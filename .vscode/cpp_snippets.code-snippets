{
	"leetcode solution":{
		"description": "leetcode template",
		"body": [
			"#include \"IO/LeetcodeIO.h\"",
			"using namespace std;",
			"",
			"#define all(a) std::begin(a), std::end(a)",
			"#define rall(a) std::rbegin(a), std::rend(a)",
			"template <typename _Tp, typename _Fp, typename _Compare = std::less<void>>",
			"bool chmax(_Tp &a, const _Fp &b, _Compare __comp = _Compare()) { return __comp(a, b) ? a = b, true : false; }",
			"template <typename _Tp, typename _Fp, typename _Compare = std::less<void>>",
			"bool chmin(_Tp &a, const _Fp &b, _Compare __comp = _Compare()) { return __comp(b, a) ? a = b, true : false; }",
			"template <typename _Tp>",
			"constexpr std::array<std::array<_Tp, 2>, 4> getNeighbors(_Tp i, _Tp j) { return {{{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}}}; }",
			"",
			"",
			"",
			"int main() {",
			"    REGISTER_CONSTRUCTOR_SOLUTION;",
			"    REGISTER_MEMBERFUNCTION_SOLUTION();",
			"    while (true) {",
			"        executor.constructSolution();",
			"        executor.executeSolution();",
			"    }",
			"}",
		],
		"prefix": "LEETCODE"
	},
	"leetcode class":{
		"description": "leetcode template",
		"body": [
			"#include \"IO/LeetcodeIO.h\"",
			"using namespace std;",
			"",
			"#define all(a) std::begin(a), std::end(a)",
			"#define rall(a) std::rbegin(a), std::rend(a)",
			"template <typename _Tp, typename _Fp, typename _Compare = std::less<void>>",
			"bool chmax(_Tp &a, const _Fp &b, _Compare __comp = _Compare()) { return __comp(a, b) ? a = b, true : false; }",
			"template <typename _Tp, typename _Fp, typename _Compare = std::less<void>>",
			"bool chmin(_Tp &a, const _Fp &b, _Compare __comp = _Compare()) { return __comp(b, a) ? a = b, true : false; }",
			"template <typename _Tp>",
			"constexpr std::array<std::array<_Tp, 2>, 4> getNeighbors(_Tp i, _Tp j) { return {{{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}}}; }",
			"",
			"",
			"",
			"int main() {",
			"    REGISTER_CONSTRUCTOR_CLASS();",
			"    REGISTER_MEMBERFUNCTION_CLASS();",
			"",
			"    while (true) {",
			"        executor.constructClass();",
			"        while (executor) {",
			"            executor.executeClass();",
			"        }",
			"    }",
			"}",
		],
		"prefix": "LEETCODE"
	},
    "O3":{
        "prefix": "o3",
        "body": [
			"#pragma GCC optimize(3,\"Ofast\",\"inline\")",
        ],
        "description": "o3"
    },
	"Luogu template":{
		"prefix": "LUOGU",
		"body": [
			"#include <algorithm>",
			"#include <array>",
			"#include <bit>",
			"#include <bitset>",
			"#include <cassert>",
			"#include <climits>",
			"#include <cstring>",
			"#include <iostream>",
			"#include <list>",
			"#include <map>",
			"#include <memory>",
			"#include <queue>",
			"#include <random>",
			"#include <set>",
			"#include <sstream>",
			"#include <stack>",
			"#include <unordered_set>",
			"#ifdef OY_LOCAL",
			"#include <windows.h>",
			"// split to make windows.h before psapi.h",
			"#include <psapi.h>",
			"#endif",
			"#define all(a) std::begin(a), std::end(a)",
			"#define rall(a) std::rbegin(a), std::rend(a)",
			"template <typename _Tp, typename _Fp, typename _Compare = std::less<void>>",
			"bool chmax(_Tp &a, const _Fp &b, _Compare __comp = _Compare()) { return __comp(a, b) ? a = b, true : false; }",
			"template <typename _Tp, typename _Fp, typename _Compare = std::less<void>>",
			"bool chmin(_Tp &a, const _Fp &b, _Compare __comp = _Compare()) { return __comp(b, a) ? a = b, true : false; }",
			"namespace OY {",
			"#define cin OY::inputHelper<1 << 10, 20>::getInstance()",
			"#define getchar() ({char c=cin.getChar_Checked();cin.next();c; })",
			"#define cout OY::outputHelper<1 << 20>::getInstance()",
			"#define putchar cout.putChar",
			"#define endl '\\n'",
			"#define putlog(...) OY::printLog(\", \", __VA_ARGS__)",
			"    template <uint64_t _BufferSize = 1 << 10, uint64_t _BlockSize = 20>",
			"    class inputHelper {",
			"    public:",
			"        FILE *m_filePtr;",
			"        char m_buf[_BufferSize], *m_end, *m_cursor;",
			"        bool m_ok;",
			"        void flush() {",
			"            uint64_t a = m_end - m_cursor;",
			"            if (a >= _BlockSize) return;",
			"            memmove(m_buf, m_cursor, a);",
			"            uint64_t b = fread(m_buf + a, 1, _BufferSize - a, m_filePtr);",
			"            m_cursor = m_buf;",
			"            if (a + b < _BufferSize) {",
			"                m_end = m_buf + a + b;",
			"                *m_end = EOF;",
			"            }",
			"        }",
			"",
			"    public:",
			"        explicit inputHelper(const char *inputFileName) : m_ok(true) {",
			"            if (!*inputFileName)",
			"                m_filePtr = stdin;",
			"            else",
			"                m_filePtr = fopen(inputFileName, \"rt\");",
			"            m_end = m_cursor = m_buf + _BufferSize;",
			"        }",
			"        ~inputHelper() { fclose(m_filePtr); }",
			"        static inputHelper<_BufferSize, _BlockSize> &getInstance() {",
			"#ifdef OY_LOCAL",
			"            static inputHelper<_BufferSize, _BlockSize> s_obj(\"in.txt\");",
			"#else",
			"            static inputHelper<_BufferSize, _BlockSize> s_obj(\"\");",
			"#endif",
			"            return s_obj;",
			"        }",
			"        static constexpr bool isBlank(char c) { return c == ' ' || c == '\\t' || c == '\\n' || c == '\\r'; }",
			"        static constexpr bool isEndline(char c) { return c == '\\n' || c == EOF; }",
			"        const char &getChar_Checked() {",
			"            if (m_cursor < m_end) return *m_cursor;",
			"            uint64_t b = fread(m_buf, 1, _BufferSize, m_filePtr);",
			"            m_cursor = m_buf;",
			"            if (b < _BufferSize) {",
			"                m_end = m_buf + b;",
			"                *m_end = EOF;",
			"            }",
			"            return *m_cursor;",
			"        }",
			"        const char &getChar_Unchecked() const { return *m_cursor; }",
			"        void next() { ++m_cursor; }",
			"        void setState(bool _ok) { m_ok = _ok; }",
			"        template <typename _Tp, typename std::enable_if<std::is_signed<_Tp>::value & std::is_integral<_Tp>::value>::type * = nullptr>",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(_Tp &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            flush();",
			"            if (getChar_Unchecked() == '-') {",
			"                next();",
			"                if (isdigit(getChar_Unchecked())) {",
			"                    ret = -(getChar_Unchecked() - '0');",
			"                    while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 - (getChar_Unchecked() - '0');",
			"                } else",
			"                    m_ok = false;",
			"            } else {",
			"                if (isdigit(getChar_Unchecked())) {",
			"                    ret = getChar_Unchecked() - '0';",
			"                    while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 + (getChar_Unchecked() - '0');",
			"                } else",
			"                    m_ok = false;",
			"            }",
			"            return *this;",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_unsigned<_Tp>::value & std::is_integral<_Tp>::value>::type * = nullptr>",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(_Tp &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            flush();",
			"            if (isdigit(getChar_Unchecked())) {",
			"                ret = getChar_Unchecked() - '0';",
			"                while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 + (getChar_Unchecked() - '0');",
			"            } else",
			"                m_ok = false;",
			"            return *this;",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_floating_point<_Tp>::value>::type * = nullptr>",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(_Tp &ret) {",
			"            bool neg = false, integer = false, decimal = false;",
			"            while (isBlank(getChar_Checked())) next();",
			"            flush();",
			"            if (getChar_Unchecked() == '-') {",
			"                neg = true;",
			"                next();",
			"            }",
			"            if (!isdigit(getChar_Unchecked()) && getChar_Unchecked() != '.') {",
			"                m_ok = false;",
			"                return *this;",
			"            }",
			"            if (isdigit(getChar_Unchecked())) {",
			"                integer = true;",
			"                ret = getChar_Unchecked() - '0';",
			"                while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 + (getChar_Unchecked() - '0');",
			"            }",
			"            if (getChar_Unchecked() == '.') {",
			"                next();",
			"                if (isdigit(getChar_Unchecked())) {",
			"                    if (!integer) ret = 0;",
			"                    decimal = true;",
			"                    _Tp unit = 0.1;",
			"                    ret += unit * (getChar_Unchecked() - '0');",
			"                    while (next(), isdigit(getChar_Unchecked())) {",
			"                        unit *= 0.1;",
			"                        ret += unit * (getChar_Unchecked() - '0');",
			"                    }",
			"                }",
			"            }",
			"            if (!integer && !decimal)",
			"                m_ok = false;",
			"            else if (neg)",
			"                ret = -ret;",
			"            return *this;",
			"        }",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(char &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            ret = getChar_Checked();",
			"            if (ret == EOF)",
			"                m_ok = false;",
			"            else",
			"                next();",
			"            return *this;",
			"        }",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(std::string &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            if (getChar_Checked() != EOF) {",
			"                ret.clear();",
			"                do {",
			"                    ret += getChar_Checked();",
			"                    next();",
			"                } while (!isBlank(getChar_Checked()) && getChar_Unchecked() != EOF);",
			"            } else",
			"                m_ok = false;",
			"            return *this;",
			"        }",
			"        explicit operator bool() { return m_ok; }",
			"    };",
			"    template <uint64_t _BufferSize = 1 << 20>",
			"    class outputHelper {",
			"        FILE *m_filePtr = nullptr;",
			"        char m_buf[_BufferSize], *m_end, *m_cursor;",
			"        char m_tempBuf[50], *m_tempBufCursor, *m_tempBufDot;",
			"        uint64_t m_floatReserve, m_floatRatio;",
			"",
			"    public:",
			"        outputHelper(const char *outputFileName, int prec = 6) : m_end(m_buf + _BufferSize) {",
			"            if (!*outputFileName)",
			"                m_filePtr = stdout;",
			"            else",
			"                m_filePtr = fopen(outputFileName, \"wt\");",
			"            m_cursor = m_buf;",
			"            m_tempBufCursor = m_tempBuf;",
			"            precision(prec);",
			"        }",
			"        static outputHelper<_BufferSize> &getInstance() {",
			"#ifdef OY_LOCAL",
			"            static outputHelper<_BufferSize> s_obj(\"out.txt\");",
			"#else",
			"            static outputHelper<_BufferSize> s_obj(\"\");",
			"#endif",
			"            return s_obj;",
			"        }",
			"        ~outputHelper() {",
			"            flush();",
			"            fclose(m_filePtr);",
			"        }",
			"        void precision(int prec) {",
			"            m_floatReserve = prec;",
			"            m_floatRatio = pow(10, prec);",
			"            m_tempBufDot = m_tempBuf + prec;",
			"        }",
			"        outputHelper<_BufferSize> &flush() {",
			"            fwrite(m_buf, 1, m_cursor - m_buf, m_filePtr);",
			"            fflush(m_filePtr);",
			"            m_cursor = m_buf;",
			"            return *this;",
			"        }",
			"        void putChar(const char &c) {",
			"            if (m_cursor == m_end) flush();",
			"            *m_cursor++ = c;",
			"        }",
			"        void putS(const char *c) {",
			"            while (*c) putChar(*c++);",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_signed<_Tp>::value & std::is_integral<_Tp>::value>::type * = nullptr>",
			"        outputHelper<_BufferSize> &operator<<(const _Tp &ret) {",
			"            _Tp _ret = _Tp(ret);",
			"            if (_ret >= 0) {",
			"                do {",
			"                    *m_tempBufCursor++ = '0' + _ret % 10;",
			"                    _ret /= 10;",
			"                } while (_ret);",
			"                do putChar(*--m_tempBufCursor);",
			"                while (m_tempBufCursor > m_tempBuf);",
			"            } else {",
			"                putChar('-');",
			"                do {",
			"                    *m_tempBufCursor++ = '0' - _ret % 10;",
			"                    _ret /= 10;",
			"                } while (_ret);",
			"                do putChar(*--m_tempBufCursor);",
			"                while (m_tempBufCursor > m_tempBuf);",
			"            }",
			"            return *this;",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_unsigned<_Tp>::value & std::is_integral<_Tp>::value>::type * = nullptr>",
			"        outputHelper<_BufferSize> &operator<<(const _Tp &ret) {",
			"            _Tp _ret = _Tp(ret);",
			"            do {",
			"                *m_tempBufCursor++ = '0' + _ret % 10;",
			"                _ret /= 10;",
			"            } while (_ret);",
			"            do putChar(*--m_tempBufCursor);",
			"            while (m_tempBufCursor > m_tempBuf);",
			"            return *this;",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_floating_point<_Tp>::value>::type * = nullptr>",
			"        outputHelper<_BufferSize> &operator<<(const _Tp &ret) {",
			"            if (ret < 0) {",
			"                putChar('-');",
			"                return *this << -ret;",
			"            }",
			"            _Tp _ret = ret * m_floatRatio;",
			"            uint64_t integer = _ret;",
			"            if (_ret - integer >= 0.4999999999) integer++;",
			"            do {",
			"                *m_tempBufCursor++ = '0' + integer % 10;",
			"                integer /= 10;",
			"            } while (integer);",
			"            if (m_tempBufCursor > m_tempBufDot) {",
			"                do putChar(*--m_tempBufCursor);",
			"                while (m_tempBufCursor > m_tempBufDot);",
			"                putChar('.');",
			"            } else {",
			"                putS(\"0.\");",
			"                for (int i = m_tempBufDot - m_tempBufCursor; i--;) putChar('0');",
			"            }",
			"            do putChar(*--m_tempBufCursor);",
			"            while (m_tempBufCursor > m_tempBuf);",
			"            return *this;",
			"        }",
			"        outputHelper<_BufferSize> &operator<<(const char &ret) {",
			"            putChar(ret);",
			"            return *this;",
			"        }",
			"        outputHelper<_BufferSize> &operator<<(const std::string &ret) {",
			"            putS(ret.data());",
			"            return *this;",
			"        }",
			"    };",
			"    template <uint64_t _BufferSize, uint64_t _BlockSize>",
			"    inputHelper<_BufferSize, _BlockSize> &getline(inputHelper<_BufferSize, _BlockSize> &ih, std::string &ret) {",
			"        ret.clear();",
			"        if (ih.getChar_Checked() == EOF)",
			"            ih.setState(false);",
			"        else {",
			"            while (!inputHelper<_BufferSize, _BlockSize>::isEndline(ih.getChar_Checked())) {",
			"                ret += ih.getChar_Unchecked();",
			"                ih.next();",
			"            }",
			"            ih.next();",
			"        }",
			"        return ih;",
			"    }",
			"    template <typename D, typename T, typename... S>",
			"    void printLog(D delim, const T &x, S... rest) {",
			"        cout << x;",
			"        if constexpr (sizeof...(rest) > 0) {",
			"            cout << delim;",
			"            printLog(delim, rest...);",
			"        }",
			"    }",
			"}",
			"using OY::getline;",
			"auto tam = [] {",
			"#ifdef OY_LOCAL",
			"#define CHECKTIME tam.stop()",
			"    struct TIME_AND_MEMORY {static auto GetMicroSecond() {static FILETIME ft;GetSystemTimeAsFileTime(&ft);return ft.dwLowDateTime;};static auto GetMemory() {PROCESS_MEMORY_COUNTERS pmc;GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));return pmc.WorkingSetSize;}uint32_t t0, t1;TIME_AND_MEMORY() : t0(GetMicroSecond()) {}void stop() {t1 = GetMicroSecond();cout << \"\\ntime cost = \" << (t1 - t0) / 10000.0 << \" ms\\nmemory cost = \" << (GetMemory() >> 20) << \" MB\\n \";t0 = t1;}~TIME_AND_MEMORY() { stop(); }};return TIME_AND_MEMORY();",
			"#else",
			"#define CHECKTIME",
			"    return 0;",
			"#endif",
			"}();",
			"",
			"int main() {",
			"    ",
			"    CHECKTIME;",
			"}",
		],
		"description": "Luogu template"
	},
	"Codeforces template":{
		"prefix": "CF",
		"body": [
			"#include <bits/stdc++.h>",
			"#ifdef OY_LOCAL",
			"#include <windows.h>",
			"// split to make windows.h before psapi.h",
			"#include <psapi.h>",
			"#endif",
			"#define all(a) std::begin(a), std::end(a)",
			"#define rall(a) std::rbegin(a), std::rend(a)",
			"template <typename _Tp, typename _Fp, typename _Compare = std::less<void>>",
			"bool chmax(_Tp &a, const _Fp &b, _Compare __comp = _Compare()) { return __comp(a, b) ? a = b, true : false; }",
			"template <typename _Tp, typename _Fp, typename _Compare = std::less<void>>",
			"bool chmin(_Tp &a, const _Fp &b, _Compare __comp = _Compare()) { return __comp(b, a) ? a = b, true : false; }",
			"#define YESNO(condition) if(condition)cout<<\"YES\\n\";else cout<<\"NO\\n\";",
			"using std::cin,std::cout,std::endl;auto tam = [] {std::ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
			"#ifdef OY_LOCAL",
			"#define CHECKTIME tam.stop()",
			"    freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);struct TIME_AND_MEMORY {static auto GetMicroSecond() {static FILETIME ft;GetSystemTimeAsFileTime(&ft);return ft.dwLowDateTime;};static auto GetMemory() {PROCESS_MEMORY_COUNTERS pmc;GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));return pmc.WorkingSetSize;}uint32_t t0, t1;TIME_AND_MEMORY() : t0(GetMicroSecond()) {}void stop() {t1 = GetMicroSecond();cout << \"\\ntime cost = \" << (t1 - t0) / 10000.0 << \" ms\\nmemory cost = \" << (GetMemory() >> 20) << \" MB\\n \";t0 = t1;}~TIME_AND_MEMORY() { stop(); }};return TIME_AND_MEMORY();",
			"#else",
			"#define CHECKTIME",
			"    return 0;",
			"#endif",
			"}();",
			"",
			"int main() {",
			"    int t;cin>>t;",
			"    while(t--){",
			"        int n;cin>>n;",
			"        int A[n];for(auto&a:A)cin>>a;",
			"    }",
			"}",
		],
		"description": "codeforces template"
	},
	"pat":{
		"prefix": "PAT",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"int main(){",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"    cout.tie(0);",
			"#ifndef ONLINE_JUDGE",
			"    freopen(\"in.txt\",\"r\",stdin);",
			"    freopen(\"out.txt\",\"w\",stdout);",
			"#endif",
			"}",
			"",
		],
		"description": "pat"
	},
    "io synch":{
        "prefix": "IOS",
        "body": [
            "using std::cin,std::cout,std::endl;int _IO=[]{std::ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);",
			"#ifdef OY_LOCAL",
			"    freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);",
			"#endif",
			"return 0;}();",
        ],
        "description": "io synch"
    },
    "fast io":{
        "prefix": "IO",
        "body": [
			"namespace OY {",
			"#define cin OY::inputHelper<1 << 10, 20>::getInstance()",
			"#define getchar() ({char c=cin.getChar_Checked();cin.next();c; })",
			"#define cout OY::outputHelper<1 << 20>::getInstance()",
			"#define putchar cout.putChar",
			"#define endl '\\n'",
			"#define putlog(...) OY::printLog(\", \", __VA_ARGS__)",
			"    template <uint64_t _BufferSize = 1 << 10, uint64_t _BlockSize = 20>",
			"    class inputHelper {",
			"    public:",
			"        FILE *m_filePtr;",
			"        char m_buf[_BufferSize], *m_end, *m_cursor;",
			"        bool m_ok;",
			"        void flush() {",
			"            uint64_t a = m_end - m_cursor;",
			"            if (a >= _BlockSize) return;",
			"            memmove(m_buf, m_cursor, a);",
			"            uint64_t b = fread(m_buf + a, 1, _BufferSize - a, m_filePtr);",
			"            m_cursor = m_buf;",
			"            if (a + b < _BufferSize) {",
			"                m_end = m_buf + a + b;",
			"                *m_end = EOF;",
			"            }",
			"        }",
			"",
			"    public:",
			"        explicit inputHelper(const char *inputFileName) : m_ok(true) {",
			"            if (!*inputFileName)",
			"                m_filePtr = stdin;",
			"            else",
			"                m_filePtr = fopen(inputFileName, \"rt\");",
			"            m_end = m_cursor = m_buf + _BufferSize;",
			"        }",
			"        ~inputHelper() { fclose(m_filePtr); }",
			"        static inputHelper<_BufferSize, _BlockSize> &getInstance() {",
			"#ifdef OY_LOCAL",
			"            static inputHelper<_BufferSize, _BlockSize> s_obj(\"in.txt\");",
			"#else",
			"            static inputHelper<_BufferSize, _BlockSize> s_obj(\"\");",
			"#endif",
			"            return s_obj;",
			"        }",
			"        static constexpr bool isBlank(char c) { return c == ' ' || c == '\\t' || c == '\\n' || c == '\\r'; }",
			"        static constexpr bool isEndline(char c) { return c == '\\n' || c == EOF; }",
			"        const char &getChar_Checked() {",
			"            if (m_cursor < m_end) return *m_cursor;",
			"            uint64_t b = fread(m_buf, 1, _BufferSize, m_filePtr);",
			"            m_cursor = m_buf;",
			"            if (b < _BufferSize) {",
			"                m_end = m_buf + b;",
			"                *m_end = EOF;",
			"            }",
			"            return *m_cursor;",
			"        }",
			"        const char &getChar_Unchecked() const { return *m_cursor; }",
			"        void next() { ++m_cursor; }",
			"        void setState(bool _ok) { m_ok = _ok; }",
			"        template <typename _Tp, typename std::enable_if<std::is_signed<_Tp>::value & std::is_integral<_Tp>::value>::type * = nullptr>",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(_Tp &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            flush();",
			"            if (getChar_Unchecked() == '-') {",
			"                next();",
			"                if (isdigit(getChar_Unchecked())) {",
			"                    ret = -(getChar_Unchecked() - '0');",
			"                    while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 - (getChar_Unchecked() - '0');",
			"                } else",
			"                    m_ok = false;",
			"            } else {",
			"                if (isdigit(getChar_Unchecked())) {",
			"                    ret = getChar_Unchecked() - '0';",
			"                    while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 + (getChar_Unchecked() - '0');",
			"                } else",
			"                    m_ok = false;",
			"            }",
			"            return *this;",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_unsigned<_Tp>::value & std::is_integral<_Tp>::value>::type * = nullptr>",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(_Tp &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            flush();",
			"            if (isdigit(getChar_Unchecked())) {",
			"                ret = getChar_Unchecked() - '0';",
			"                while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 + (getChar_Unchecked() - '0');",
			"            } else",
			"                m_ok = false;",
			"            return *this;",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_floating_point<_Tp>::value>::type * = nullptr>",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(_Tp &ret) {",
			"            bool neg = false, integer = false, decimal = false;",
			"            while (isBlank(getChar_Checked())) next();",
			"            flush();",
			"            if (getChar_Unchecked() == '-') {",
			"                neg = true;",
			"                next();",
			"            }",
			"            if (!isdigit(getChar_Unchecked()) && getChar_Unchecked() != '.') {",
			"                m_ok = false;",
			"                return *this;",
			"            }",
			"            if (isdigit(getChar_Unchecked())) {",
			"                integer = true;",
			"                ret = getChar_Unchecked() - '0';",
			"                while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 + (getChar_Unchecked() - '0');",
			"            }",
			"            if (getChar_Unchecked() == '.') {",
			"                next();",
			"                if (isdigit(getChar_Unchecked())) {",
			"                    if (!integer) ret = 0;",
			"                    decimal = true;",
			"                    _Tp unit = 0.1;",
			"                    ret += unit * (getChar_Unchecked() - '0');",
			"                    while (next(), isdigit(getChar_Unchecked())) {",
			"                        unit *= 0.1;",
			"                        ret += unit * (getChar_Unchecked() - '0');",
			"                    }",
			"                }",
			"            }",
			"            if (!integer && !decimal)",
			"                m_ok = false;",
			"            else if (neg)",
			"                ret = -ret;",
			"            return *this;",
			"        }",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(char &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            ret = getChar_Checked();",
			"            if (ret == EOF)",
			"                m_ok = false;",
			"            else",
			"                next();",
			"            return *this;",
			"        }",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(std::string &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            if (getChar_Checked() != EOF) {",
			"                ret.clear();",
			"                do {",
			"                    ret += getChar_Checked();",
			"                    next();",
			"                } while (!isBlank(getChar_Checked()) && getChar_Unchecked() != EOF);",
			"            } else",
			"                m_ok = false;",
			"            return *this;",
			"        }",
			"        explicit operator bool() { return m_ok; }",
			"    };",
			"    template <uint64_t _BufferSize = 1 << 20>",
			"    class outputHelper {",
			"        FILE *m_filePtr = nullptr;",
			"        char m_buf[_BufferSize], *m_end, *m_cursor;",
			"        char m_tempBuf[50], *m_tempBufCursor, *m_tempBufDot;",
			"        uint64_t m_floatReserve, m_floatRatio;",
			"",
			"    public:",
			"        outputHelper(const char *outputFileName, int prec = 6) : m_end(m_buf + _BufferSize) {",
			"            if (!*outputFileName)",
			"                m_filePtr = stdout;",
			"            else",
			"                m_filePtr = fopen(outputFileName, \"wt\");",
			"            m_cursor = m_buf;",
			"            m_tempBufCursor = m_tempBuf;",
			"            precision(prec);",
			"        }",
			"        static outputHelper<_BufferSize> &getInstance() {",
			"#ifdef OY_LOCAL",
			"            static outputHelper<_BufferSize> s_obj(\"out.txt\");",
			"#else",
			"            static outputHelper<_BufferSize> s_obj(\"\");",
			"#endif",
			"            return s_obj;",
			"        }",
			"        ~outputHelper() {",
			"            flush();",
			"            fclose(m_filePtr);",
			"        }",
			"        void precision(int prec) {",
			"            m_floatReserve = prec;",
			"            m_floatRatio = pow(10, prec);",
			"            m_tempBufDot = m_tempBuf + prec;",
			"        }",
			"        outputHelper<_BufferSize> &flush() {",
			"            fwrite(m_buf, 1, m_cursor - m_buf, m_filePtr);",
			"            fflush(m_filePtr);",
			"            m_cursor = m_buf;",
			"            return *this;",
			"        }",
			"        void putChar(const char &c) {",
			"            if (m_cursor == m_end) flush();",
			"            *m_cursor++ = c;",
			"        }",
			"        void putS(const char *c) {",
			"            while (*c) putChar(*c++);",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_signed<_Tp>::value & std::is_integral<_Tp>::value>::type * = nullptr>",
			"        outputHelper<_BufferSize> &operator<<(const _Tp &ret) {",
			"            _Tp _ret = _Tp(ret);",
			"            if (_ret >= 0) {",
			"                do {",
			"                    *m_tempBufCursor++ = '0' + _ret % 10;",
			"                    _ret /= 10;",
			"                } while (_ret);",
			"                do putChar(*--m_tempBufCursor);",
			"                while (m_tempBufCursor > m_tempBuf);",
			"            } else {",
			"                putChar('-');",
			"                do {",
			"                    *m_tempBufCursor++ = '0' - _ret % 10;",
			"                    _ret /= 10;",
			"                } while (_ret);",
			"                do putChar(*--m_tempBufCursor);",
			"                while (m_tempBufCursor > m_tempBuf);",
			"            }",
			"            return *this;",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_unsigned<_Tp>::value & std::is_integral<_Tp>::value>::type * = nullptr>",
			"        outputHelper<_BufferSize> &operator<<(const _Tp &ret) {",
			"            _Tp _ret = _Tp(ret);",
			"            do {",
			"                *m_tempBufCursor++ = '0' + _ret % 10;",
			"                _ret /= 10;",
			"            } while (_ret);",
			"            do putChar(*--m_tempBufCursor);",
			"            while (m_tempBufCursor > m_tempBuf);",
			"            return *this;",
			"        }",
			"        template <typename _Tp, typename std::enable_if<std::is_floating_point<_Tp>::value>::type * = nullptr>",
			"        outputHelper<_BufferSize> &operator<<(const _Tp &ret) {",
			"            if (ret < 0) {",
			"                putChar('-');",
			"                return *this << -ret;",
			"            }",
			"            _Tp _ret = ret * m_floatRatio;",
			"            uint64_t integer = _ret;",
			"            if (_ret - integer >= 0.4999999999) integer++;",
			"            do {",
			"                *m_tempBufCursor++ = '0' + integer % 10;",
			"                integer /= 10;",
			"            } while (integer);",
			"            if (m_tempBufCursor > m_tempBufDot) {",
			"                do putChar(*--m_tempBufCursor);",
			"                while (m_tempBufCursor > m_tempBufDot);",
			"                putChar('.');",
			"            } else {",
			"                putS(\"0.\");",
			"                for (int i = m_tempBufDot - m_tempBufCursor; i--;) putChar('0');",
			"            }",
			"            do putChar(*--m_tempBufCursor);",
			"            while (m_tempBufCursor > m_tempBuf);",
			"            return *this;",
			"        }",
			"        outputHelper<_BufferSize> &operator<<(const char &ret) {",
			"            putChar(ret);",
			"            return *this;",
			"        }",
			"        outputHelper<_BufferSize> &operator<<(const std::string &ret) {",
			"            putS(ret.data());",
			"            return *this;",
			"        }",
			"    };",
			"    template <uint64_t _BufferSize, uint64_t _BlockSize>",
			"    inputHelper<_BufferSize, _BlockSize> &getline(inputHelper<_BufferSize, _BlockSize> &ih, std::string &ret) {",
			"        ret.clear();",
			"        if (ih.getChar_Checked() == EOF)",
			"            ih.setState(false);",
			"        else {",
			"            while (!inputHelper<_BufferSize, _BlockSize>::isEndline(ih.getChar_Checked())) {",
			"                ret += ih.getChar_Unchecked();",
			"                ih.next();",
			"            }",
			"            ih.next();",
			"        }",
			"        return ih;",
			"    }",
			"    template <typename D, typename T, typename... S>",
			"    void printLog(D delim, const T &x, S... rest) {",
			"        cout << x;",
			"        if constexpr (sizeof...(rest) > 0) {",
			"            cout << delim;",
			"            printLog(delim, rest...);",
			"        }",
			"    }",
			"}",
			"using OY::getline;",
        ],
        "description": "fast io"
    },
	"time and local":{
		"prefix": "TAM",
		"body": [
			"auto tam = [] {",
			"#ifdef OY_LOCAL",
			"#define CHECKTIME tam.stop()",
			"    struct TIME_AND_MEMORY {static auto GetMicroSecond() {static FILETIME ft;GetSystemTimeAsFileTime(&ft);return ft.dwLowDateTime;};static auto GetMemory() {PROCESS_MEMORY_COUNTERS pmc;GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));return pmc.WorkingSetSize;}uint32_t t0, t1;TIME_AND_MEMORY() : t0(GetMicroSecond()) {}void stop() {t1 = GetMicroSecond();cout << \"\\ntime cost = \" << (t1 - t0) / 10000.0 << \" ms\\nmemory cost = \" << (GetMemory() >> 20) << \" MB\\n \";t0 = t1;}~TIME_AND_MEMORY() { stop(); }};return TIME_AND_MEMORY();",
			"#else",
			"#define CHECKTIME",
			"    return 0;",
			"#endif",
			"}();",
		],
		"description": "time and local"
	},
	"time and memory:windows":{
		"prefix": "TIME",
		"body": [
			"//#include <windows.h>",
			"//#include <psapi.h>",
			"auto GetMicroSecond=[](){static FILETIME ft;GetSystemTimeAsFileTime(&ft);return ft.dwLowDateTime;};auto t1=GetMicroSecond();",
			"auto t2=GetMicroSecond();cout<<\"\\ntime cost=\"<<(t2-t1)/10000.0<<\"ms\\n\";PROCESS_MEMORY_COUNTERS pmc;GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));cout<<\"memory cost=\"<<(pmc.WorkingSetSize>>20)<<\"MB\\n\";",
		],
		"description": "time and memory"
	},
	"time and memory:linux":{
		"prefix": "TIME",
		"body": [
			"//#include \"sys/time.h\"",
			"auto GetMicroSecond=[](){static timeval ft;gettimeofday(&ft,nullptr);return ft.tv_sec*1000000+ft.tv_usec;};auto t1=GetMicroSecond();",
			"auto t2=GetMicroSecond();cout<<\"\\ntime cost=\"<<(t2-t1)/1000.0<<\"ms\\n\";{char _mem_buff[512]={0};int used,now_use;fgets(_mem_buff,sizeof(_mem_buff),fopen(\"/proc/self/statm\",\"r\"));sscanf(_mem_buff,\"%d %d\",&used,&now_use);cout<<used/250.0<<\" MB used, \"<<now_use/250.0<<\" MB is now using\\n\";}"
		],
		"description": "time and memory"
	},
	"POLY":{
		"prefix": "POLY",
		"body": [
			"using mint=OY::StaticModInt32<998244353,true>;",
			"using poly=OY::NTTPolynomial<mint,1<<21>;",
			"auto poly_init=[]{return poly::s_primitiveRoot=3;}();"
		],
		"description": "NTT Poly"
	},

	"accumulator":{
		"prefix": "ACC",
		"body": [
			"namespace OY {",
			"    enum ACCUMULATE_TYPE {",
			"        ACCUMULATE_PREFIX = 1,",
			"        ACCUMULATE_SUFFIX = 2",
			"    };",
			"    template <typename _Tp = int64_t, typename _Operation = std::plus<_Tp>, int _Mask = ACCUMULATE_PREFIX | ACCUMULATE_SUFFIX>",
			"    class Accumulator {",
			"        std::vector<_Tp> m_val;",
			"        std::vector<_Tp> m_prefix;",
			"        std::vector<_Tp> m_suffix;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        void _update(int i, int j) {",
			"            if constexpr ((_Mask & ACCUMULATE_PREFIX) != 0) {",
			"                m_prefix.resize(i);",
			"                m_prefix.reserve(m_val.size());",
			"                for (; i < m_val.size(); i++) m_prefix.push_back(i ? m_op(m_prefix.back(), m_val[i]) : m_val[i]);",
			"            }",
			"            if constexpr ((_Mask & ACCUMULATE_SUFFIX) != 0) {",
			"                m_suffix.resize(m_val.size());",
			"                if (j == m_val.size() - 1)",
			"                    std::partial_sum(m_val.rbegin(), m_val.rend(), m_suffix.rbegin(), m_op);",
			"                else",
			"                    for (; j >= 0; j--) m_suffix[j] = m_op(m_suffix[j + 1], m_val[j]);",
			"            }",
			"        }",
			"",
			"    public:",
			"        Accumulator(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        Accumulator(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_val.assign(__n, m_defaultValue);",
			"            _update(0, m_val.size() - 1);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_val.assign(__first, __last);",
			"            _update(0, m_val.size() - 1);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            m_val[__i] = __val;",
			"            _update(__i, __i);",
			"        }",
			"        _Tp queryPrefix(int __i) const {",
			"            static_assert((_Mask & ACCUMULATE_PREFIX) != 0);",
			"            return m_prefix[__i];",
			"        }",
			"        _Tp querySuffix(int __i) const {",
			"            static_assert((_Mask & ACCUMULATE_SUFFIX) != 0);",
			"            return m_suffix[__i];",
			"        }",
			"        _Tp query(int __i) const { return m_val[__i]; }",
			"        _Tp query(int __left, int __right) const { return std::accumulate(m_val.begin() + __left + 1, m_val.begin() + __right + 1, m_val[__left], m_op); }",
			"        _Tp queryAll() const {",
			"            if constexpr ((_Mask & ACCUMULATE_PREFIX) != 0)",
			"                return m_prefix.back();",
			"            else if constexpr ((_Mask & ACCUMULATE_SUFFIX) != 0)",
			"                return m_suffix.front();",
			"            else",
			"                return query(0, m_val.size() - 1);",
			"        }",
			"    };",
			"    template <typename _Tp = int64_t, int _Mask = 3>",
			"    Accumulator(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, const _Tp &(*)(const _Tp &, const _Tp &), _Mask>;",
			"    template <typename _Tp = int64_t, int _Mask = 3>",
			"    Accumulator(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, _Tp (*)(_Tp, _Tp), _Mask>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, int _Mask = 3>",
			"    Accumulator(int = 0, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, _Operation, _Mask>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, int _Mask = 3>",
			"    Accumulator(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, const _Tp &(*)(const _Tp &, const _Tp &), _Mask>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, int _Mask = 3>",
			"    Accumulator(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, _Tp (*)(_Tp, _Tp), _Mask>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>, int _Mask = 3>",
			"    Accumulator(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, _Operation, _Mask>;",
			"}",
		],
		"description": "accumulator"
	},
	"adjacent difference 2d":{
		"prefix": "AD2D",
		"body": [
			"namespace OY {",
			"    enum AD2d_STATE {",
			"        AD2D_ANY = 0,",
			"        AD2D_DIFFERENCE = 1,",
			"        AD2D_VALUE = 2,",
			"        AD2D_PRESUM = 3",
			"    };",
			"    template <typename _Tp>",
			"    class AdjacentDifference2d {",
			"        std::vector<std::vector<_Tp>> m_values;",
			"        AD2d_STATE m_state;",
			"",
			"    public:",
			"        AdjacentDifference2d(uint32_t __m, uint32_t __n) : m_values(__m + 2, std::vector<_Tp>(__n + 2)), m_state(AD2D_ANY) {}",
			"        void add(uint32_t __i, uint32_t __j, _Tp __inc) {",
			"            if (m_state == AD2D_DIFFERENCE)",
			"                m_values[__i + 1][__j + 2] -= __inc, m_values[__i + 2][__j + 1] -= __inc, m_values[__i + 1][__j + 1] += __inc, m_values[__i + 2][__j + 2] += __inc;",
			"            else {",
			"                switchTo(AD2D_VALUE);",
			"                m_values[__i + 1][__j + 1] += __inc;",
			"            }",
			"        }",
			"        void add(uint32_t __r1, uint32_t __r2, uint32_t __c1, uint32_t __c2, _Tp __inc) {",
			"            switchTo(AD2D_DIFFERENCE);",
			"            m_values[__r1 + 1][__c2 + 2] -= __inc, m_values[__r2 + 2][__c1 + 1] -= __inc, m_values[__r1 + 1][__c1 + 1] += __inc, m_values[__r2 + 2][__c2 + 2] += __inc;",
			"        }",
			"        _Tp query(uint32_t __i, uint32_t __j) {",
			"            switchTo(AD2D_VALUE);",
			"            return m_values[__i + 1][__j + 1];",
			"        }",
			"        _Tp query(uint32_t __r1, uint32_t __r2, uint32_t __c1, uint32_t __c2) {",
			"            switchTo(AD2D_PRESUM);",
			"            return m_values[__r2 + 1][__c2 + 1] + m_values[__r1][__c1] - m_values[__r1][__c2 + 1] - m_values[__r2 + 1][__c1];",
			"        }",
			"        void switchTo(AD2d_STATE __state) {",
			"            if (m_state == AD2D_ANY) m_state = __state;",
			"            for (; m_state < __state; m_state = AD2d_STATE(m_state + 1)) partialSum();",
			"            for (; m_state > __state; m_state = AD2d_STATE(m_state - 1)) adjacentDiffrence();",
			"        }",
			"        void adjacentDiffrence() {",
			"            for (uint32_t i = m_values.size() - 1; i; i--)",
			"                for (uint32_t j = m_values[0].size() - 1; j; j--) m_values[i][j] += m_values[i - 1][j - 1] - m_values[i][j - 1] - m_values[i - 1][j];",
			"        }",
			"        void partialSum() {",
			"            for (uint32_t i = 1; i < m_values.size(); i++)",
			"                for (uint32_t j = 1; j < m_values[0].size(); j++) m_values[i][j] -= m_values[i - 1][j - 1] - m_values[i][j - 1] - m_values[i - 1][j];",
			"        }",
			"    };",
			"}",
		],
		"description": "adjacent difference 2d"
	},
	"avl tree":{
        "prefix": "AVL",
        "body": [
			"namespace OY {",
			"    struct AVLSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct AVLMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct AVLMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _AVLNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _AVLNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = AVLMultisetTag>",
			"    class AVL {",
			"        struct node : _AVLNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            int subtree_height;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int subtree_height(node *p) { return p ? p->subtree_height : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            p->subtree_height = 1 + std::max(subtree_height(p->lchild), subtree_height(p->rchild));",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return update(q);",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return update(q);",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return update(r);",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return update(r);",
			"        }",
			"        static node *balance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (int lh = subtree_height(cur->lchild), rh = subtree_height(cur->rchild); lh > rh + 1) {",
			"                if (subtree_height(cur->lchild->lchild) > rh)",
			"                    return rrotate(cur);",
			"                else",
			"                    return lrrotate(cur);",
			"            } else if (rh > lh + 1) {",
			"                if (subtree_height(cur->rchild->rchild) > lh)",
			"                    return lrotate(cur);",
			"                else",
			"                    return rlrotate(cur);",
			"            } else",
			"                return update(cur);",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else {",
			"                cur->lchild = deleteMin(cur->lchild, res);",
			"                return balance(cur);",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        AVL(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        ~AVL() { clear(); }",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __args..., 1, 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return balance(cur);",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return balance(cur);",
			"                };",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key))",
			"                    cur->lchild = self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    cur->rchild = self(self, cur->rchild);",
			"                else {",
			"                    delete cur;",
			"                    if (!cur->rchild)",
			"                        return cur->lchild;",
			"                    else {",
			"                        node *res;",
			"                        cur->rchild = deleteMin(cur->rchild, res);",
			"                        res->lchild = cur->lchild;",
			"                        res->rchild = cur->rchild;",
			"                        cur = res;",
			"                    }",
			"                }",
			"                return balance(cur);",
			"            };",
			"            int old_weight = size();",
			"            m_root = dfs(dfs, m_root);",
			"            return old_weight != size();",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace AVLContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = AVL<_Tp, bool, _Compare, AVLSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = AVL<_Tp, bool, _Compare, AVLMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = AVL<_Tp, _Fp, _Compare, AVLMapTag>;",
			"    }",
			"}",
        ],
        "description": "avl tree"
    },
	"binary indexed tree":{
        "prefix": "BIT",
        "body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    class BIT {",
			"        std::vector<_Tp> m_sum;",
			"        _Tp m_defaultValue;",
			"        _Plus m_plus;",
			"        _Minus m_minus;",
			"        int m_length;",
			"",
			"    public:",
			"        BIT(int __n = 0, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) { resize(__n); }",
			"        template <typename _Iterator>",
			"        BIT(_Iterator __first, _Iterator __last, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) { reset(__first, __last); }",
			"        void resize(int __n) {",
			"            m_length = __n > 1 ? 1 << (32 - std::__countl_zero<uint32_t>(__n - 1)) : 1;",
			"            m_sum.assign(m_length, m_defaultValue);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = (__last - __first) > 1 ? 1 << (32 - std::__countl_zero<uint32_t>((__last - __first) - 1)) : 1;",
			"            m_sum.resize(m_length);",
			"            std::copy(__first, __last, m_sum.begin());",
			"            std::fill(m_sum.begin() + (__last - __first), m_sum.end(), m_defaultValue);",
			"            for (int i = 0; i < m_length; i++)",
			"                if (int j = i + (1 << std::__countr_zero<uint32_t>(i + 1)); j < m_length) m_sum[j] = m_plus(m_sum[j], m_sum[i]);",
			"        }",
			"        void add(int i, _Tp __inc) {",
			"            while (i < m_length) {",
			"                m_sum[i] = m_plus(m_sum[i], __inc);",
			"                i += 1 << std::__countr_zero<uint32_t>(i + 1);",
			"            }",
			"        }",
			"        _Tp presum(int i) const {",
			"            _Tp ret = m_defaultValue;",
			"            while (i >= 0) {",
			"                ret = m_plus(ret, m_sum[i]);",
			"                i -= 1 << std::__countr_zero<uint32_t>(i + 1);",
			"            }",
			"            return ret;",
			"        }",
			"        _Tp query(int i) const { return m_minus(presum(i), presum(i - 1)); }",
			"        _Tp query(int __left, int __right) const { return m_minus(presum(__right), presum(__left - 1)); }",
			"        _Tp queryAll() const { return presum(m_length - 1); }",
			"        int kth(_Tp __k) const {",
			"            int cursor = -1;",
			"            for (int d = m_length / 2; d; d >>= 1)",
			"                if (m_sum[cursor + d] <= __k) __k -= m_sum[cursor += d];",
			"            return cursor + 1;",
			"        }",
			"    };",
			"    template <typename _Tp = int, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT(int, _Plus = _Plus(), _Minus = _Minus(), _Tp = _Tp()) -> BIT<_Tp, _Plus, _Minus>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT(_Iterator, _Iterator, _Plus = _Plus(), _Minus = _Minus(), _Tp = _Tp()) -> BIT<_Tp, _Plus, _Minus>;",
			"",
			"    template <typename _Tp = int64_t>",
			"    class BIT_ex {",
			"        struct _TpArray {",
			"            _Tp val[2];",
			"            _TpArray(_Tp __val = _Tp(0)) {",
			"                val[0] = __val;",
			"                val[1] = 0;",
			"            }",
			"            _TpArray(_Tp __val0, _Tp __val1) {",
			"                val[0] = __val0;",
			"                val[1] = __val1;",
			"            }",
			"            _TpArray &operator+=(const _TpArray &other) {",
			"                val[0] += other.val[0];",
			"                val[1] += other.val[1];",
			"                return *this;",
			"            }",
			"        };",
			"        std::vector<_TpArray> m_sum;",
			"        int m_length;",
			"        void _add(int i, _Tp __inc) {",
			"            _TpArray inc(__inc, __inc * i);",
			"            while (i < m_length) {",
			"                m_sum[i] += inc;",
			"                i += 1 << std::__countr_zero<uint32_t>(i + 1);",
			"            }",
			"        }",
			"",
			"    public:",
			"        BIT_ex(int __n) { resize(__n); }",
			"        template <typename _Iterator>",
			"        BIT_ex(_Iterator __first, _Iterator __last) { reset(__first, __last); }",
			"        void resize(int __n) {",
			"            m_length = __n > 1 ? 1 << (32 - std::__countl_zero<uint32_t>(__n - 1)) : 1;",
			"            m_sum.assign(m_length, _Tp(0));",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = (__last - __first) > 1 ? 1 << (32 - std::__countl_zero<uint32_t>((__last - __first) - 1)) : 1;",
			"            m_sum.resize(m_length);",
			"            std::adjacent_difference(__first, __last, m_sum.begin());",
			"            std::fill(m_sum.begin() + (__last - __first), m_sum.end(), _Tp(0));",
			"            for (int i = 0; i < m_length; i++) m_sum[i].val[1] = m_sum[i].val[0] * i;",
			"            for (int i = 0; i < m_length; i++)",
			"                if (int j = i + (1 << std::__countr_zero<uint32_t>(i + 1)); j < m_length) m_sum[j] += m_sum[i];",
			"        }",
			"        void add(int i, _Tp __inc) {",
			"            _add(i, __inc);",
			"            _add(i + 1, -__inc);",
			"        }",
			"        void add(int __left, int __right, _Tp __inc) {",
			"            _add(__left, __inc);",
			"            _add(__right + 1, -__inc);",
			"        }",
			"        _Tp presum(int i) {",
			"            _TpArray ret;",
			"            for (int j = i; j >= 0; j -= 1 << std::__countr_zero<uint32_t>(j + 1)) ret += m_sum[j];",
			"            return ret.val[0] * (i + 1) - ret.val[1];",
			"        }",
			"        _Tp query(int i) {",
			"            _Tp ret(0);",
			"            for (int j = i; j >= 0; j -= 1 << std::__countr_zero<uint32_t>(j + 1)) ret += m_sum[j].val[0];",
			"            return ret;",
			"        }",
			"        _Tp query(int __left, int __right) { return presum(__right) - presum(__left - 1); }",
			"        _Tp queryAll() { return presum(m_length - 1); }",
			"        int kth(_Tp __k) {",
			"            int cursor = -1;",
			"            _TpArray cur;",
			"            for (int d = m_length / 2; d; d >>= 1)",
			"                if ((cur.val[0] + m_sum[cursor + d].val[0]) * (cursor + d + 1) - (cur.val[1] + m_sum[cursor + d].val[1]) <= __k) cur += m_sum[cursor += d];",
			"            return cursor + 1;",
			"        }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    BIT_ex(int) -> BIT_ex<_Tp>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    BIT_ex(_Iterator, _Iterator) -> BIT_ex<_Tp>;",
			"}",
        ],
        "description": "binary indexed tree"
    },
	"binary indexed tree 2d":{
		"prefix": "BIT2D",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    class BIT2d {",
			"        std::vector<std::vector<_Tp>> m_sum;",
			"        _Tp m_defaultValue;",
			"        _Plus m_plus;",
			"        _Minus m_minus;",
			"        int m_row;",
			"        int m_column;",
			"",
			"    public:",
			"        BIT2d(int __row, int __column, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) {",
			"            resize(__row, __column);",
			"        }",
			"        template <typename Ref>",
			"        BIT2d(Ref __ref, int __row, int __column, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) {",
			"            reset(__ref, __row, __column);",
			"        }",
			"        void resize(int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_sum.assign(m_row, std::vector<_Tp>(m_column, m_defaultValue));",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_sum.resize(m_row);",
			"            for (int i = 0; i < m_row; i++) {",
			"                if constexpr (std::is_invocable_v<Ref, int>)",
			"                    m_sum[i].assign(__ref(i), __ref(i) + m_column);",
			"                else {",
			"                    m_sum[i].clear();",
			"                    m_sum[i].reserve(m_column);",
			"                    for (int j = 0; j < m_column; j++) m_sum[i].push_back(__ref(i, j));",
			"                }",
			"            }",
			"            for (int j = 0; j < m_column; j++)",
			"                if (int k = j + (1 << std::__countr_zero<uint32_t>(j + 1)); k < m_column)",
			"                    for (int i = 0; i < m_row; i++) m_sum[i][k] = m_plus(m_sum[i][k], m_sum[i][j]);",
			"            for (int i = 0; i < m_row; i++)",
			"                if (int k = i + (1 << std::__countr_zero<uint32_t>(i + 1)); k < m_row)",
			"                    for (int j = 0; j < m_column; j++) m_sum[k][j] = m_plus(m_sum[k][j], m_sum[i][j]);",
			"        }",
			"        void add(int i, int j, _Tp __inc) {",
			"            for (int r = i; r < m_row; r += 1 << std::__countr_zero<uint32_t>(r + 1))",
			"                for (int c = j; c < m_column; c += 1 << std::__countr_zero<uint32_t>(c + 1))",
			"                    m_sum[r][c] = m_plus(m_sum[r][c], __inc);",
			"        }",
			"        _Tp presum(int i, int j) const {",
			"            _Tp ret = m_defaultValue;",
			"            for (int r = i; r >= 0; r -= 1 << std::__countr_zero<uint32_t>(r + 1))",
			"                for (int c = j; c >= 0; c -= 1 << std::__countr_zero<uint32_t>(c + 1))",
			"                    ret = m_plus(ret, m_sum[r][c]);",
			"            return ret;",
			"        }",
			"        _Tp query(int i, int j) const { return m_minus(m_plus(presum(i, j), presum(i - 1, j - 1)), m_plus(presum(i, j - 1), presum(i - 1, j))); }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const { return m_minus(m_plus(presum(__row2, __column2), presum(__row1 - 1, __column1 - 1)), m_plus(presum(__row1 - 1, __column2), presum(__row2, __column1 - 1))); }",
			"        _Tp queryAll() const { return presum(m_row - 1, m_column - 1); }",
			"    };",
			"    template <typename _Tp = int, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT2d(int, int, _Plus = _Plus(), _Minus = _Minus(), _Tp = _Tp()) -> BIT2d<_Tp, _Plus, _Minus>;",
			"    template <typename Ref, typename _Tp = typename std::iterator_traits<typename decltype(std::mem_fn(&Ref::operator()))::result_type>::value_type, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT2d(Ref, int, int, _Plus = _Plus(), _Minus = _Minus(), std::enable_if_t<std::is_invocable_v<Ref, int>, _Tp> = _Tp()) -> BIT2d<_Tp, _Plus, _Minus>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT2d(Ref, int, int, _Plus = _Plus(), _Minus = _Minus(), std::enable_if_t<std::is_invocable_v<Ref, int, int>, _Tp> = _Tp()) -> BIT2d<_Tp, _Plus, _Minus>;",
			"",
			"    template <typename _Tp = int64_t>",
			"    class BIT2d_ex {",
			"        struct _TpArray {",
			"            _Tp val[4];",
			"            _TpArray() { val[0] = val[1] = val[2] = val[3] = 0; }",
			"            _TpArray(_Tp __val0, _Tp __val1, _Tp __val2, _Tp __val3) {",
			"                val[0] = __val0;",
			"                val[1] = __val1;",
			"                val[2] = __val2;",
			"                val[3] = __val3;",
			"            }",
			"            _TpArray &operator+=(const _TpArray &other) {",
			"                val[0] += other.val[0];",
			"                val[1] += other.val[1];",
			"                val[2] += other.val[2];",
			"                val[3] += other.val[3];",
			"                return *this;",
			"            }",
			"        };",
			"        std::vector<std::vector<_TpArray>> m_sum;",
			"        int m_row;",
			"        int m_column;",
			"        void _add(int i, int j, _Tp __inc) {",
			"            _TpArray inc(__inc, __inc * i, __inc * j, __inc * i * j);",
			"            for (int r = i; r < m_row; r += 1 << std::__countr_zero<uint32_t>(r + 1))",
			"                for (int c = j; c < m_column; c += 1 << std::__countr_zero<uint32_t>(c + 1))",
			"                    m_sum[r][c] += inc;",
			"        }",
			"",
			"    public:",
			"        BIT2d_ex(int __row, int __column) { resize(__row, __column); }",
			"        template <typename Ref>",
			"        BIT2d_ex(Ref __ref, int __row, int __column) { reset(__ref, __row, __column); }",
			"        void resize(int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_sum.assign(m_row, std::vector<_TpArray>(m_column));",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_sum.resize(m_row);",
			"            for (int i = 0; i < m_row; i++) {",
			"                m_sum[i].clear();",
			"                m_sum[i].reserve(m_column);",
			"                for (int j = 0; j < m_column; j++) {",
			"                    _Tp value;",
			"                    if (i && j)",
			"                        value = __ref(i, j) + __ref(i - 1, j - 1) - __ref(i, j - 1) - __ref(i - 1, j);",
			"                    else if (i)",
			"                        value = __ref(i, j) - __ref(i - 1, j);",
			"                    else if (j)",
			"                        value = __ref(i, j) - __ref(i, j - 1);",
			"                    else",
			"                        value = __ref(i, j);",
			"                    m_sum[i].emplace_back(value, value * i, value * j, value * i * j);",
			"                }",
			"            }",
			"            for (int j = 0; j < m_column; j++)",
			"                if (int k = j + (1 << std::__countr_zero<uint32_t>(j + 1)); k < m_column)",
			"                    for (int i = 0; i < m_row; i++) m_sum[i][k] += m_sum[i][j];",
			"            for (int i = 0; i < m_row; i++)",
			"                if (int k = i + (1 << std::__countr_zero<uint32_t>(i + 1)); k < m_row)",
			"                    for (int j = 0; j < m_column; j++) m_sum[k][j] += m_sum[i][j];",
			"        }",
			"        void add(int i, int j, _Tp __inc) {",
			"            _add(i, j, __inc);",
			"            _add(i, j + 1, -__inc);",
			"            _add(i + 1, j, -__inc);",
			"            _add(i + 1, j + 1, __inc);",
			"        }",
			"        void add(int __row1, int __row2, int __column1, int __column2, _Tp __inc) {",
			"            _add(__row1, __column1, __inc);",
			"            _add(__row1, __column2 + 1, -__inc);",
			"            _add(__row2 + 1, __column1, -__inc);",
			"            _add(__row2 + 1, __column2 + 1, __inc);",
			"        }",
			"        _Tp presum(int i, int j) const {",
			"            _TpArray ret;",
			"            for (int r = i; r >= 0; r -= 1 << std::__countr_zero<uint32_t>(r + 1))",
			"                for (int c = j; c >= 0; c -= 1 << std::__countr_zero<uint32_t>(c + 1))",
			"                    ret += m_sum[r][c];",
			"            return ret.val[0] * (i + 1) * (j + 1) - ret.val[1] * (j + 1) - ret.val[2] * (i + 1) + ret.val[3];",
			"        }",
			"        _Tp query(int i, int j) const {",
			"            _Tp ret = 0;",
			"            for (int r = i; r >= 0; r -= 1 << std::__countr_zero<uint32_t>(r + 1))",
			"                for (int c = j; c >= 0; c -= 1 << std::__countr_zero<uint32_t>(c + 1))",
			"                    ret += m_sum[r][c].val[0];",
			"            return ret;",
			"        }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const { return presum(__row2, __column2) + presum(__row1 - 1, __column1 - 1) - presum(__row2, __column1 - 1) - presum(__row1 - 1, __column2); }",
			"        _Tp queryAll() const { return presum(m_row - 1, m_column - 1); }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    BIT2d_ex(int, int) -> BIT2d_ex<_Tp>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>>",
			"    BIT2d_ex(Ref, int, int) -> BIT2d_ex<_Tp>;",
			"}",
		],
		"description": "binary indexed tree 2d"
	},
	"Bitset":{
		"prefix": "BITSET",
		"body": [
			"namespace OY {",
			"    enum _BITBLOCK_STATE {",
			"        BITSET_DEFAULT = 0,",
			"        BITSET_FLIPPED = 1,",
			"        BITSET_ZERO = 2,",
			"        BITSET_ONE = 3",
			"    };",
			"    template <int _Depth = 6>",
			"    struct _BitBlock {",
			"        mutable uint64_t m_mask[1 << _Depth];",
			"        mutable _BITBLOCK_STATE m_state;",
			"        int m_sum;",
			"        void set_inside(int i, int l, int r) {",
			"            uint64_t old = m_mask[i];",
			"            m_mask[i] |= r < 63 ? (1ull << (r + 1)) - (1ull << l) : -(1ull << l);",
			"            m_sum += std::__popcount(m_mask[i] ^ old);",
			"        }",
			"        void reset_inside(int i, int l, int r) {",
			"            uint64_t old = m_mask[i];",
			"            m_mask[i] &= r < 63 ? ~((1ull << (r + 1)) - (1ull << l)) : ~-(1ull << l);",
			"            m_sum -= std::__popcount(m_mask[i] ^ old);",
			"        }",
			"        void flip_inside(int i, int l, int r) {",
			"            uint64_t old = m_mask[i];",
			"            m_mask[i] = (m_mask[i] & (r < 63 ? (1ull << l) - (1ull << (r + 1)) - 1 : (1ull << l) - 1)) ^ (~m_mask[i] & (r < 63 ? (1ull << (r + 1)) - (1ull << l) : -(1ull << l)));",
			"            m_sum += std::__popcount(m_mask[i]) - std::__popcount(old);",
			"        }",
			"        int count_inside(int i, int l, int r) const { return std::__popcount(m_mask[i] & (r < 63 ? (1ull << (r + 1)) - (1ull << l) : -(1ull << l))); }",
			"        void push_down() const {",
			"            if (m_state == BITSET_DEFAULT) return;",
			"            if (m_state == BITSET_FLIPPED) {",
			"                m_state = BITSET_DEFAULT;",
			"                for (auto &a : m_mask) a = ~a;",
			"            } else if (m_state == BITSET_ZERO) {",
			"                m_state = BITSET_DEFAULT;",
			"                memset(m_mask, 0, sizeof(m_mask));",
			"            } else {",
			"                m_state = BITSET_DEFAULT;",
			"                memset(m_mask, -1, sizeof(m_mask));",
			"            }",
			"        }",
			"        void update_sum() {",
			"            m_sum = 0;",
			"            for (auto &a : m_mask) m_sum += std::__popcount(a);",
			"        }",
			"        _BitBlock() : m_mask{0}, m_state(BITSET_DEFAULT), m_sum(0) {}",
			"        int set() {",
			"            m_state = BITSET_ONE;",
			"            int old = m_sum;",
			"            m_sum = 1 << (_Depth + 6);",
			"            return m_sum - old;",
			"        }",
			"        int set(int __i) {",
			"            if (m_state == BITSET_ONE) return 0;",
			"            if (m_state == BITSET_DEFAULT) {",
			"                if (m_mask[__i >> 6] >> (__i & 63) & 1) return 0;",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                if (!(m_mask[__i >> 6] >> (__i & 63) & 1)) return 0;",
			"            } else {",
			"                m_state = BITSET_DEFAULT;",
			"                memset(m_mask, 0, sizeof(m_mask));",
			"            }",
			"            m_mask[__i >> 6] ^= 1ull << (__i & 63);",
			"            m_sum++;",
			"            return 1;",
			"        }",
			"        int set(int __left, int __right) {",
			"            if (m_state == BITSET_ONE) return 0;",
			"            int old = m_sum;",
			"            push_down();",
			"            if (int l = __left >> 6, r = __right >> 6; l == r)",
			"                set_inside(l, __left & 63, __right & 63);",
			"            else {",
			"                set_inside(l, __left & 63, 63);",
			"                for (int i = l + 1; i < r; i++) {",
			"                    uint64_t old = m_mask[i];",
			"                    m_mask[i] = -1ull;",
			"                    m_sum += std::__popcount(m_mask[i] ^ old);",
			"                }",
			"                set_inside(r, 0, __right & 63);",
			"            }",
			"            return m_sum - old;",
			"        }",
			"        int reset() {",
			"            m_state = BITSET_ZERO;",
			"            int old = m_sum;",
			"            m_sum = 0;",
			"            return -old;",
			"        }",
			"        int reset(int __i) {",
			"            if (m_state == BITSET_ZERO) return 0;",
			"            if (m_state == BITSET_DEFAULT) {",
			"                if (!(m_mask[__i >> 6] >> (__i & 63) & 1)) return 0;",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                if (m_mask[__i >> 6] >> (__i & 63) & 1) return 0;",
			"            } else {",
			"                m_state = BITSET_DEFAULT;",
			"                memset(m_mask, -1, sizeof(m_mask));",
			"            }",
			"            m_mask[__i >> 6] ^= 1ull << (__i & 63);",
			"            m_sum--;",
			"            return -1;",
			"        }",
			"        int reset(int __left, int __right) {",
			"            if (m_state == BITSET_ZERO) return 0;",
			"            int old = m_sum;",
			"            push_down();",
			"            if (int l = __left >> 6, r = __right >> 6; l == r)",
			"                reset_inside(l, __left & 63, __right & 63);",
			"            else {",
			"                reset_inside(l, __left & 63, 63);",
			"                for (int i = l + 1; i < r; i++) {",
			"                    m_sum -= std::__popcount(m_mask[i]);",
			"                    m_mask[i] = 0;",
			"                }",
			"                reset_inside(r, 0, __right & 63);",
			"            }",
			"            return m_sum - old;",
			"        }",
			"        int flip() {",
			"            if (m_state == BITSET_DEFAULT)",
			"                m_state = BITSET_FLIPPED;",
			"            else if (m_state == BITSET_FLIPPED)",
			"                m_state = BITSET_DEFAULT;",
			"            else if (m_state == BITSET_ONE)",
			"                m_state = BITSET_ZERO;",
			"            else",
			"                m_state = BITSET_ONE;",
			"            m_sum = (1 << (_Depth + 6)) - m_sum;",
			"            return m_sum * 2 - (1 << (_Depth + 6));",
			"        }",
			"        int flip(int __i) {",
			"            bool add;",
			"            if (m_state == BITSET_FLIPPED) {",
			"                m_mask[__i >> 6] ^= 1ull << (__i & 63);",
			"                add = !(m_mask[__i >> 6] >> (__i & 63) & 1);",
			"            } else {",
			"                if (m_state != BITSET_DEFAULT) push_down();",
			"                m_mask[__i >> 6] ^= 1ull << (__i & 63);",
			"                add = m_mask[__i >> 6] >> (__i & 63) & 1;",
			"            }",
			"            if (add) {",
			"                m_sum++;",
			"                return 1;",
			"            } else {",
			"                m_sum--;",
			"                return -1;",
			"            }",
			"        }",
			"        int flip(int __left, int __right) {",
			"            int old = m_sum;",
			"            push_down();",
			"            if (int l = __left >> 6, r = __right >> 6; l == r)",
			"                flip_inside(l, __left & 63, __right & 63);",
			"            else {",
			"                flip_inside(l, __left & 63, 63);",
			"                for (int i = l + 1; i < r; i++) {",
			"                    m_sum += 64 - std::__popcount(m_mask[i]) * 2;",
			"                    m_mask[i] = ~m_mask[i];",
			"                }",
			"                flip_inside(r, 0, __right & 63);",
			"            }",
			"            return m_sum - old;",
			"        }",
			"        int first() const {",
			"            if (!m_sum) return -1;",
			"            if (m_state == BITSET_DEFAULT) {",
			"                int i = 0;",
			"                while (!m_mask[i]) i++;",
			"                return (i << 6) + std::__countr_zero(m_mask[i]);",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                int i = 0;",
			"                while (!~m_mask[i]) i++;",
			"                return (i << 6) + std::__countr_zero(~m_mask[i]);",
			"            } else",
			"                return 0;",
			"        }",
			"        int prev(int __i) const {",
			"            if (m_state == BITSET_DEFAULT) {",
			"                int i = __i >> _Depth;",
			"                if (auto a = m_mask[i] & (1ull << (__i & 63)) - 1) return (i << 6) + 63 - std::__countl_zero(a);",
			"                while (~--i && !m_mask[i])",
			"                    ;",
			"                return ~i ? (i << 6) + 63 - std::__countl_zero(m_mask[i]) : -1;",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                int i = __i >> _Depth;",
			"                if (auto a = ~m_mask[i] & (1ull << (__i & 63)) - 1) return (i << 6) + 63 - std::__countl_zero(a);",
			"                while (~--i && !~m_mask[i])",
			"                    ;",
			"                return ~i ? (i << 6) + 63 - std::__countl_zero(~m_mask[i]) : -1;",
			"            } else if (m_state == BITSET_ONE)",
			"                return __i - 1;",
			"            else",
			"                return -1;",
			"        }",
			"        int next(int __i) const {",
			"            if (m_state == BITSET_DEFAULT) {",
			"                int i = __i >> _Depth;",
			"                if ((__i & 63) < 63) {",
			"                    if (auto a = m_mask[i] & -1ull << ((__i & 63) + 1)) return (i << 6) + std::__countr_zero(a);",
			"                }",
			"                while (++i < 1 << _Depth && !m_mask[i])",
			"                    ;",
			"                return i < 1 << _Depth ? (i << 6) + std::__countr_zero(m_mask[i]) : -1;",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                int i = __i >> _Depth;",
			"                if ((__i & 63) < 63)",
			"                    if (auto a = ~m_mask[i] & -1ull << ((__i & 63) + 1)) return (i << 6) + std::__countr_zero(a);",
			"                while (++i < 1 << _Depth && !~m_mask[i])",
			"                    ;",
			"                return i < 1 << _Depth ? (i << 6) + std::__countr_zero(~m_mask[i]) : -1;",
			"            } else if (m_state == BITSET_ONE)",
			"                return __i < 1 << (_Depth + 6) ? __i + 1 : -1;",
			"            else",
			"                return -1;",
			"        }",
			"        int last() const {",
			"            if (!m_sum) return -1;",
			"            if (m_state == BITSET_DEFAULT) {",
			"                int i = (1 << _Depth) - 1;",
			"                while (!m_mask[i]) i--;",
			"                return (i << 6) + 63 - std::__countl_zero(m_mask[i]);",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                int i = (1 << _Depth) - 1;",
			"                while (!~m_mask[i]) i--;",
			"                return (i << 6) + 63 - std::__countl_zero(~m_mask[i]);",
			"            } else",
			"                return (1 << (_Depth + 6)) - 1;",
			"        }",
			"        int count() const { return m_sum; }",
			"        int count(int __left, int __right) const {",
			"            if (m_state == BITSET_ZERO)",
			"                return 0;",
			"            else if (m_state == BITSET_ONE)",
			"                return __right - __left + 1;",
			"            else {",
			"                int l = __left >> 6, r = __right >> 6, sum = 0;",
			"                if (l == r)",
			"                    sum = count_inside(l, __left & 63, __right & 63);",
			"                else {",
			"                    sum = count_inside(l, __left & 63, 63);",
			"                    for (int i = l + 1; i < r; i++) sum += std::__popcount(m_mask[i]);",
			"                    sum += count_inside(r, 0, __right & 63);",
			"                }",
			"                return m_state == BITSET_DEFAULT ? sum : __right - __left + 1 - sum;",
			"            }",
			"        }",
			"        bool at(int __i) const {",
			"            if (m_state == BITSET_DEFAULT)",
			"                return m_mask[__i >> 6] >> (__i & 63) & 1;",
			"            else if (m_state == BITSET_FLIPPED)",
			"                return !(m_mask[__i >> 6] >> (__i & 63) & 1);",
			"            else",
			"                return m_state == BITSET_ONE;",
			"        }",
			"        bool operator[](int __i) const { return at(__i); }",
			"        bool all() const { return m_sum == 1 << (_Depth + 6); }",
			"        bool any() const { return m_sum; }",
			"        _BitBlock<_Depth> &operator&=(const _BitBlock<_Depth> &other) {",
			"            push_down();",
			"            other.push_down();",
			"            for (int i = 0; i < 1 << _Depth; i++) m_mask[i] &= other.m_mask[i];",
			"            update_sum();",
			"            return *this;",
			"        }",
			"        _BitBlock<_Depth> &operator|=(const _BitBlock<_Depth> &other) {",
			"            push_down();",
			"            other.push_down();",
			"            for (int i = 0; i < 1 << _Depth; i++) m_mask[i] |= other.m_mask[i];",
			"            update_sum();",
			"            return *this;",
			"        }",
			"        _BitBlock<_Depth> &operator^=(const _BitBlock<_Depth> &other) {",
			"            push_down();",
			"            other.push_down();",
			"            for (int i = 0; i < 1 << _Depth; i++) m_mask[i] ^= other.m_mask[i];",
			"            update_sum();",
			"            return *this;",
			"        }",
			"        friend _BitBlock<_Depth> operator&(const _BitBlock<_Depth> &a, const _BitBlock<_Depth> &b) {",
			"            _BitBlock<_Depth> res(a);",
			"            a &= b;",
			"            return a;",
			"        }",
			"        friend _BitBlock<_Depth> operator|(const _BitBlock<_Depth> &a, const _BitBlock<_Depth> &b) {",
			"            _BitBlock<_Depth> res(a);",
			"            a |= b;",
			"            return a;",
			"        }",
			"        friend _BitBlock<_Depth> operator^(const _BitBlock<_Depth> &a, const _BitBlock<_Depth> &b) {",
			"            _BitBlock<_Depth> res(a);",
			"            a ^= b;",
			"            return a;",
			"        }",
			"    };",
			"    template <int _Depth = 6>",
			"    class Bitset {",
			"        std::vector<_BitBlock<_Depth>> m_sub;",
			"        int m_length;",
			"        int m_sum;",
			"        void updateSum() {",
			"            m_sum = 0;",
			"            for (auto &sub : m_sub) m_sum += sub.m_sum;",
			"        }",
			"",
			"    public:",
			"        Bitset(int __n = 0) { resize(__n); }",
			"        void resize(int __n) {",
			"            if (!(m_length = __n)) return;",
			"            m_sub.clear();",
			"            m_sub.resize(((__n - 1) >> (_Depth + 6)) + 1);",
			"            m_sum = 0;",
			"        }",
			"        void set() {",
			"            for (int i = 0; i < m_sub.size() - 1; i++) m_sub[i].set();",
			"            m_sub.back().set(0, (m_length - 1) & (1 << (_Depth + 6)) - 1);",
			"            m_sum = m_length;",
			"        }",
			"        void set(int __i) { m_sum += m_sub[__i >> (_Depth + 6)].set(__i & (1 << (_Depth + 6)) - 1); }",
			"        void set(int __left, int __right) {",
			"            int l = __left >> (_Depth + 6), r = __right >> (_Depth + 6);",
			"            if (l == r)",
			"                m_sum += m_sub[l].set(__left & (1 << (_Depth + 6)) - 1, __right & (1 << (_Depth + 6)) - 1);",
			"            else {",
			"                m_sum += m_sub[l].set(__left & (1 << (_Depth + 6)) - 1, (1 << (_Depth + 6)) - 1);",
			"                for (int i = l + 1; i < r; i++) m_sum += m_sub[i].set();",
			"                m_sum += m_sub[r].set(0, __right & (1 << (_Depth + 6)) - 1);",
			"            }",
			"        }",
			"        void reset() {",
			"            for (auto &sub : m_sub) sub.reset();",
			"            m_sum = 0;",
			"        }",
			"        void reset(int __i) { m_sum += m_sub[__i >> (_Depth + 6)].reset(__i & (1 << (_Depth + 6)) - 1); }",
			"        void reset(int __left, int __right) {",
			"            int l = __left >> (_Depth + 6), r = __right >> (_Depth + 6);",
			"            if (l == r)",
			"                m_sum += m_sub[l].reset(__left & (1 << (_Depth + 6)) - 1, __right & (1 << (_Depth + 6)) - 1);",
			"            else {",
			"                m_sum += m_sub[l].reset(__left & (1 << (_Depth + 6)) - 1, (1 << (_Depth + 6)) - 1);",
			"                for (int i = l + 1; i < r; i++) m_sum += m_sub[i].reset();",
			"                m_sum += m_sub[r].reset(0, __right & (1 << (_Depth + 6)) - 1);",
			"            }",
			"        }",
			"        void flip() {",
			"            for (int i = 0; i < m_sub.size() - 1; i++) m_sub[i].flip();",
			"            m_sub.back().flip(0, (m_length - 1) & (1 << (_Depth + 6)) - 1);",
			"            m_sum = m_length - m_sum;",
			"        }",
			"        void flip(int __i) { m_sum += m_sub[__i >> (_Depth + 6)].flip(__i & (1 << (_Depth + 6)) - 1); }",
			"        void flip(int __left, int __right) {",
			"            int l = __left >> (_Depth + 6), r = __right >> (_Depth + 6);",
			"            if (l == r)",
			"                m_sum += m_sub[l].flip(__left & (1 << (_Depth + 6)) - 1, __right & (1 << (_Depth + 6)) - 1);",
			"            else {",
			"                m_sum += m_sub[l].flip(__left & (1 << (_Depth + 6)) - 1, (1 << (_Depth + 6)) - 1);",
			"                for (int i = l + 1; i < r; i++) m_sum += m_sub[i].flip();",
			"                m_sum += m_sub[r].flip(0, __right & (1 << (_Depth + 6)) - 1);",
			"            }",
			"        }",
			"        int first() const {",
			"            if (!m_sum) return -1;",
			"            int i = 0;",
			"            while (!m_sub[i].any()) i++;",
			"            return (i << (_Depth + 6)) + m_sub[i].first();",
			"        }",
			"        int prev(int __i) const {",
			"            int i = __i >> (_Depth + 6);",
			"            if (int j = m_sub[i].prev(__i & (1 << (_Depth + 6)) - 1); ~j) return (i << (_Depth + 6)) + j;",
			"            while (~--i && !m_sub[i].any())",
			"                ;",
			"            return ~i ? (i << (_Depth + 6)) + m_sub[i].last() : -1;",
			"        }",
			"        int next(int __i) const {",
			"            int i = __i >> (_Depth + 6);",
			"            if (int j = m_sub[i].next(__i & (1 << (_Depth + 6)) - 1); ~j) return (i << (_Depth + 6)) + j;",
			"            while (++i < m_sub.size() && !m_sub[i].any())",
			"                ;",
			"            return i < m_sub.size() ? (i << (_Depth + 6)) + m_sub[i].first() : -1;",
			"        }",
			"        int last() const {",
			"            if (!m_sum) return -1;",
			"            int i = m_sub.size() - 1;",
			"            while (!m_sub[i].any()) i--;",
			"            return (i << (_Depth + 6)) + m_sub[i].last();",
			"        }",
			"        int count() const { return m_sum; }",
			"        int count(int __left, int __right) const {",
			"            int l = __left >> (_Depth + 6), r = __right >> (_Depth + 6);",
			"            if (l == r)",
			"                return m_sub[l].count(__left & (1 << (_Depth + 6)) - 1, __right & (1 << (_Depth + 6)) - 1);",
			"            else {",
			"                int sum = m_sub[l].count(__left & (1 << (_Depth + 6)) - 1, (1 << (_Depth + 6)) - 1);",
			"                for (int i = l + 1; i < r; i++) sum += m_sub[i].count();",
			"                return sum + m_sub[r].count(0, __right & (1 << (_Depth + 6)) - 1);",
			"            }",
			"        }",
			"        bool at(int __i) const { return m_sub[__i >> (_Depth + 6)].at(__i & (1 << (_Depth + 6)) - 1); }",
			"        bool operator[](int __i) const { return at(__i); }",
			"        bool all() const { return count() == m_length; }",
			"        bool any() const { return count(); }",
			"        Bitset<_Depth> &operator&=(const Bitset<_Depth> &other) {",
			"            assert(m_length == other.m_length);",
			"            for (int i = 0; i < m_sub.size(); i++) m_sub[i] &= other.m_sub[i];",
			"            updateSum();",
			"            return *this;",
			"        };",
			"        Bitset<_Depth> &operator|=(const Bitset<_Depth> &other) {",
			"            assert(m_length == other.m_length);",
			"            for (int i = 0; i < m_sub.size(); i++) m_sub[i] |= other.m_sub[i];",
			"            updateSum();",
			"            return *this;",
			"        };",
			"        Bitset<_Depth> &operator^=(const Bitset<_Depth> &other) {",
			"            assert(m_length == other.m_length);",
			"            for (int i = 0; i < m_sub.size(); i++) m_sub[i] ^= other.m_sub[i];",
			"            updateSum();",
			"            return *this;",
			"        };",
			"        friend Bitset<_Depth> operator&(const Bitset<_Depth> &a, const Bitset<_Depth> &b) {",
			"            Bitset<_Depth> res(a);",
			"            res &= b;",
			"            return res;",
			"        }",
			"        friend Bitset<_Depth> operator|(const Bitset<_Depth> &a, const Bitset<_Depth> &b) {",
			"            Bitset<_Depth> res(a);",
			"            res |= b;",
			"            return res;",
			"        }",
			"        friend Bitset<_Depth> operator^(const Bitset<_Depth> &a, const Bitset<_Depth> &b) {",
			"            Bitset<_Depth> res(a);",
			"            res ^= b;",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Bitset"
	},
	"BiTrie":{
		"prefix": "BITRIE",
		"body": [
			"namespace OY {",
			"    struct BiTrieDefaultInfo {};",
			"    template <typename _Tp, uint8_t _L>",
			"    struct BiTrieIteration {",
			"        _Tp m_number;",
			"        struct BiTrieIterator {",
			"            _Tp number;",
			"            uint32_t index;",
			"            BiTrieIterator(_Tp _number, uint32_t _index) : number(_number), index(_index) {}",
			"            BiTrieIterator &operator++() {",
			"                index--;",
			"                return *this;",
			"            }",
			"            BiTrieIterator operator+(uint32_t __i) const { return BiTrieIterator(number, index - __i); }",
			"            bool operator*() const { return number >> index & 1; }",
			"            bool operator==(const BiTrieIterator &_other) const { return !~index; }",
			"            bool operator!=(const BiTrieIterator &_other) const { return ~index; }",
			"        };",
			"        BiTrieIteration(_Tp __number) : m_number(__number) {}",
			"        BiTrieIterator begin() const { return BiTrieIterator(m_number, _L - 1); }",
			"        BiTrieIterator end() const { return BiTrieIterator(m_number, -1); }",
			"    };",
			"    template <typename _Tp = uint32_t, uint8_t _L = 30, typename _Info = BiTrieDefaultInfo, uint32_t _PoolSize = 2000000>",
			"    struct BiTrie {",
			"        struct BiTrieMapping {",
			"            static constexpr int range() { return 2; }",
			"            uint32_t operator()(bool __c) const { return __c; }",
			"        };",
			"        static inline Trie<BiTrieMapping, _Info, _PoolSize> s_trie;",
			"        using TrieNode = typename Trie<BiTrieMapping, _Info, _PoolSize>::TrieNode;",
			"        static void Init() { s_trie = Trie<BiTrieMapping, _Info, _PoolSize>(); }",
			"        static TrieNode Insert(const BiTrieIteration<_Tp, _L> &__numberIteration) { return s_trie.insert(__numberIteration); }",
			"        static std::pair<TrieNode, _Tp> QueryMaxSame(_Tp __number) {",
			"            TrieNode cur = s_trie.m_root;",
			"            _Tp res(0);",
			"            for (bool c : BiTrieIteration<_Tp, _L>(__number)) {",
			"                res *= 2;",
			"                if (TrieNode child = cur.child(c)) {",
			"                    cur = child;",
			"                    res++;",
			"                } else",
			"                    cur = cur.child(c ^ 1);",
			"            }",
			"            return {cur, res};",
			"        }",
			"        static std::pair<TrieNode, _Tp> QueryMaxBitxor(_Tp __number) {",
			"            __number ^= (_Tp(1) << _L) - 1;",
			"            TrieNode cur = s_trie.m_root;",
			"            _Tp res(0);",
			"            for (bool c : BiTrieIteration<_Tp, _L>(__number)) {",
			"                res *= 2;",
			"                if (TrieNode child = cur.child(c)) {",
			"                    cur = child;",
			"                    res++;",
			"                } else",
			"                    cur = cur.child(c ^ 1);",
			"            }",
			"            return {cur, res};",
			"        }",
			"        static _Tp QueryLeafValue(TrieNode __leaf) {",
			"            TrieNode cur = __leaf;",
			"            _Tp res(0);",
			"            for (uint32_t i = 0; i < _L; i++) {",
			"                TrieNode parent = cur.parent();",
			"                if (cur == parent.child(1)) res |= _Tp(1) << i;",
			"                cur = parent;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "BiTrie"
	},
	"B tree":{
		"prefix": "BT",
		"body": [
			"",
			"namespace OY {",
			"    struct BTreeSetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    struct BTreeMultisetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = true;",
			"    };",
			"    struct BTreeMapTag {",
			"        static constexpr bool is_map = true;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _BTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _BTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = int, typename _Compare = std::less<_Tp>, typename _Tag = BTreeMultisetTag, int _K = 3>",
			"    class BTree {",
			"        using node = _BTreeNode<_Tp, _Fp, _Tag::is_map>;",
			"        struct block : MemoryPool<block> {",
			"            node keys[_K * 2 - 1];",
			"            int keyNum;",
			"            node min;",
			"            node max;",
			"            int weight;",
			"            block *child[_K * 2];",
			"            block() { child[0] = nullptr; }",
			"            void push_front(node key, block *p) {",
			"                std::copy_backward(keys, keys + keyNum, keys + keyNum + 1);",
			"                if (child[0]) std::copy_backward(child, child + keyNum + 1, child + keyNum + 2);",
			"                keys[0] = key;",
			"                child[0] = p;",
			"                keyNum++;",
			"            }",
			"            void push_back(node key, block *p) {",
			"                keys[keyNum] = key;",
			"                child[keyNum + 1] = p;",
			"                keyNum++;",
			"            }",
			"            void pop_front() {",
			"                std::copy(keys + 1, keys + keyNum, keys);",
			"                bool is_leaf = !child[0];",
			"                std::copy(child + 1, child + keyNum + 1, child);",
			"                if (is_leaf) child[0] = nullptr;",
			"                keyNum--;",
			"            }",
			"            void pop_back() { keyNum--; }",
			"            void updateMinMax() {",
			"                if (!child[0]) {",
			"                    min = keys[0];",
			"                    max = keys[keyNum - 1];",
			"                } else {",
			"                    min = child[0]->min;",
			"                    max = child[keyNum]->max;",
			"                }",
			"            }",
			"        };",
			"        _Compare m_comp;",
			"        block *m_root;",
			"        static void getLeftLast(block *parent, int pos) {",
			"            block *left = parent->child[pos - 1];",
			"            block *right = parent->child[pos];",
			"            bool is_leaf = !right->child[0];",
			"            right->push_front(parent->keys[pos - 1], is_leaf ? nullptr : left->child[left->keyNum]);",
			"            parent->keys[pos - 1] = left->keys[left->keyNum - 1];",
			"            left->pop_back();",
			"            int w = is_leaf ? 1 : right->child[0]->weight + 1;",
			"            left->max = is_leaf ? left->keys[left->keyNum - 1] : left->child[left->keyNum]->max;",
			"            right->min = is_leaf ? right->keys[0] : right->child[0]->min;",
			"            left->weight -= w;",
			"            right->weight += w;",
			"        }",
			"        static void getRightFirst(block *parent, int pos) {",
			"            block *left = parent->child[pos];",
			"            block *right = parent->child[pos + 1];",
			"            bool is_leaf = !right->child[0];",
			"            left->push_back(parent->keys[pos], right->child[0]);",
			"            parent->keys[pos] = right->keys[0];",
			"            right->pop_front();",
			"            int w = is_leaf ? 1 : left->child[left->keyNum]->weight + 1;",
			"            left->max = is_leaf ? left->keys[left->keyNum - 1] : left->child[left->keyNum]->max;",
			"            right->min = is_leaf ? right->keys[0] : right->child[0]->min;",
			"            left->weight += w;",
			"            right->weight -= w;",
			"        }",
			"        static void mergeAt(block *parent, int pos) {",
			"            block *left = parent->child[pos];",
			"            block *right = parent->child[pos + 1];",
			"            left->keys[left->keyNum] = parent->keys[pos];",
			"            std::copy(right->keys, right->keys + right->keyNum, left->keys + left->keyNum + 1);",
			"            std::copy(right->child, right->child + right->keyNum + 1, left->child + left->keyNum + 1);",
			"            left->keyNum = _K * 2 - 1;",
			"            left->max = right->max;",
			"            left->weight += right->weight + 1;",
			"            delete right;",
			"            std::copy(parent->keys + pos + 1, parent->keys + parent->keyNum, parent->keys + pos);",
			"            std::copy(parent->child + pos + 2, parent->child + parent->keyNum + 1, parent->child + pos + 1);",
			"            parent->keyNum--;",
			"        }",
			"        static void splitAt(block *parent, int pos) {",
			"            block *left = parent->child[pos];",
			"            block *right = new block;",
			"            left->keyNum = right->keyNum = _K - 1;",
			"            std::copy(left->keys + _K, left->keys + (_K * 2 - 1), right->keys);",
			"            if (left->child[0]) {",
			"                int w = _K - 1;",
			"                for (int i = 0; i < _K; i++) {",
			"                    right->child[i] = left->child[_K + i];",
			"                    w += right->child[i]->weight;",
			"                }",
			"                right->min = right->child[0]->min;",
			"                right->max = left->max;",
			"                right->weight = w;",
			"                left->max = left->child[_K - 1]->max;",
			"                left->weight -= w + 1;",
			"            } else {",
			"                right->min = right->keys[0];",
			"                right->max = left->max;",
			"                right->weight = _K - 1;",
			"                left->max = left->keys[_K - 2];",
			"                left->weight -= _K;",
			"            }",
			"            parent->child[pos + 1] = right;",
			"            parent->keys[pos] = left->keys[_K - 1];",
			"            parent->keyNum++;",
			"        }",
			"        const node *key_lower_bound(const node *first, const node *last, _Tp __val) const {",
			"            int len = last - first;",
			"            while (len) {",
			"                int half = len / 2;",
			"                const node *mid = first + half;",
			"                if (m_comp(mid->key, __val)) {",
			"                    first = mid + 1;",
			"                    len -= half + 1;",
			"                } else",
			"                    len = half;",
			"            }",
			"            return first;",
			"        }",
			"        const node *key_upper_bound(const node *first, const node *last, _Tp __val) const {",
			"            int len = last - first;",
			"            while (len) {",
			"                int half = len / 2;",
			"                const node *mid = first + half;",
			"                if (m_comp(__val, mid->key))",
			"                    len = half;",
			"                else {",
			"                    first = mid + 1;",
			"                    len -= half + 1;",
			"                }",
			"            }",
			"            return first;",
			"        }",
			"        block *_insert(block *cur, const node &item, bool &res) {",
			"            int pos = key_upper_bound(cur->keys, cur->keys + cur->keyNum, item.key) - cur->keys;",
			"            if constexpr (!_Tag::multi_key)",
			"                if (pos && !m_comp(cur->keys[pos - 1].key, item.key)) return cur;",
			"            if (!cur->child[0]) {",
			"                std::copy_backward(cur->keys + pos, cur->keys + cur->keyNum, cur->keys + cur->keyNum + 1);",
			"                cur->keys[pos] = item;",
			"                cur->keyNum++;",
			"                res = true;",
			"            } else {",
			"                if (cur->child[pos]->keyNum == _K * 2 - 1) {",
			"                    std::copy_backward(cur->keys + pos, cur->keys + cur->keyNum, cur->keys + cur->keyNum + 1);",
			"                    std::copy_backward(cur->child + pos + 1, cur->child + cur->keyNum + 1, cur->child + cur->keyNum + 2);",
			"                    splitAt(cur, pos);",
			"                    if (m_comp(cur->keys[pos].key, item.key)) pos++;",
			"                }",
			"                _insert(cur->child[pos], item, res);",
			"            }",
			"            if (res) {",
			"                cur->weight++;",
			"                if (m_comp(item.key, cur->min.key)) cur->min = item;",
			"                if (m_comp(cur->max.key, item.key)) cur->max = item;",
			"            }",
			"            return cur;",
			"        }",
			"        block *_erase(block *cur, _Tp key, bool &res) {",
			"            int pos = key_lower_bound(cur->keys, cur->keys + cur->keyNum, key) - cur->keys;",
			"            if (pos == cur->keyNum || m_comp(key, cur->keys[pos].key)) {",
			"                if (!cur->child[0]) return cur;",
			"                if (cur->child[pos]->keyNum == _K - 1) {",
			"                    if (pos && cur->child[pos - 1]->keyNum >= _K)",
			"                        getLeftLast(cur, pos);",
			"                    else if (pos < cur->keyNum && cur->child[pos + 1]->keyNum >= _K)",
			"                        getRightFirst(cur, pos);",
			"                    else {",
			"                        if (pos) pos--;",
			"                        mergeAt(cur, pos);",
			"                        if (!cur->keyNum) {",
			"                            m_root = _erase(cur->child[0], key, res);",
			"                            delete cur;",
			"                            return m_root;",
			"                        }",
			"                    }",
			"                }",
			"                cur->child[pos] = _erase(cur->child[pos], key, res);",
			"                if (res) {",
			"                    cur->weight--;",
			"                    cur->min = cur->child[0]->min;",
			"                    cur->max = cur->child[cur->keyNum]->max;",
			"                }",
			"                return cur;",
			"            } else {",
			"                res = true;",
			"                if (!--cur->weight) {",
			"                    delete cur;",
			"                    return nullptr;",
			"                }",
			"                if (!cur->child[0]) {",
			"                    std::copy(cur->keys + pos + 1, cur->keys + cur->keyNum, cur->keys + pos);",
			"                    cur->keyNum--;",
			"                    cur->updateMinMax();",
			"                } else if (cur->child[pos]->keyNum >= _K) {",
			"                    node leftMax = cur->child[pos]->max;",
			"                    cur->keys[pos] = leftMax;",
			"                    cur->child[pos] = _erase(cur->child[pos], leftMax.key, res);",
			"                } else if (cur->child[pos + 1]->keyNum >= _K) {",
			"                    node rightMin = cur->child[pos + 1]->min;",
			"                    cur->keys[pos] = rightMin;",
			"                    cur->child[pos + 1] = _erase(cur->child[pos + 1], rightMin.key, res);",
			"                } else {",
			"                    mergeAt(cur, pos);",
			"                    if (!cur->keyNum) {",
			"                        m_root = _erase(cur->child[0], key, res);",
			"                        delete cur;",
			"                        return m_root;",
			"                    }",
			"                    cur->child[pos] = _erase(cur->child[pos], key, res);",
			"                }",
			"                return cur;",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { block::_reserve(__count); }",
			"        BTree(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            node item = node{__key, __args...};",
			"            bool res = false;",
			"            if (!m_root) {",
			"                m_root = new block;",
			"                m_root->min = m_root->max = m_root->keys[0] = item;",
			"                m_root->keyNum = m_root->weight = 1;",
			"            } else {",
			"                if (m_root->keyNum == _K * 2 - 1) {",
			"                    block *p = new block;",
			"                    p->keyNum = 0;",
			"                    p->child[0] = m_root;",
			"                    p->weight = m_root->weight;",
			"                    splitAt(p, 0);",
			"                    m_root = _insert(p, item, res);",
			"                } else",
			"                    m_root = _insert(m_root, item, res);",
			"            }",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key); p)",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            bool res = false;",
			"            if (m_root) m_root = _erase(m_root, __key, res);",
			"            return res;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            block *cur = m_root;",
			"            int ord = 0;",
			"            while (cur) {",
			"                int pos = key_lower_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys;",
			"                ord += pos;",
			"                if (!cur->child[0]) break;",
			"                for (int i = 0; i < pos; i++) ord += cur->child[i]->weight;",
			"                cur = cur->child[pos];",
			"            }",
			"            return ord;",
			"        }",
			"        const node *kth(int k) const {",
			"            block *cur = m_root;",
			"            for (int i; cur->child[0]; cur = cur->child[i])",
			"                for (i = 0; k >= cur->child[i]->weight; i++) {",
			"                    k -= cur->child[i]->weight;",
			"                    if (!k--) return cur->keys + i;",
			"                }",
			"            return cur->keys + k;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            block *cur = m_root;",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            for (int i;; cur = cur->child[i]) {",
			"                if (i = key_lower_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys; i < cur->keyNum && !m_comp(__key, cur->keys[i].key)) return cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            block *cur = m_root;",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            for (int i;; cur = cur->child[i]) {",
			"                if (i = key_lower_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys) res = cur->keys + i - 1;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            block *cur = m_root;",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            for (int i; cur; cur = i ? cur->child[i - 1] : nullptr) {",
			"                if (i = key_lower_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys; i < cur->keyNum) res = cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            block *cur = m_root;",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            for (int i; cur; cur = cur->child[i]) {",
			"                if (i = key_upper_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys; i < cur->keyNum) res = cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return m_root ? m_root->weight : 0; }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if constexpr (!_Tag::multi_key)",
			"                return it2 != it1;",
			"            else {",
			"                if (!it2)",
			"                    return size() - rank(__key);",
			"                else",
			"                    return rank(it2->key) - rank(__key);",
			"            }",
			"        }",
			"    };",
			"    namespace BTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>, int _K = 28>",
			"        using Set = BTree<_Tp, bool, _Compare, BTreeSetTag, _K>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>, int _K = 28>",
			"        using Multiset = BTree<_Tp, bool, _Compare, BTreeMultisetTag, _K>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>, int _K = 28>",
			"        using Map = BTree<_Tp, _Fp, _Compare, BTreeMapTag, _K>;",
			"    }",
			"}",
		],
		"description": "B tree"
	},
    "cat tree":{
        "prefix": "CAT",
        "body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation>",
			"    class CatTree {",
			"        std::vector<std::vector<_Tp>> m_sub;",
			"        _Operation m_op;",
			"        int m_length;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"",
			"    public:",
			"        CatTree(int __n = 0, _Operation __op = std::max<_Tp>, _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        CatTree(_Iterator __first, _Iterator __last, _Operation __op = std::max<_Tp>, _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            int d = m_length > 1 ? 32 - std::__countl_zero<uint32_t>(m_length - 1) : 1;",
			"            m_sub.resize(d);",
			"            for (int i = 0; i < d; i++) {",
			"                m_sub[i].resize(m_length * 2);",
			"                for (int j = 0, k = j + (1 << i); j < m_length; j += 1 << i, k = std::min(j + (1 << i), m_length)) {",
			"                    for (int l = j; l < k; l++) m_sub[i][l * 2] = l == j ? m_defaultValue : m_op(m_sub[i][(l - 1) * 2], m_defaultValue);",
			"                    for (int l = k - 1; l >= j; l--) m_sub[i][l * 2 + 1] = l == k - 1 ? m_defaultValue : m_op(m_sub[i][(l + 1) * 2 + 1], m_defaultValue);",
			"                }",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            int d = m_length > 1 ? 32 - std::__countl_zero<uint32_t>(m_length - 1) : 1;",
			"            m_sub.resize(d);",
			"            for (int i = 0; i < d; i++) {",
			"                m_sub[i].resize(m_length * 2);",
			"                for (int j = 0, k = j + (1 << i); j < m_length; j += 1 << i, k = std::min(j + (1 << i), m_length)) {",
			"                    for (int l = j; l < k; l++) m_sub[i][l * 2] = l == j ? *(__first + l) : m_op(m_sub[i][(l - 1) * 2], *(__first + l));",
			"                    for (int l = k - 1; l >= j; l--) m_sub[i][l * 2 + 1] = l == k - 1 ? *(__first + l) : m_op(m_sub[i][(l + 1) * 2 + 1], *(__first + l));",
			"                }",
			"            }",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            m_sub[0][__i * 2] = __val;",
			"            for (int i = 1; i < m_sub.size(); i++) {",
			"                int j = __i - (__i & (1 << i) - 1), k = std::min(j + (1 << i), m_length);",
			"                for (int l = j; l < k; l++) m_sub[i][l * 2] = l == j ? query(l) : m_op(m_sub[i][(l - 1) * 2], query(l));",
			"                for (int l = k - 1; l >= j; l--) m_sub[i][l * 2 + 1] = l == k - 1 ? query(l) : m_op(m_sub[i][(l + 1) * 2 + 1], query(l));",
			"            }",
			"        }",
			"        _Tp query(int __i) const { return m_sub[0][__i * 2]; }",
			"        _Tp query(int __left, int __right) const {",
			"            if (__left == __right) return m_sub[0][__left * 2];",
			"            int d = 31 - std::__countl_zero<uint32_t>(__right ^ __left);",
			"            return m_op(m_sub[d][__left * 2 + 1], m_sub[d][__right * 2]);",
			"        }",
			"        _Tp queryAll() const { return query(0, m_length - 1); }",
			"    };",
			"    template <typename _Tp = int>",
			"    CatTree(int = 0, const _Tp &(*)(const _Tp &, const _Tp &) = std::max<_Tp>) -> CatTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int>",
			"    CatTree(int, _Tp (*)(_Tp, _Tp)) -> CatTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    CatTree(int, _Operation) -> CatTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    CatTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &) = std::max<_Tp>) -> CatTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    CatTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp)) -> CatTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Operation, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    CatTree(_Iterator, _Iterator, _Operation) -> CatTree<_Tp, _Operation>;",
			"}",
        ],
        "description": "cat tree"
    },
	"discretizer":{
		"prefix": "DIS",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = int>",
			"    struct Discretizer : std::vector<_Tp> {",
			"        using std::vector<_Tp>::vector, std::vector<_Tp>::begin, std::vector<_Tp>::end, std::vector<_Tp>::insert, std::vector<_Tp>::push_back, std::vector<_Tp>::resize;",
			"        Discretizer &operator<<(const _Tp &__item) {",
			"            push_back(__item);",
			"            return *this;",
			"        }",
			"        Discretizer &operator<<(const std::vector<_Tp> &__items) {",
			"            insert(end(), __items.begin(), __items.end());",
			"            return *this;",
			"        }",
			"        Discretizer &operator<<(const std::vector<std::vector<_Tp>> &__items) {",
			"            for (auto &each : __items) *this << each;",
			"            return *this;",
			"        }",
			"        void prepare() {",
			"            std::sort(begin(), end());",
			"            resize(std::unique(begin(), end()) - begin());",
			"        }",
			"        int rank(const _Tp &__item) {",
			"            return lower_bound(__item);",
			"        }",
			"        int lower_bound(const _Tp &__item) {",
			"            return std::lower_bound(begin(), end(), __item) - begin();",
			"        }",
			"        int upper_bound(const _Tp &__item) {",
			"            return std::upper_bound(begin(), end(), __item) - begin();",
			"        }",
			"    };",
			"}",
		],
		"description": "discretizer"
	},
    "divide tree":{
        "prefix": "DIV",
        "body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"    class DivideTree {",
			"        std::vector<std::vector<int>> m_left;",
			"        std::vector<_Tp> m_sorted;",
			"        _Compare m_comp;",
			"        int m_length, m_depth;",
			"",
			"    public:",
			"        DivideTree(_Compare __comp = _Compare()) : m_comp(__comp) {}",
			"        template <typename _Iterator>",
			"        DivideTree(_Iterator __first, _Iterator __last, _Compare __comp = _Compare()) : m_comp(__comp) {",
			"            reset(__first, __last);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32);",
			"            m_sorted.resize(1 << m_depth);",
			"            m_left.resize(m_depth);",
			"            std::vector<int> leftSame(1 << m_depth, 1);",
			"            std::vector<_Tp> cur(1 << m_depth), nxt(1 << m_depth);",
			"            std::partial_sort_copy(__first, __last, m_sorted.begin(), m_sorted.begin() + m_length, m_comp);",
			"            std::fill(m_sorted.begin() + m_length, m_sorted.end(), m_sorted[m_length - 1]);",
			"            for (int i = 1; i < 1 << m_depth; i++)",
			"                if (!m_comp(m_sorted[i - 1], m_sorted[i])) leftSame[i] = leftSame[i - 1] + 1;",
			"            std::copy(__first, __last, cur.begin());",
			"            std::fill(cur.begin() + (__last - __first), cur.end(), m_sorted.back());",
			"            for (int i = 0; i < m_depth; i++) {",
			"                m_left[i].clear();",
			"                m_left[i].reserve(1 << m_depth);",
			"                for (int j = 0, k = 1 << (m_depth - i - 1); j < 1 << m_depth; j += k * 2) {",
			"                    _Tp mid = m_sorted[j + k - 1];",
			"                    int same = std::min(k, leftSame[j + k - 1]);",
			"                    int toLeft = 0;",
			"                    for (auto now = cur.begin() + j, end = cur.begin() + j + k * 2, l = nxt.begin() + j, r = nxt.begin() + j + k; now < end; ++now)",
			"                        if (m_comp(*now, mid) || (!m_comp(mid, *now) && same-- > 0)) {",
			"                            *l++ = *now;",
			"                            m_left[i].push_back(++toLeft);",
			"                        } else {",
			"                            *r++ = *now;",
			"                            m_left[i].push_back(toLeft);",
			"                        }",
			"                }",
			"                std::swap(cur, nxt);",
			"            }",
			"        }",
			"        _Tp query(int __left, int __right, int __k) const {",
			"            for (int i = 0, j = 1 << (m_depth - 1), k = 0; i < m_depth; i++, j >>= 1) {",
			"                int toLeft = m_left[i][__right] - (__left == k ? 0 : m_left[i][__left - 1]);",
			"                if (__k < toLeft) {",
			"                    __left = k + (__left == k ? 0 : m_left[i][__left - 1]);",
			"                    __right = k + m_left[i][__right] - 1;",
			"                } else {",
			"                    __left = __left == k ? j + k : __left + j - m_left[i][__left - 1];",
			"                    __right += j - m_left[i][__right];",
			"                    __k -= toLeft;",
			"                    k += j;",
			"                }",
			"            }",
			"            return m_sorted[__left];",
			"        }",
			"    };",
			"    template <typename _Compare = std::less<int>, typename _Tp = std::decay_t<typename decltype(std::function(std::declval<_Compare>()))::first_argument_type>>",
			"    DivideTree(_Compare = _Compare()) -> DivideTree<_Tp, _Compare>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Compare = std::less<_Tp>>",
			"    DivideTree(_Iterator, _Iterator, _Compare = _Compare()) -> DivideTree<_Tp, _Compare>;",
			"}",
        ],
        "description": "divide tree"
    },
	"fhq treap":{
		"prefix": "FHQ",
		"body": [
			"namespace OY {",
			"    struct FHQTreapSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct FHQTreapMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct FHQTreapMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _FHQTreapNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _FHQTreapNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = FHQTreapMultisetTag>",
			"    class FHQTreap {",
			"        struct node : _FHQTreapNode<_Tp, _Fp, _Tag::is_map> {",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static inline std::mt19937 s_rand;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        void split_less(node *p, const _Tp &key, node *&l, node *&r) {",
			"            if (!p)",
			"                l = r = nullptr;",
			"            else if (m_comp(p->key, key)) {",
			"                split_less(p->rchild, key, l, r);",
			"                p->rchild = l;",
			"                l = update(p);",
			"            } else {",
			"                split_less(p->lchild, key, l, r);",
			"                p->lchild = r;",
			"                r = update(p);",
			"            }",
			"        }",
			"        void split_less_equal(node *p, const _Tp &key, node *&l, node *&r) {",
			"            if (!p)",
			"                l = r = nullptr;",
			"            else if (m_comp(key, p->key)) {",
			"                split_less_equal(p->lchild, key, l, r);",
			"                p->lchild = r;",
			"                r = update(p);",
			"            } else {",
			"                split_less_equal(p->rchild, key, l, r);",
			"                p->rchild = l;",
			"                l = update(p);",
			"            }",
			"        }",
			"        void split_by_key(node *p, const _Tp &key, node *&l, node *&mid, node *&r) {",
			"            if (!p)",
			"                l = mid = r = nullptr;",
			"            else if (m_comp(p->key, key)) {",
			"                split_by_key(p->rchild, key, l, mid, r);",
			"                p->rchild = l;",
			"                l = update(p);",
			"            } else if (m_comp(key, p->key)) {",
			"                split_by_key(p->lchild, key, l, mid, r);",
			"                p->lchild = r;",
			"                r = update(p);",
			"            } else {",
			"                node *l_mid, *r_mid;",
			"                split_less(p->lchild, key, l, l_mid);",
			"                split_less_equal(p->rchild, key, r_mid, r);",
			"                p->lchild = l_mid;",
			"                p->rchild = r_mid;",
			"                mid = update(p);",
			"            }",
			"        }",
			"        void split_by_rank(node *p, int k, node *&l, node *&r) {",
			"            if (!k) {",
			"                l = nullptr;",
			"                r = p;",
			"            } else if (subtree_weight(p->lchild) > k) {",
			"                split_by_rank(p->lchild, k, l, r);",
			"                p->lchild = r;",
			"                r = update(p);",
			"            } else if (k -= subtree_weight(p->lchild); !k) {",
			"                l = p->lchild;",
			"                p->lchild = nullptr;",
			"                r = update(p);",
			"            } else {",
			"                split_by_rank(p->rchild, k - 1, l, r);",
			"                p->rchild = l;",
			"                l = update(p);",
			"            }",
			"        }",
			"        static node *merge(node *l, node *r) {",
			"            if (!l) return r;",
			"            if (!r) return l;",
			"            if (l->priority > r->priority) {",
			"                l->rchild = merge(l->rchild, r);",
			"                return update(l);",
			"            } else {",
			"                r->lchild = merge(l, r->lchild);",
			"                return update(r);",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        FHQTreap(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            node *l, *r;",
			"            split_less_equal(m_root, __key, l, r);",
			"            m_root = merge(merge(l, new node{__key, __args..., s_rand(), 1, nullptr, nullptr}), r);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(m_root, __key, l, mid, r);",
			"            if (!mid)",
			"                m_root = merge(l, r);",
			"            else {",
			"                delete mid;",
			"                m_root = mid->subtree_weight > 1 ? merge(merge(l, mid->lchild), merge(mid->rchild, r)) : merge(l, r);",
			"            }",
			"            return mid;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) {",
			"            node *l, *r;",
			"            split_less(m_root, __key, l, r);",
			"            int ord = subtree_weight(l);",
			"            m_root = merge(l, r);",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) {",
			"            node *l, *r;",
			"            split_by_rank(m_root, __k, l, r);",
			"            node *res = r;",
			"            while (res->lchild) res = res->lchild;",
			"            m_root = merge(l, r);",
			"            return res;",
			"        }",
			"        const node *find(_Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(m_root, __key, l, mid, r);",
			"            node *res = mid;",
			"            m_root = merge(merge(l, mid), r);",
			"            return res;",
			"        }",
			"        const node *lower_bound(_Tp __key) {",
			"            node *l, *r;",
			"            split_less(m_root, __key, l, r);",
			"            node *res = r;",
			"            while (res->lchild) res = res->lchild;",
			"            m_root = merge(l, r);",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) {",
			"            node *l, *r;",
			"            split_less_equal(m_root, __key, l, r);",
			"            node *res = r;",
			"            while (res->lchild) res = res->lchild;",
			"            m_root = merge(l, r);",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) {",
			"            node *l, *r;",
			"            split_less(m_root, __key, l, r);",
			"            node *res = l;",
			"            while (res->rchild) res = res->rchild;",
			"            m_root = merge(l, r);",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(m_root, __key, l, mid, r);",
			"            int res = subtree_weight(mid);",
			"            m_root = merge(merge(l, mid), r);",
			"            return res;",
			"        }",
			"    };",
			"    namespace FHQTreapContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = FHQTreap<_Tp, bool, _Compare, FHQTreapSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = FHQTreap<_Tp, bool, _Compare, FHQTreapMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = FHQTreap<_Tp, _Fp, _Compare, FHQTreapMapTag>;",
			"    }",
			"}",
		],
		"description": "fhq treap"
	},
	"fhq treap array":{
		"prefix": "FHQ",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    class FHQTreapArray {",
			"        struct node : MemoryPool<node> {",
			"            _Tp key;",
			"            bool reversed;",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            void reverse() { reversed = reversed ? false : true; }",
			"            void push_down() {",
			"                reverse();",
			"                std::swap(lchild, rchild);",
			"                if (lchild) lchild->reverse();",
			"                if (rchild) rchild->reverse();",
			"            }",
			"        };",
			"        node *m_root;",
			"        static inline std::mt19937 s_rand;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static void split_l_r(node *p, int k, node *child[2]) {",
			"            if (!p) return;",
			"            if (p->reversed) p->push_down();",
			"            if (!k) { //",
			"                child[0] = nullptr;",
			"                child[1] = p;",
			"            } else if (k == p->subtree_weight) {",
			"                child[0] = p;",
			"                child[1] = nullptr;",
			"            } else if (subtree_weight(p->lchild) > k) { //",
			"                split_l_r(p->lchild, k, child);",
			"                p->lchild = child[1];",
			"                child[1] = update(p);",
			"            } else if (k -= subtree_weight(p->lchild); k) { //",
			"                split_l_r(p->rchild, k - 1, child);         //",
			"                p->rchild = child[0];",
			"                child[0] = update(p);",
			"            } else {",
			"                child[0] = p->lchild;",
			"                p->lchild = nullptr;",
			"                child[1] = update(p);",
			"            }",
			"        }",
			"        static void split_l_m_r(node *p, int left, int right, node *child[3]) {",
			"            split_l_r(p, right + 1, child + 1);",
			"            split_l_r(child[1], left, child);",
			"        }",
			"        static node *merge(node *l, node *r) {",
			"            if (!l) return r;",
			"            if (!r) return l;",
			"            if (l->priority > r->priority) {",
			"                if (l->reversed) l->push_down();",
			"                l->rchild = merge(l->rchild, r);",
			"                return update(l);",
			"            } else {",
			"                if (r->reversed) r->push_down();",
			"                r->lchild = merge(l, r->lchild);",
			"                return update(r);",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        node *make_tree(_Iterator first, _Iterator last) {",
			"            auto _make_tree = [](auto self, _Iterator first, _Iterator last) -> node * {",
			"                if (first == last) return nullptr;",
			"                if (first + 1 == last) return new node{{}, *first, false, s_rand(), 1, nullptr, nullptr};",
			"                _Iterator mid = first + (last - first) / 2;",
			"                node *p = new node{{}, *mid, false, 0, 1, self(self, first, mid), self(self, mid + 1, last)};",
			"                return update(p);",
			"            };",
			"            node *root = _make_tree(_make_tree, first, last);",
			"            static std::vector<uint_fast32_t> s_prior;",
			"            static std::vector<node *> s_queue;",
			"            s_prior.resize(root->subtree_weight);",
			"            s_queue.clear();",
			"            s_queue.reserve(root->subtree_weight);",
			"            for (uint_fast32_t &a : s_prior) a = s_rand();",
			"            std::sort(s_prior.rbegin(), s_prior.rend());",
			"            s_queue.reserve(root->subtree_weight);",
			"            s_queue.push_back(root);",
			"            for (int i = 0; i < s_queue.size(); i++) {",
			"                node *p = s_queue[i];",
			"                p->priority = s_prior[i];",
			"                if (p->lchild) s_queue.push_back(p->lchild);",
			"                if (p->rchild) s_queue.push_back(p->rchild);",
			"            }",
			"            return root;",
			"        }",
			"        void _clear(node *cur) {} ",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        FHQTreapArray() : m_root(nullptr) {}",
			"        template <typename _Iterator>",
			"        FHQTreapArray(_Iterator __first, _Iterator __last) : m_root(make_tree(__first, __last)) {}",
			"        void clear() {",
			"            if (m_root) _clear(m_root);",
			"            m_root = nullptr;",
			"        }",
			"        void insert(int __pos, _Tp __key) {",
			"            node *child[2] = {0};",
			"            split_l_r(m_root, __pos, child);",
			"            m_root = merge(merge(child[0], new node{{}, __key, false, s_rand(), 1, nullptr, nullptr}), child[1]);",
			"        }",
			"        void insert(int __pos, FHQTreapArray<_Tp> &__toInsert) {",
			"            if (__pos == size())",
			"                join(__toInsert);",
			"            else {",
			"                FHQTreapArray<_Tp> sub = subArray(__pos, size() - 1);",
			"                join(__toInsert);",
			"                join(sub);",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void insert(int __pos, _Iterator __first, _Iterator __last) {",
			"            if (FHQTreapArray<_Tp> toInsert(__first, __last); toInsert.size()) insert(__pos, toInsert);",
			"        }",
			"        void update(int __pos, _Tp __key) { at(__pos)->key = __key; }",
			"        void erase(int __pos) {",
			"            node *child[3] = {0};",
			"            split_l_m_r(m_root, __pos, __pos, child);",
			"            delete child[1];",
			"            m_root = merge(child[0], child[2]);",
			"        }",
			"        void erase(int __left, int __right) {",
			"            node *child[3] = {0};",
			"            split_l_m_r(m_root, __left, __right, child);",
			"            if (child[1]) _clear(child[1]);",
			"            m_root = merge(child[0], child[2]);",
			"        }",
			"        template <typename _Iterator>",
			"        void assign(_Iterator __first, _Iterator __last) {",
			"            clear();",
			"            m_root = make_tree(__first, __last);",
			"        }",
			"        void reverse(int __left, int __right) {",
			"            node *child[3] = {0};",
			"            split_l_m_r(m_root, __left, __right, child);",
			"            child[1]->reverse();",
			"            m_root = merge(merge(child[0], child[1]), child[2]);",
			"        }",
			"        void push_front(_Tp __key) { m_root = merge(new node{{}, __key, false, s_rand(), 1, nullptr, nullptr}, m_root); }",
			"        void push_back(_Tp __key) { m_root = merge(m_root, new node{{}, __key, false, s_rand(), 1, nullptr, nullptr}); }",
			"        void pop_front() {",
			"            node *child[2];",
			"            split_l_r(m_root, 1, child);",
			"            delete child[0];",
			"            m_root = child[1];",
			"        }",
			"        void pop_back() {",
			"            node *child[2];",
			"            split_l_r(m_root, m_root->subtree_weight - 1, child);",
			"            delete child[1];",
			"            m_root = child[0];",
			"        }",
			"        node *at(int __pos) const {",
			"            node *cur = m_root;",
			"            while (true) {",
			"                if (cur->reversed) cur->push_down();",
			"                if (subtree_weight(cur->lchild) > __pos)",
			"                    cur = cur->lchild;",
			"                else if (__pos -= subtree_weight(cur->lchild); !__pos--)",
			"                    break;",
			"                else",
			"                    cur = cur->rchild;",
			"            };",
			"            return cur;",
			"        }",
			"        _Tp &operator[](int __index) const { return at(__index)->key; }",
			"        node *front(int __pos) const { return at(0); }",
			"        node *back() const { return at(size() - 1); }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        FHQTreapArray<_Tp> subArray(int __left, int __right) {",
			"            node *child[3] = {0};",
			"            split_l_m_r(m_root, __left, __right, child);",
			"            m_root = merge(child[0], child[2]);",
			"            FHQTreapArray<_Tp> sub;",
			"            sub.m_root = child[1];",
			"            return sub;",
			"        }",
			"        void join(FHQTreapArray<_Tp> &__other) {",
			"            m_root = merge(m_root, __other.m_root);",
			"            __other.m_root = nullptr;",
			"        }",
			"        template <typename _Sequence = std::vector<_Tp>>",
			"        _Sequence to_sequence() const {",
			"            _Sequence v;",
			"            v.reserve(size());",
			"            auto dfs = [&](auto self, node *cur) -> void {",
			"                if (cur->reversed) cur->push_down();",
			"                if (cur->lchild) self(self, cur->lchild);",
			"                v.push_back(cur->key);",
			"                if (cur->rchild) self(self, cur->rchild);",
			"            };",
			"            if (m_root) dfs(dfs, m_root);",
			"            return v;",
			"        }",
			"        template <typename _Sequence = std::vector<_Tp>>",
			"        _Sequence to_sequence(int __left, int __right) const {",
			"            _Sequence v;",
			"            v.reserve(__right - __left + 1);",
			"            auto dfs = [&](auto self, node *cur, int smaller) -> void {",
			"                if (cur->reversed) cur->push_down();",
			"                if (cur->lchild) {",
			"                    if (__left < smaller + cur->lchild->subtree_weight) self(self, cur->lchild, smaller);",
			"                    smaller += cur->lchild->subtree_weight;",
			"                }",
			"                if (__right < smaller) return;",
			"                if (__left <= smaller) v.push_back(cur->key);",
			"                if (__right >= ++smaller && cur->rchild) self(self, cur->rchild, smaller);",
			"            };",
			"            if (m_root) dfs(dfs, m_root, 0);",
			"            return v;",
			"        }",
			"    };",
			"    template <typename _Tp = int>",
			"    FHQTreapArray() -> FHQTreapArray<_Tp>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    FHQTreapArray(_Iterator, _Iterator) -> FHQTreapArray<_Tp>;",
			"}",
		],
		"description": "fhq treap array"
	},
	"kd tree":{
		"prefix": "KD",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, int _K>",
			"    struct KDTreeRectRange {",
			"        _Tp min[_K];",
			"        _Tp max[_K];",
			"        template <typename treenode>",
			"        bool intersect(const treenode &rect) const {",
			"            for (int i = 0; i < _K; i++)",
			"                if (rect.max[i] < min[i] || rect.min[i] > max[i]) return false;",
			"            return true;",
			"        }",
			"        template <typename treenode>",
			"        bool contain_rect(const treenode &rect) const {",
			"            for (int i = 0; i < _K; i++)",
			"                if (rect.min[i] < min[i] || rect.max[i] > max[i]) return false;",
			"            return true;",
			"        }",
			"        template <typename node>",
			"        bool contain_point(const node &point) const {",
			"            for (int i = 0; i < _K; i++)",
			"                if (point.pos[i] < min[i] || point.pos[i] > max[i]) return false;",
			"            return true;",
			"        }",
			"    };",
			"    template <typename _Tp, int _K, typename _TpDistance>",
			"    struct KDTreeCircleRange {",
			"        _Tp pos[_K];",
			"        _TpDistance radius_square;",
			"        template <typename treenode>",
			"        bool intersect(const treenode &rect) const {",
			"            bool out = false;",
			"            for (int i = 0; i < _K; i++)",
			"                if (pos[i] < rect.min[i] || pos[i] > rect.max[i]) {",
			"                    out = true;",
			"                    break;",
			"                }",
			"            if (!out) return true;",
			"            _TpDistance dis = 0;",
			"            for (int i = 0; i < _K; i++) {",
			"                _TpDistance p = 0;",
			"                if (pos[i] < rect.min[i])",
			"                    p = rect.min[i] - pos[i];",
			"                else if (pos[i] > rect.max[i])",
			"                    p = rect.max[i] - pos[i];",
			"                dis += p * p;",
			"            }",
			"            return dis <= radius_square;",
			"        }",
			"        template <typename treenode>",
			"        bool contain_rect(const treenode &rect) const {",
			"            _TpDistance dis = 0;",
			"            for (int i = 0; i < _K; i++) {",
			"                _TpDistance p = std::max(std::abs(rect.min[i] - pos[i]), std::abs(rect.max[i] - pos[i]));",
			"                dis += p * p;",
			"            }",
			"            return dis <= radius_square;",
			"        }",
			"        template <typename node>",
			"        bool contain_point(const node &point) const {",
			"            _TpDistance dis = 0;",
			"            for (int i = 0; i < _K; i++) {",
			"                _TpDistance p = point.pos[i] - pos[i];",
			"                dis += p * p;",
			"            }",
			"            return dis <= radius_square;",
			"        }",
			"    };",
			"    template <typename _Tp, typename _Fp, typename _Operation = std::plus<_Fp>, int _K = 2, int _N = 31>",
			"    class KDTree {",
			"    public:",
			"        struct node : MemoryPool<node> {",
			"            _Tp pos[_K];",
			"            _Fp value;",
			"            node() {}",
			"            node(const std::initializer_list<_Tp> &_pos, _Fp _value = _Fp()) : value(_value) { std::copy(_pos.begin(), _pos.end(), pos); }",
			"        };",
			"        struct treenode : MemoryPool<treenode> {",
			"            _Tp min[_K];",
			"            _Tp max[_K];",
			"            int size;",
			"            _Tp thresh;",
			"            _Fp value;",
			"            std::vector<node *> points;",
			"            treenode *lchild;",
			"            treenode *rchild;",
			"            treenode(_Fp _defaultValue = _Fp()) : size(0), value(_defaultValue), lchild(nullptr), rchild(nullptr) {}",
			"            treenode(node *point) : size(1), points({point}), lchild(nullptr), rchild(nullptr) {",
			"                for (int i = 0; i < _K; i++) min[i] = max[i] = point->pos[i];",
			"                value = point->value;",
			"            }",
			"            bool contain_point(const std::initializer_list<_Tp> &pos) const {",
			"                for (int i = 0; i < _K; i++)",
			"                    if (_Tp x = *(pos.begin() + i); x < min[i] || x > max[i]) return false;",
			"                return true;",
			"            }",
			"        };",
			"        treenode *m_root;",
			"",
			"    private:",
			"        _Operation m_op;",
			"        _Fp m_defaultValue;",
			"        std::vector<node *> m_buffer;",
			"        static constexpr int ratio = 4, bias = 4;",
			"        static treenode *updateRange(treenode *p, node *q) {",
			"            for (int i = 0; i < _K; i++) {",
			"                _Tp pos = q->pos[i];",
			"                if (pos < p->min[i])",
			"                    p->min[i] = pos;",
			"                else if (pos > p->max[i])",
			"                    p->max[i] = pos;",
			"            }",
			"            return p;",
			"        }",
			"        static treenode *updateRange(treenode *p, const std::initializer_list<_Tp> &pos) {",
			"            for (int i = 0; i < _K; i++) {",
			"                _Tp _pos = *(pos.begin() + i);",
			"                if (_pos < p->min[i])",
			"                    p->min[i] = _pos;",
			"                else if (_pos > p->max[i])",
			"                    p->max[i] = _pos;",
			"            }",
			"            return p;",
			"        }",
			"        treenode *updateByChild(treenode *p) {",
			"            std::copy(p->lchild->min, p->lchild->min + _K, p->min);",
			"            std::copy(p->lchild->max, p->lchild->max + _K, p->max);",
			"            for (int i = 0; i < _K; i++)",
			"                if (p->rchild->min[i] < p->min[i]) p->min[i] = p->rchild->min[i];",
			"            for (int i = 0; i < _K; i++)",
			"                if (p->rchild->max[i] > p->max[i]) p->max[i] = p->rchild->max[i];",
			"            p->size = p->lchild->size + p->rchild->size;",
			"            p->value = m_op(p->lchild->value, p->rchild->value);",
			"            return p;",
			"        }",
			"        treenode *updateBySelf(treenode *p) {",
			"            p->size = p->points.size();",
			"            p->value = p->points[0]->value;",
			"            for (int i = 1; i < p->points.size(); i++) p->value = m_op(p->value, p->points[i]->value);",
			"            return p;",
			"        }",
			"        treenode *update(treenode *p, const std::initializer_list<_Tp> &pos) {",
			"            for (int i = 0; i < _K; i++) {",
			"                _Tp _pos = *(pos.begin() + i);",
			"                if (_pos < p->min[i])",
			"                    p->min[i] = _pos;",
			"                else if (_pos > p->max[i])",
			"                    p->max[i] = _pos;",
			"            }",
			"            if (p->lchild) {",
			"                p->size = p->lchild->size + p->rchild->size;",
			"                p->value = m_op(p->lchild->value, p->rchild->value);",
			"            } else {",
			"                p->size = p->points.size();",
			"                p->value = p->points[0]->value;",
			"                for (int i = 1; i < p->points.size(); i++) p->value = m_op(p->value, p->points[i]->value);",
			"            }",
			"            return p;",
			"        }",
			"        treenode *update(treenode *p) {",
			"            if (p->lchild) {",
			"                p->size = p->lchild->size + p->rchild->size;",
			"                p->value = m_op(p->lchild->value, p->rchild->value);",
			"            } else {",
			"                p->size = p->points.size();",
			"                p->value = p->points[0]->value;",
			"                for (int i = 1; i < p->points.size(); i++) p->value = m_op(p->value, p->points[i]->value);",
			"            }",
			"            return p;",
			"        }",
			"        treenode *balance(treenode *cur, int i) {",
			"            if (cur->lchild) {",
			"                if (cur->lchild->size + cur->rchild->size <= _N || cur->lchild->size > cur->rchild->size * ratio + bias || cur->rchild->size > cur->lchild->size * ratio + bias) return rebuild(cur, i);",
			"            } else if (cur->points.size() > _N)",
			"                return rebuild(cur, i);",
			"            return cur;",
			"        }",
			"        void traverse(treenode *p) {",
			"            if (!p->lchild && !p->rchild) {",
			"                for (node *q : p->points) m_buffer.push_back(q);",
			"            } else {",
			"                if (p->lchild) traverse(p->lchild);",
			"                if (p->rchild) traverse(p->rchild);",
			"            }",
			"            delete p;",
			"        }",
			"        treenode *make_tree(node **first, node **last, int i) {",
			"            if (first == last) return nullptr;",
			"            if (last - first <= _N) {",
			"                treenode *p = new treenode(*first++);",
			"                while (first < last) {",
			"                    p->points.push_back(*first);",
			"                    p = updateRange(p, *first++);",
			"                }",
			"                return updateBySelf(p);",
			"            } else {",
			"                treenode *p = new treenode(m_defaultValue);",
			"                node **mid = first + (last - first) / 2;",
			"                std::nth_element(first, mid, last, [&](const node *x, const node *y) { return x->pos[i] < y->pos[i]; });",
			"                p->thresh = (*mid)->pos[i];",
			"                p->lchild = make_tree(first, mid, i + 1 < _K ? i + 1 : 0);",
			"                p->rchild = make_tree(mid, last, i + 1 < _K ? i + 1 : 0);",
			"                return updateByChild(p);",
			"            }",
			"        }",
			"        treenode *rebuild(treenode *cur, int i) {",
			"            if (cur) traverse(cur);",
			"            cur = make_tree(m_buffer.data(), m_buffer.data() + m_buffer.size(), i);",
			"            m_buffer.clear();",
			"            return cur;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __treeCount, int __nodeCount) {",
			"            MemoryPool<treenode>::_reserve(__treeCount);",
			"            MemoryPool<node>::_reserve(__nodeCount);",
			"        }",
			"        KDTree(_Operation __op = _Operation(), _Fp __defaultValue = _Fp()) : m_root(nullptr), m_op(__op), m_defaultValue(__defaultValue) {}",
			"        ~KDTree() { clear(); }",
			"        void clear() {",
			"            m_root = nullptr;",
			"        }",
			"        void prepared_insert(const std::initializer_list<_Tp> &__pos, _Fp __value = _Fp(1)) { m_buffer.push_back(new node(__pos, __value)); }",
			"        void prepared_build() {",
			"            m_root = make_tree(m_buffer.data(), m_buffer.data() + m_buffer.size(), 0);",
			"            m_buffer.clear();",
			"        }",
			"        void insert(const std::initializer_list<_Tp> &__pos, _Fp __value = _Fp(1)) {",
			"            auto dfs = [&](auto self, treenode *cur, int i) -> treenode * {",
			"                if (!cur)",
			"                    return new treenode(new node(__pos, __value));",
			"                else if (!cur->lchild)",
			"                    cur->points.push_back(new node(__pos, __value));",
			"                else if (*(__pos.begin() + i) < cur->thresh)",
			"                    cur->lchild = self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                else",
			"                    cur->rchild = self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                return balance(update(cur, __pos), i);",
			"            };",
			"            m_root = dfs(dfs, m_root, 0);",
			"        }",
			"        bool erase(const std::initializer_list<_Tp> &__pos) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, treenode *cur, int i) -> treenode * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (!cur->lchild) {",
			"                    auto it = std::find_if(cur->points.begin(), cur->points.end(), [&](const node *p) {",
			"                        for (int i = 0; i < _K; i++)",
			"                            if (p->pos[i] != *(__pos.begin() + i)) return false;",
			"                        return true;",
			"                    });",
			"                    if (it != cur->points.end()) {",
			"                        res = true;",
			"                        cur->points.erase(it);",
			"                    }",
			"                } else {",
			"                    if (*(__pos.begin() + i) <= cur->thresh) cur->lchild = self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                    if (!res && *(__pos.begin() + i) >= cur->thresh) cur->rchild = self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                }",
			"                return res ? balance(update(cur), i) : cur;",
			"            };",
			"            m_root = dfs(dfs, m_root, 0);",
			"            return res;",
			"        }",
			"        const node *find(const std::initializer_list<_Tp> &__pos) const {",
			"            node *res = nullptr;",
			"            auto dfs = [&](auto self, treenode *cur, int i) {",
			"                if (!cur)",
			"                    return;",
			"                else if (!cur->lchild) {",
			"                    auto it = std::find_if(cur->points.begin(), cur->points.end(), [&](const node *p) {",
			"                        for (int i = 0; i < _K; i++)",
			"                            if (p->pos[i] != *(__pos.begin() + i)) return false;",
			"                        return true;",
			"                    });",
			"                    if (it != cur->points.end()) res = *it;",
			"                } else {",
			"                    if (*(__pos.begin() + i) <= cur->thresh) self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                    if (!res && *(__pos.begin() + i) >= cur->thresh) self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0);",
			"            return res;",
			"        }",
			"        template <typename _Range>",
			"        _Fp queryNumber(const _Range &__range) const {",
			"            _Fp res = m_defaultValue;",
			"            auto dfs = [&](auto self, treenode *cur) {",
			"                if (!__range.intersect(*cur)) return;",
			"                if (__range.contain_rect(*cur))",
			"                    res = m_op(res, cur->value);",
			"                else if (cur->lchild) {",
			"                    if (cur->lchild) self(self, cur->lchild);",
			"                    if (cur->rchild) self(self, cur->rchild);",
			"                } else",
			"                    for (node *point : cur->points)",
			"                        if (__range.contain_point(*point)) res = m_op(res, point->value);",
			"            };",
			"            if (m_root) dfs(dfs, m_root);",
			"            return res;",
			"        }",
			"        _Fp queryNumber_rect(const KDTreeRectRange<_Tp, _K> &__range) const {",
			"            return queryNumber(__range);",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _Fp queryNumber_circle(const KDTreeCircleRange<_Tp, _K, _TpDistance> &__range) const {",
			"            return queryNumber(__range);",
			"        }",
			"        template <typename _TpDistance, bool _DropZero, typename _DistanceConvert>",
			"        _TpDistance queryClosest(const std::initializer_list<_Tp> &__pos, _DistanceConvert __conv) const {",
			"            _TpDistance dis = std::numeric_limits<_TpDistance>::max();",
			"            auto dfs = [&](auto self, treenode *cur, int i) {",
			"                if (!cur->contain_point(__pos)) {",
			"                    _TpDistance d = 0;",
			"                    for (int i = 0; i < _K; i++) {",
			"                        _TpDistance di = 0;",
			"                        if (_Tp pos = *(__pos.begin() + i); pos < cur->min[i])",
			"                            di = cur->min[i] - pos;",
			"                        else if (pos > cur->max[i])",
			"                            di = pos - cur->max[i];",
			"                        d += __conv(di);",
			"                    }",
			"                    if (dis <= d) return;",
			"                }",
			"                if (cur->lchild) {",
			"                    if (*(__pos.begin() + i) < cur->thresh) {",
			"                        self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                        self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                    } else {",
			"                        self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                        self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                    }",
			"                } else {",
			"                    for (auto p : cur->points) {",
			"                        _TpDistance d = 0;",
			"                        for (int i = 0; i < _K; i++) {",
			"                            _TpDistance di;",
			"                            if (_Tp pos = *(__pos.begin() + i); pos < p->pos[i])",
			"                                di = p->pos[i] - pos;",
			"                            else",
			"                                di = pos - p->pos[i];",
			"                            d += __conv(di);",
			"                        }",
			"                        if constexpr (_DropZero) {",
			"                            if (d && d < dis) dis = d;",
			"                        } else {",
			"                            if (d < dis) dis = d;",
			"                        }",
			"                    }",
			"                }",
			"            };",
			"            if (m_root) dfs(dfs, m_root, 0);",
			"            return dis;",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _TpDistance queryClosest_Euclidean(const std::initializer_list<_Tp> &__pos) const {",
			"            return queryClosest<_TpDistance, true>(__pos, [](auto x) { return x * x; });",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _TpDistance queryClosest_Manhattan(const std::initializer_list<_Tp> &__pos) const {",
			"            return queryClosest<_TpDistance, true>(__pos, [](auto x) { return x; });",
			"        }",
			"        template <typename _TpDistance, typename _DistanceConvert>",
			"        _TpDistance queryFurthest(const std::initializer_list<_Tp> &__pos, _DistanceConvert __conv) const {",
			"            _TpDistance dis = 0;",
			"            auto dfs = [&](auto self, treenode *cur, int i) {",
			"                _TpDistance d = 0;",
			"                for (int i = 0; i < _K; i++) {",
			"                    _Tp pos = *(__pos.begin() + i);",
			"                    _TpDistance di = std::max(std::abs(pos - cur->min[i]), std::abs(pos - cur->max[i]));",
			"                    d += __conv(di);",
			"                }",
			"                if (dis >= d) return;",
			"                if (cur->lchild) {",
			"                    if (*(__pos.begin() + i) < cur->thresh) {",
			"                        self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                        self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                    } else {",
			"                        self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                        self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                    }",
			"                } else {",
			"                    for (auto p : cur->points) {",
			"                        _TpDistance d = 0;",
			"                        for (int i = 0; i < _K; i++) {",
			"                            _TpDistance di;",
			"                            if (_Tp pos = *(__pos.begin() + i); pos < p->pos[i])",
			"                                di = p->pos[i] - pos;",
			"                            else",
			"                                di = pos - p->pos[i];",
			"                            d += __conv(di);",
			"                        }",
			"                        if (d > dis) dis = d;",
			"                    }",
			"                }",
			"            };",
			"            if (m_root) dfs(dfs, m_root, 0);",
			"            return dis;",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _TpDistance queryFurthest_Euclidean(const std::initializer_list<_Tp> &__pos) const {",
			"            return queryFurthest<_TpDistance>(__pos, [](auto x) { return x * x; });",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _TpDistance queryFurthest_Manhattan(const std::initializer_list<_Tp> &__pos) const {",
			"            return queryFurthest<_TpDistance>(__pos, [](auto x) { return x; });",
			"        }",
			"    };",
			"}",
		],
		"description": "kd tree"
	},
	"kind manager":{
		"prefix": "KIND",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Map = std::map<_Tp, uint32_t>>",
			"    struct KindManager {",
			"        PersistentSegTree<int, std::plus<int>> m_tree;",
			"        _Map m_last;",
			"        std::vector<uint32_t> m_realVersion;",
			"        template <typename _Iterator>",
			"        KindManager(_Iterator __first, _Iterator __last) : m_tree(__last - __first), m_last{} {",
			"            m_realVersion.reserve(__last - __first);",
			"            for (auto it = __first; it != __last; ++it) {",
			"                if (uint32_t last = m_last[*it]) m_tree.add(-1, last - 1, -1);",
			"                m_tree.add(-1, (m_last[*it] = it - __first + 1) - 1, 1);",
			"                m_realVersion.push_back(m_tree.versionCount() - 1);",
			"            }",
			"        }",
			"        uint32_t query(uint32_t __left, uint32_t __right) const { return m_tree.query(m_realVersion[__right], __left, __right); }",
			"    };",
		],
		"description": "Kind Manager"
	},
	"lazy bitset":{
		"prefix": "BITSET",
		"body": [
			"namespace OY {",
			"    struct LazyBitset {",
			"        struct _BitsetNode : MemoryPool<_BitsetNode> {",
			"            int sum;",
			"            bool flipped;",
			"            _BitsetNode *lchild;",
			"            _BitsetNode *rchild;",
			"            _BitsetNode(int _sum, bool _flipped, _BitsetNode *_lchild, _BitsetNode *_rchild) : sum(_sum), flipped(_flipped), lchild(_lchild), rchild(_rchild) {}",
			"            void flip(int size) {",
			"                sum = size - sum;",
			"                flipped = flipped ? false : true;",
			"            }",
			"        };",
			"        int m_length;",
			"        _BitsetNode *m_root;",
			"        void _pushDown_one(_BitsetNode *cur) const {",
			"            if (int half = (cur->sum + 1) / 2; !cur->lchild)",
			"                cur->lchild = new _BitsetNode(half, false, nullptr, nullptr);",
			"            else",
			"                cur->lchild->sum = half;",
			"            if (int half = cur->sum / 2; !cur->rchild)",
			"                cur->rchild = new _BitsetNode(half, false, nullptr, nullptr);",
			"            else",
			"                cur->rchild->sum = half;",
			"        }",
			"        void _pushDown_zero(_BitsetNode *cur) const {",
			"            if (cur->lchild) cur->lchild->sum = 0;",
			"            if (cur->rchild) cur->rchild->sum = 0;",
			"        }",
			"        void _pushDown_flip(_BitsetNode *cur, int left, int right) const {",
			"            if (int half = (right - left) / 2 + 1; !cur->lchild)",
			"                cur->lchild = new _BitsetNode(half, false, nullptr, nullptr);",
			"            else",
			"                cur->lchild->flip(half);",
			"            if (int half = (right - left + 1) / 2; !cur->rchild)",
			"                cur->rchild = new _BitsetNode(half, false, nullptr, nullptr);",
			"            else",
			"                cur->rchild->flip(half);",
			"            cur->flipped = false;",
			"        }",
			"        void _update(_BitsetNode *cur) {",
			"            cur->sum = (cur->lchild ? cur->lchild->sum : 0) + (cur->rchild ? cur->rchild->sum : 0);",
			"            cur->flipped = false;",
			"        }",
			"        LazyBitset(int __n = 0) : m_length(__n) { m_root = new _BitsetNode(0, false, nullptr, nullptr); }",
			"        void resize(int __n) {",
			"            m_length = __n;",
			"            reset();",
			"        }",
			"        void set() { m_root->sum = m_length; }",
			"        void set(int __i) {",
			"            auto dfs = [&](auto self, _BitsetNode *&cur, int left, int right) -> void {",
			"                if (left == right) {",
			"                    if (!cur)",
			"                        cur = new _BitsetNode(1, false, nullptr, nullptr);",
			"                    else",
			"                        cur->sum = 1;",
			"                } else if (!cur || cur->sum < right - left + 1) {",
			"                    if (!cur)",
			"                        cur = new _BitsetNode(0, false, nullptr, nullptr);",
			"                    else if (!cur->sum)",
			"                        _pushDown_zero(cur);",
			"                    else if (cur->flipped)",
			"                        _pushDown_flip(cur, left, right);",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        self(self, cur->lchild, left, mid);",
			"                    else",
			"                        self(self, cur->rchild, mid + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void set(int __left, int __right) {",
			"            auto dfs = [&](auto self, _BitsetNode *&cur, int left, int right) -> void {",
			"                if (__left <= left && __right >= right) {",
			"                    if (!cur)",
			"                        cur = new _BitsetNode(right - left + 1, false, nullptr, nullptr);",
			"                    else",
			"                        cur->sum = right - left + 1;",
			"                } else if (!cur || cur->sum < right - left + 1) {",
			"                    if (!cur)",
			"                        cur = new _BitsetNode(0, false, nullptr, nullptr);",
			"                    else if (!cur->sum)",
			"                        _pushDown_zero(cur);",
			"                    else if (cur->flipped)",
			"                        _pushDown_flip(cur, left, right);",
			"                    int mid = (left + right) / 2;",
			"                    if (__left <= mid) self(self, cur->lchild, left, mid);",
			"                    if (__right > mid) self(self, cur->rchild, mid + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void reset() { m_root->sum = 0; }",
			"        void reset(int __i) {",
			"            auto dfs = [&](auto self, _BitsetNode *&cur, int left, int right) -> void {",
			"                if (left == right) {",
			"                    if (cur) cur->sum = 0;",
			"                } else if (cur && cur->sum) {",
			"                    if (cur->sum == right - left + 1)",
			"                        _pushDown_one(cur);",
			"                    else if (cur->flipped)",
			"                        _pushDown_flip(cur, left, right);",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        self(self, cur->lchild, left, mid);",
			"                    else",
			"                        self(self, cur->rchild, mid + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void reset(int __left, int __right) {",
			"            auto dfs = [&](auto self, _BitsetNode *&cur, int left, int right) -> void {",
			"                if (__left <= left && __right >= right) {",
			"                    if (cur) cur->sum = 0;",
			"                } else if (cur && cur->sum) {",
			"                    if (cur->sum == right - left + 1)",
			"                        _pushDown_one(cur);",
			"                    else if (cur->flipped)",
			"                        _pushDown_flip(cur, left, right);",
			"                    int mid = (left + right) / 2;",
			"                    if (__left <= mid) self(self, cur->lchild, left, mid);",
			"                    if (__right > mid) self(self, cur->rchild, mid + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void flip() { m_root->flip(m_length); }",
			"        void flip(int __i) {",
			"            auto dfs = [&](auto self, _BitsetNode *&cur, int left, int right) -> void {",
			"                if (left == right) {",
			"                    if (!cur)",
			"                        cur = new _BitsetNode(1, false, nullptr, nullptr);",
			"                    else",
			"                        cur->flip(1);",
			"                } else {",
			"                    if (!cur)",
			"                        cur = new _BitsetNode(0, false, nullptr, nullptr);",
			"                    else if (cur->sum == right - left + 1)",
			"                        _pushDown_one(cur);",
			"                    else if (!cur->sum)",
			"                        _pushDown_zero(cur);",
			"                    else if (cur->flipped)",
			"                        _pushDown_flip(cur, left, right);",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        self(self, cur->lchild, left, mid);",
			"                    else",
			"                        self(self, cur->rchild, mid + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void flip(int __left, int __right) {",
			"            auto dfs = [&](auto self, _BitsetNode *&cur, int left, int right) -> void {",
			"                if (__left <= left && __right >= right) {",
			"                    if (!cur)",
			"                        cur = new _BitsetNode(right - left + 1, false, nullptr, nullptr);",
			"                    else",
			"                        cur->flip(right - left + 1);",
			"                } else {",
			"                    if (!cur)",
			"                        cur = new _BitsetNode(0, false, nullptr, nullptr);",
			"                    else if (cur->sum == right - left + 1)",
			"                        _pushDown_one(cur);",
			"                    else if (!cur->sum)",
			"                        _pushDown_zero(cur);",
			"                    else if (cur->flipped)",
			"                        _pushDown_flip(cur, left, right);",
			"                    int mid = (left + right) / 2;",
			"                    if (__left <= mid) self(self, cur->lchild, left, mid);",
			"                    if (__right > mid) self(self, cur->rchild, mid + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        int first() const {",
			"            if (!m_root->sum) return -1;",
			"            auto dfs = [&](auto self, _BitsetNode *cur, int left, int right) -> int {",
			"                if (cur->sum == right - left + 1)",
			"                    return left;",
			"                else {",
			"                    if (cur->flipped) _pushDown_flip(cur, left, right);",
			"                    if (int mid = (left + right) / 2; cur->lchild && cur->lchild->sum)",
			"                        return self(self, cur->lchild, left, mid);",
			"                    else",
			"                        return self(self, cur->rchild, mid + 1, right);",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        int prev(int __i) const {",
			"            auto dfs = [&](auto self, _BitsetNode *cur, int left, int right) -> int {",
			"                if (!cur || !cur->sum || __i == left) return -1;",
			"                if (cur->sum == right - left + 1)",
			"                    return std::min(right, __i - 1);",
			"                else {",
			"                    if (cur->flipped) _pushDown_flip(cur, left, right);",
			"                    int mid = (left + right) / 2, res = -1;",
			"                    if (__i > mid + 1) res = self(self, cur->rchild, mid + 1, right);",
			"                    if (!~res) res = self(self, cur->lchild, left, mid);",
			"                    return res;",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        int next(int __i) const {",
			"            auto dfs = [&](auto self, _BitsetNode *cur, int left, int right) -> int {",
			"                if (!cur || !cur->sum || __i == right) return -1;",
			"                if (cur->sum == right - left + 1)",
			"                    return std::max(left, __i + 1);",
			"                else {",
			"                    if (cur->flipped) _pushDown_flip(cur, left, right);",
			"                    int mid = (left + right) / 2, res = -1;",
			"                    if (__i < mid) res = self(self, cur->lchild, left, mid);",
			"                    if (!~res) res = self(self, cur->rchild, mid + 1, right);",
			"                    return res;",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        int last() const {",
			"            if (!m_root->sum) return -1;",
			"            auto dfs = [&](auto self, _BitsetNode *cur, int left, int right) -> int {",
			"                if (cur->sum == right - left + 1)",
			"                    return right;",
			"                else {",
			"                    if (cur->flipped) _pushDown_flip(cur, left, right);",
			"                    if (int mid = (left + right) / 2; cur->rchild && cur->rchild->sum)",
			"                        return self(self, cur->rchild, mid + 1, right);",
			"                    else",
			"                        return self(self, cur->lchild, left, mid);",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        int count() const { return m_root->sum; }",
			"        int count(int __left, int __right) const {",
			"            auto dfs = [&](auto self, _BitsetNode *cur, int left, int right) -> int {",
			"                if (__left <= left && __right >= right)",
			"                    return cur ? cur->sum : 0;",
			"                else if (!cur || !cur->sum)",
			"                    return 0;",
			"                else if (cur->sum == right - left + 1)",
			"                    return std::min(right, __right) - std::max(left, __left) + 1;",
			"                else {",
			"                    if (cur->flipped) _pushDown_flip(cur, left, right);",
			"                    if (int mid = (left + right) / 2; __right <= mid)",
			"                        return self(self, cur->lchild, left, mid);",
			"                    else if (__left > mid)",
			"                        return self(self, cur->rchild, mid + 1, right);",
			"                    else",
			"                        return self(self, cur->lchild, left, mid) + self(self, cur->rchild, mid + 1, right);",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        bool at(int __i) const {",
			"            auto dfs = [&](auto self, _BitsetNode *cur, int left, int right) -> int {",
			"                if (left == right)",
			"                    return cur && cur->sum;",
			"                else if (!cur || !cur->sum)",
			"                    return 0;",
			"                else if (cur->sum == right - left + 1)",
			"                    return 1;",
			"                else {",
			"                    if (cur->flipped) _pushDown_flip(cur, left, right);",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        return self(self, cur->lchild, left, mid);",
			"                    else",
			"                        return self(self, cur->rchild, mid + 1, right);",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        bool operator[](int __i) const { return at(__i); }",
			"        bool all() const { return count() == m_length; }",
			"        bool any() const { return count(); }",
			"    };",
			"}",
		],
		"description": "lazy bitset"
	},
	"lazy seg tree":{
		"prefix": "LAZY",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct LazySegAdd {",
			"        _Tp operator()(const _Fp &__x, const _Tp &__y, int __size) const { return __x * __size + __y; }",
			"    };",
			"    template <typename _Tp = int64_t, typename _Fp = _Tp, typename _Operation = std::plus<_Tp>, typename _Mapping = LazySegAdd<_Tp, _Fp>, typename _Composition = std::plus<_Fp>>",
			"    class LazySegTree {",
			"        struct _Tp_FpNode : MemoryPool<_Tp_FpNode> {",
			"            _Tp val;",
			"            _Fp inc;",
			"            _Tp_FpNode *lchild;",
			"            _Tp_FpNode *rchild;",
			"            _Tp_FpNode(_Tp _val, _Fp _inc, _Tp_FpNode *_lchild, _Tp_FpNode *_rchild) : val(_val), inc(_inc), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        _Tp_FpNode *m_root;",
			"        int m_length;",
			"        _Operation m_op;",
			"        _Mapping m_map;",
			"        _Composition m_com;",
			"        _Tp m_defaultValue;",
			"        _Fp m_defaultIncrement;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue && m_com(m_defaultIncrement, m_defaultIncrement) == m_defaultIncrement);",
			"            // if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>) assert(m_map(m_defaultIncrement, m_defaultValue, 1) == m_defaultValue);",
			"            // else assert(m_map(m_defaultIncrement, m_defaultValue) == m_defaultValue);",
			"        }",
			"        _Tp _applied(_Tp val, _Fp inc, int left, int right) const {",
			"            if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>)",
			"                return m_map(inc, val, right - left + 1);",
			"            else",
			"                return m_map(inc, val);",
			"        }",
			"        void _apply(_Tp_FpNode *cur, _Fp inc, int left, int right) {",
			"            cur->val = _applied(cur->val, inc, left, right);",
			"            if (right > left) cur->inc = m_com(inc, cur->inc);",
			"        }",
			"        _Tp_FpNode *_update(_Tp_FpNode *cur) {",
			"            cur->val = m_op(cur->lchild->val, cur->rchild->val);",
			"            return cur;",
			"        }",
			"        void _pushDown(_Tp_FpNode *cur, int left, int right) {",
			"            if (!cur->lchild) {",
			"                cur->lchild = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"                cur->rchild = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"            }",
			"            _apply(cur->lchild, cur->inc, left, (left + right) / 2);",
			"            _apply(cur->rchild, cur->inc, (left + right) / 2 + 1, right);",
			"            cur->inc = m_defaultIncrement;",
			"        }",
			"        void _clear(_Tp_FpNode *p) {",
			"            // if (p->lchild) _clear(p->lchild);",
			"            // if (p->rchild) _clear(p->rchild);",
			"            // delete p;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_Tp_FpNode>::_reserve(__count); }",
			"        LazySegTree(int __n = 0, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_root(nullptr), m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        LazySegTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_root(nullptr), m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        ~LazySegTree() {",
			"            if (m_root) _clear(m_root);",
			"        }",
			"        void resize(int __n) {",
			"            if (m_root) _clear(m_root);",
			"            if (m_length = __n)",
			"                m_root = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"            else",
			"                m_root = nullptr;",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            if (m_root) _clear(m_root);",
			"            m_length = __last - __first;",
			"            auto dfs = [&](auto self, _Iterator first, _Iterator last) -> _Tp_FpNode * {",
			"                if (first + 1 == last)",
			"                    return new _Tp_FpNode(*first, m_defaultIncrement, nullptr, nullptr);",
			"                else",
			"                    return _update(new _Tp_FpNode(m_defaultValue, m_defaultIncrement, self(self, first, first + (last - first + 1) / 2), self(self, first + (last - first + 1) / 2, last)));",
			"            };",
			"            m_root = dfs(dfs, __first, __last);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) -> void {",
			"                if (left == right)",
			"                    cur->val = __val;",
			"                else {",
			"                    _pushDown(cur, left, right);",
			"                    if (__i <= (left + right) / 2)",
			"                        self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void add(int __i, _Fp __inc) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) -> void {",
			"                if (left == right)",
			"                    _apply(cur, __inc, left, right);",
			"                else {",
			"                    _pushDown(cur, left, right);",
			"                    if (__i <= (left + right) / 2)",
			"                        self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void add(int __left, int __right, _Fp __inc) {",
			"            if (__left == __right) {",
			"                add(__left, __inc);",
			"                return;",
			"            }",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) -> void {",
			"                if (__left <= left && __right >= right)",
			"                    _apply(cur, __inc, left, right);",
			"                else {",
			"                    _pushDown(cur, left, right);",
			"                    int mid = (left + right) / 2;",
			"                    if (__left <= mid) self(self, cur->lchild, left, mid);",
			"                    if (__right > mid) self(self, cur->rchild, mid + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp query(int __i) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) {",
			"                if (left == right)",
			"                    return cur->val;",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        return cur->lchild ? _pushDown(cur, left, right), self(self, cur->lchild, left, (left + right) / 2) : _applied(m_defaultValue, cur->inc, __i, __i);",
			"                    else",
			"                        return cur->rchild ? _pushDown(cur, left, right), self(self, cur->rchild, (left + right) / 2 + 1, right) : _applied(m_defaultValue, cur->inc, __i, __i);",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp query(int __left, int __right) {",
			"            if (__left == __right) return query(__left);",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) -> _Tp {",
			"                if (__left <= left && __right >= right)",
			"                    return cur->val;",
			"                else {",
			"                    if (int mid = (left + right) / 2; __left > mid)",
			"                        return cur->rchild ? _pushDown(cur, left, right), self(self, cur->rchild, mid + 1, right) : _applied(m_defaultValue, cur->inc, __left, __right < right ? __right : right);",
			"                    else if (__right <= mid)",
			"                        return cur->lchild ? _pushDown(cur, left, right), self(self, cur->lchild, left, mid) : _applied(m_defaultValue, cur->inc, __left > left ? __left : left, __right);",
			"                    else",
			"                        return cur->lchild ? _pushDown(cur, left, right), m_op(self(self, cur->lchild, left, mid), self(self, cur->rchild, mid + 1, right)) : m_op(_applied(m_defaultValue, cur->inc, __left > left ? __left : left, mid), _applied(m_defaultValue, cur->inc, mid + 1, __right < right ? __right : right));",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp queryAll() const {",
			"            return m_root->val;",
			"        }",
			"        int kth(_Tp __k) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right, int k) {",
			"                if (left == right) return left;",
			"                _pushDown(cur, left, right);",
			"                if (cur->lchild->val > k)",
			"                    return self(self, cur->lchild, left, (left + right) / 2, k);",
			"                else",
			"                    return self(self, cur->rchild, (left + right) / 2 + 1, right, k - cur->lchild->val);",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1, __k);",
			"        }",
			"    };",
			"    template <typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    LazySegTree(int = 0, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Fp = _Fp()) -> LazySegTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"    template <typename _Iterator, typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    LazySegTree(_Iterator, _Iterator, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Fp = _Fp()) -> LazySegTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"}",
		],
		"description": "lazy seg tree",
	},
	"lazy zkw tree":{
		"prefix": "LAZY",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct LazyZkwAdd {",
			"        _Tp operator()(const _Fp &__x, const _Tp &__y, int __size) const { return __x * __size + __y; }",
			"    };",
			"    template <typename _Tp = int64_t, typename _Fp = _Tp, typename _Operation = std::plus<_Tp>, typename _Mapping = LazyZkwAdd<_Tp, _Fp>, typename _Composition = std::plus<_Fp>>",
			"    class LazyZkwTree {",
			"        struct _Tp_FpNode {",
			"            _Tp val;",
			"            _Fp inc;",
			"        };",
			"        std::vector<_Tp_FpNode> m_sub;",
			"        int m_length;",
			"        int m_depth;",
			"        _Operation m_op;",
			"        _Mapping m_map;",
			"        _Composition m_com;",
			"        _Tp m_defaultValue;",
			"        _Fp m_defaultIncrement;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue && m_com(m_defaultIncrement, m_defaultIncrement) == m_defaultIncrement);",
			"            // if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>) assert(m_map(m_defaultIncrement, m_defaultValue, 1) == m_defaultValue);",
			"            // else assert(m_map(m_defaultIncrement, m_defaultValue) == m_defaultValue);",
			"        }",
			"        int _size(int i) {",
			"            return 1 << (std::__countl_zero<uint32_t>(i) + m_depth - 31);",
			"        }",
			"        void _apply(int i, _Fp inc) {",
			"            if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>)",
			"                m_sub[i].val = m_map(inc, m_sub[i].val, _size(i));",
			"            else",
			"                m_sub[i].val = m_map(inc, m_sub[i].val);",
			"            if (i < 1 << m_depth) m_sub[i].inc = m_com(inc, m_sub[i].inc);",
			"        }",
			"        void _update(int i) {",
			"            m_sub[i].val = m_op(m_sub[i * 2].val, m_sub[i * 2 + 1].val);",
			"        }",
			"        void _pushDown(int i) {",
			"            _apply(i * 2, m_sub[i].inc);",
			"            _apply(i * 2 + 1, m_sub[i].inc);",
			"            m_sub[i].inc = m_defaultIncrement;",
			"        }",
			"",
			"    public:",
			"        LazyZkwTree(int __n = 0, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        LazyZkwTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32);",
			"            m_sub.resize(1 << (m_depth + 1));",
			"            std::fill(m_sub.begin() + (1 << m_depth), m_sub.end(), _Tp_FpNode{m_defaultValue, m_defaultIncrement});",
			"            for (int i = 1 << m_depth; --i;) {",
			"                _update(i);",
			"                m_sub[i].inc = m_defaultIncrement;",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32);",
			"            m_sub.resize(1 << (m_depth + 1));",
			"            for (int i = 0; i < m_length; i++) m_sub[(1 << m_depth) + i] = {_Tp(__first[i]), m_defaultIncrement};",
			"            std::fill(m_sub.begin() + (1 << m_depth) + m_length, m_sub.end(), _Tp_FpNode{m_defaultValue, m_defaultIncrement});",
			"            for (int i = 1 << m_depth; --i;) _update(i);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            __i += 1 << m_depth;",
			"            for (int d = m_depth; d; d--) _pushDown(__i >> d);",
			"            m_sub[__i].val = __val;",
			"            while (__i >>= 1) _update(__i);",
			"        }",
			"        void add(int __i, _Fp __inc) {",
			"            __i += 1 << m_depth;",
			"            for (int d = m_depth; d; d--) _pushDown(__i >> d);",
			"            _apply(__i, __inc);",
			"            while (__i /= 2) _update(__i);",
			"        }",
			"        void add(int __left, int __right, _Fp __inc) {",
			"            if (__left == __right) {",
			"                add(__left, __inc);",
			"                return;",
			"            }",
			"            __left += 1 << m_depth;",
			"            __right += 1 << m_depth;",
			"            int j = 31 - std::__countl_zero<uint32_t>(__left ^ __right);",
			"            for (int d = m_depth; d > j; d--) _pushDown(__left >> d);",
			"            for (int d = j; d; d--) _pushDown(__left >> d), _pushDown(__right >> d);",
			"            _apply(__left, __inc);",
			"            _apply(__right, __inc);",
			"            while (__left / 2 < __right / 2) {",
			"                if (__left % 2 == 0) _apply(__left + 1, __inc);",
			"                _update(__left /= 2);",
			"                if (__right % 2) _apply(__right - 1, __inc);",
			"                _update(__right /= 2);",
			"            }",
			"            while (__left /= 2) _update(__left);",
			"        }",
			"        _Tp query(int __i) {",
			"            __i += 1 << m_depth;",
			"            for (int d = m_depth; d; d--) _pushDown(__i >> d);",
			"            return m_sub[__i].val;",
			"        }",
			"        _Tp query(int __left, int __right) {",
			"            if (__left == __right) return query(__left);",
			"            __left += 1 << m_depth;",
			"            __right += 1 << m_depth;",
			"            int j = 31 - std::__countl_zero<uint32_t>(__left ^ __right);",
			"            for (int d = m_depth; d > j; d--) _pushDown(__left >> d);",
			"            for (int d = j; d; d--) _pushDown(__left >> d), _pushDown(__right >> d);",
			"            _Tp res = m_sub[__left].val;",
			"            for (int i = 0; i < j; i++)",
			"                if (!(__left >> i & 1)) res = m_op(res, m_sub[__left >> i ^ 1].val);",
			"            for (int i = j - 1; i >= 0; i--)",
			"                if (__right >> i & 1) res = m_op(res, m_sub[__right >> i ^ 1].val);",
			"            return m_op(res, m_sub[__right].val);",
			"        }",
			"        _Tp queryAll() const {",
			"            return m_sub[1].val;",
			"        }",
			"        int kth(_Tp __k) {",
			"            int i = 1;",
			"            while (i < 1 << m_depth) {",
			"                _pushDown(i);",
			"                if (m_sub[i *= 2].val <= __k) __k -= m_sub[i++].val;",
			"            }",
			"            return i - (1 << m_depth);",
			"        }",
			"    };",
			"    template <typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    LazyZkwTree(int = 0, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Tp = _Tp(), _Fp = _Fp()) -> LazyZkwTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"    template <typename _Iterator, typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    LazyZkwTree(_Iterator, _Iterator, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Tp = _Tp(), _Fp = _Fp()) -> LazyZkwTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"}",
		],
		"description": "lazy zkw tree",
	},
	"limited rmq":{
		"prefix": "RMQ",
		"body": [
			"namespace OY {",
			"    template <typename _Sequence, typename _Compare = std::less<void>>",
			"    struct _LimitedRMQPicker {",
			"        _Sequence &m_seq;",
			"        _Compare m_comp;",
			"        _LimitedRMQPicker(_Sequence &__seq, _Compare __comp = _Compare()) : m_seq(__seq), m_comp(__comp) {}",
			"        uint32_t operator()(uint32_t __x, uint32_t __y) const { return m_comp(m_seq[__x], m_seq[__y]) ? __y : __x; }",
			"    };",
			"    template <typename _Pick>",
			"    class LimitedRMQ {",
			"        _Pick m_pick;",
			"        int m_length;",
			"        int m_blockSize;",
			"        int m_blockCount;",
			"        std::vector<int> m_state;",
			"        std::vector<std::vector<std::vector<int>>> m_internal;",
			"        STTable<int, _Pick> m_table;",
			"",
			"    public:",
			"        LimitedRMQ(_Pick __pick = _Pick()) : m_pick(__pick), m_table(0, __pick) {}",
			"        template <typename _Iterator>",
			"        LimitedRMQ(_Iterator __first, _Iterator __last, _Pick __pick = _Pick()) : m_pick(__pick), m_table(0, __pick) { reset(__first, __last); }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_blockSize = m_length > 1 ? (32 - std::__countl_zero<uint32_t>(m_length - 1)) / 2 : 1;",
			"            m_blockCount = (m_length + m_blockSize - 1) / m_blockSize;",
			"            m_state.clear();",
			"            m_state.reserve(m_blockCount);",
			"            m_internal.assign(1 << m_blockSize, std::vector<std::vector<int>>());",
			"            int cursor = 0;",
			"            while (cursor <= m_length - m_blockSize) {",
			"                int state = 0;",
			"                for (int i = 1; i < m_blockSize; i++) state = state * 2 + (__first[cursor + i] > __first[cursor + i - 1]);",
			"                m_state.push_back(state);",
			"                if (m_internal[state].empty()) {",
			"                    m_internal[state].resize(m_blockSize, std::vector<int>(m_blockSize, 0));",
			"                    for (int i = 0; i < m_blockSize; i++) {",
			"                        int pos = cursor + i;",
			"                        m_internal[state][i][i] = i;",
			"                        for (int j = i + 1; j < m_blockSize; j++) {",
			"                            pos = m_pick(pos, cursor + j);",
			"                            m_internal[state][i][j] = pos - cursor;",
			"                        }",
			"                    }",
			"                }",
			"                cursor += m_blockSize;",
			"            }",
			"            if (cursor < m_length) {",
			"                int state = 0;",
			"                for (int i = 1; i < m_blockSize; i++) state = state * 2 + (cursor + i < m_length && __first[cursor + i] > __first[cursor + i - 1]);",
			"                m_state.push_back(state);",
			"                if (m_internal[state].empty()) {",
			"                    m_internal[state].resize(m_blockSize, std::vector<int>(m_blockSize, 0));",
			"                    for (int i = 0; i < m_blockSize && cursor + i < m_length; i++) {",
			"                        int pos = cursor + i;",
			"                        m_internal[state][i][i] = 0;",
			"                        for (int j = i + 1; j < m_blockSize && cursor + j < m_length; j++) {",
			"                            pos = m_pick(pos, cursor + j);",
			"                            m_internal[state][i][j] = pos - cursor;",
			"                        }",
			"                    }",
			"                }",
			"            }",
			"            if (int fullBlock = m_blockCount - (m_length % m_blockSize != 0); fullBlock > 1) {",
			"                int blockValue[fullBlock];",
			"                for (int i = 0; i < fullBlock; i++) blockValue[i] = i * m_blockSize + m_internal[m_state[i]].front().back();",
			"                m_table.reset(blockValue, blockValue + fullBlock);",
			"            }",
			"        }",
			"        int query(int __left, int __right) const {",
			"            int l1 = __left / m_blockSize, l2 = __left % m_blockSize;",
			"            int r1 = __right / m_blockSize, r2 = __right % m_blockSize;",
			"            if (l1 == r1)",
			"                return __left - l2 + m_internal[m_state[l1]][l2][r2];",
			"            else if (l1 + 1 == r1)",
			"                return m_pick(__left - l2 + m_internal[m_state[l1]][l2][m_blockSize - 1], __right - r2 + m_internal[m_state[r1]][0][r2]);",
			"            else",
			"                return m_pick(m_table.query(l1 + 1, r1 - 1), m_pick(__left - l2 + m_internal[m_state[l1]][l2][m_blockSize - 1], __right - r2 + m_internal[m_state[r1]][0][r2]));",
			"        }",
			"        int queryAll() const { return query(0, m_length - 1); }",
			"    };",
			"}",
		],
		"description": "limited rmq"
	},
	"Lichao tree":{
		"prefix": "LICHAO",
		"body": [
			"namespace OY {",
			"    struct LichaoLine {",
			"        double k;",
			"        double b;",
			"        LichaoLine() = default;",
			"        LichaoLine(double _k, double _b) : k(_k), b(_b) {}",
			"        double calc(int i) const { return k * i + b; }",
			"    };",
			"    template <typename _Line>",
			"    struct LichaoLess {",
			"        bool operator()(const _Line &x, const _Line &y, int i) const { return x.calc(i) < y.calc(i); }",
			"    };",
			"    template <typename _Line = LichaoLine, typename _Compare = LichaoLess<_Line>>",
			"    class LichaoTree {",
			"        std::vector<_Line> m_lines;",
			"        int m_depth;",
			"        int m_length;",
			"        _Line m_defaultLine;",
			"        _Compare m_comp;",
			"",
			"    public:",
			"        LichaoTree(int __n = 0, _Compare __comp = _Compare(), _Line __defaultLine = _Line()) : m_comp(__comp), m_defaultLine(__defaultLine) {",
			"            resize(__n);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32);",
			"            m_lines.assign(1 << (m_depth + 1), m_defaultLine);",
			"        }",
			"        void add(int __left, int __right, _Line __line) {",
			"            if (__left < 0) __left = 0;",
			"            if (__right >= m_length) __right = m_length - 1;",
			"            if (__left > __right) return;",
			"            auto dfs = [&](auto self, int i, int left, int right, _Line line) -> void {",
			"                int mid = (left + right) / 2;",
			"                if (__left <= left && __right >= right) {",
			"                    if (m_comp(m_lines[i], line, mid)) std::swap(m_lines[i], line);",
			"                    if (left < right) {",
			"                        if (m_comp(m_lines[i], line, left))",
			"                            self(self, i * 2, left, mid, line);",
			"                        else if (m_comp(m_lines[i], line, right))",
			"                            self(self, i * 2 + 1, mid + 1, right, line);",
			"                    }",
			"                } else {",
			"                    if (__left <= mid) self(self, i * 2, left, mid, line);",
			"                    if (__right > mid) self(self, i * 2 + 1, mid + 1, right, line);",
			"                }",
			"            };",
			"            dfs(dfs, 1, 0, (1 << m_depth) - 1, __line);",
			"        }",
			"        _Line query(int i) const {",
			"            _Line res = m_defaultLine;",
			"            for (int j = i + (1 << m_depth); j; j >>= 1)",
			"                if (m_comp(res, m_lines[j], i)) res = m_lines[j];",
			"            return res;",
			"        }",
			"    };",
			"    template <typename _Line = LichaoLine, typename _Compare = LichaoLess<_Line>>",
			"    LichaoTree(int = 0, _Compare = _Compare(), _Line = _Line()) -> LichaoTree<_Line, _Compare>;",
			"}",
		],
		"description": "Lichao tree"
	},
	"llrb":{
		"prefix": "LLRB",
		"body": [
			"namespace OY {",
			"    struct LLRBSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct LLRBMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct LLRBMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, typename _Tag>",
			"    struct _LLRBNode;",
			"    template <typename _Tp, typename _Fp>",
			"    struct _LLRBNode<_Tp, _Fp, LLRBSetTag> { _Tp key; };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _LLRBNode<_Tp, _Fp, LLRBMultisetTag> {",
			"        _Tp key;",
			"        int _node_weight;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _LLRBNode<_Tp, _Fp, LLRBMapTag> {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = LLRBMultisetTag>",
			"    class LLRB {",
			"        struct node : _LLRBNode<_Tp, _Fp, _Tag> {",
			"            int subtree_weight;",
			"            bool node_color;",
			"            node *lchild;",
			"            node *rchild;",
			"            constexpr int node_weight() const {",
			"                if constexpr (_Tag::multi_key)",
			"                    return this->_node_weight;",
			"                else",
			"                    return 1;",
			"            }",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static int node_weight(node *p) { return p ? p->node_weight() : 0; }",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->node_weight() + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static bool is_red(const node *p) { return p && p->node_color; }",
			"        static bool neg_node_color(bool b) { return !b; }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            q->node_color = p->node_color;",
			"            p->node_color = true;",
			"            return q;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            q->node_color = p->node_color;",
			"            p->node_color = true;",
			"            return q;",
			"        }",
			"        static node *rrotate_flip(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            p->rchild->node_color = true;",
			"            p->node_color = false;",
			"            q->rchild = update(p);",
			"            q->node_color = true;",
			"            q->lchild->node_color = false;",
			"            return q;",
			"        }",
			"        static node *rlrotate_flip(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            p->node_color = false;",
			"            p->lchild->node_color = true;",
			"            r->subtree_weight = p->subtree_weight;",
			"            r->node_color = true;",
			"            r->lchild = p;",
			"            r->rchild = update(q);",
			"            return r;",
			"        }",
			"        static node *node_color_flip(node *p) {",
			"            p->node_color = neg_node_color(p->node_color);",
			"            p->lchild->node_color = neg_node_color(p->lchild->node_color);",
			"            p->rchild->node_color = neg_node_color(p->rchild->node_color);",
			"            return p;",
			"        }",
			"        static node *move_red_right(node *cur) {",
			"            if (is_red(cur->lchild->lchild))",
			"                return rrotate_flip(cur);",
			"            else",
			"                return node_color_flip(cur);",
			"        }",
			"        static node *move_red_left(node *cur) {",
			"            if (is_red(cur->rchild->lchild))",
			"                return rlrotate_flip(cur);",
			"            else",
			"                return node_color_flip(cur);",
			"        }",
			"        static node *balance(node *cur) {",
			"            if (is_red(cur->rchild) && !is_red(cur->lchild))",
			"                cur = lrotate(cur);",
			"            if (is_red(cur->lchild) && is_red(cur->lchild->lchild))",
			"                cur = rrotate(cur);",
			"            if (is_red(cur->lchild) && is_red(cur->rchild))",
			"                node_color_flip(cur);",
			"            return update(cur);",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (cur->lchild == nullptr) {",
			"                res->key = cur->key;",
			"                if constexpr (_Tag::multi_key)",
			"                    res->_node_weight = cur->_node_weight;",
			"                delete cur;",
			"                return nullptr;",
			"            }",
			"            if (!is_red(cur->lchild) && !is_red(cur->lchild->lchild)) cur = move_red_left(cur);",
			"            cur->lchild = deleteMin(cur->lchild, res);",
			"            return balance(cur);",
			"        }",
			"        template <typename... Args>",
			"        node *_insert(node *cur, _Tp key, Args... args) {",
			"            if (cur == nullptr) return new node{key, args..., 1, true, nullptr, nullptr};",
			"            if (m_comp(key, cur->key))",
			"                cur->lchild = _insert(cur->lchild, key, args...);",
			"            else if (m_comp(cur->key, key))",
			"                cur->rchild = _insert(cur->rchild, key, args...);",
			"            else {",
			"                if constexpr (_Tag::multi_key) {",
			"                    cur->_node_weight++;",
			"                    cur->subtree_weight++;",
			"                }",
			"            }",
			"            return balance(cur);",
			"        }",
			"        node *deleteArbitrary(node *cur, _Tp key) {",
			"            if (m_comp(key, cur->key)) {",
			"                if (!is_red(cur->lchild) && !is_red(cur->lchild->lchild)) cur = move_red_left(cur);",
			"                cur->lchild = deleteArbitrary(cur->lchild, key);",
			"            } else {",
			"                if (is_red(cur->lchild)) cur = rrotate(cur);",
			"                if (!m_comp(cur->key, key) && !cur->rchild) {",
			"                    delete cur;",
			"                    return nullptr;",
			"                }",
			"                if (!is_red(cur->rchild) && !is_red(cur->rchild->lchild)) cur = move_red_right(cur);",
			"                if (m_comp(cur->key, key))",
			"                    cur->rchild = deleteArbitrary(cur->rchild, key);",
			"                else",
			"                    cur->rchild = deleteMin(cur->rchild, cur);",
			"            }",
			"            return balance(cur);",
			"        }",
			"        int decrease(node *cur, _Tp key) {",
			"            if (!cur) return 0;",
			"            int old;",
			"            if (m_comp(key, cur->key))",
			"                old = decrease(cur->lchild, key);",
			"            else if (m_comp(cur->key, key))",
			"                old = decrease(cur->rchild, key);",
			"            else {",
			"                old = cur->node_weight();",
			"                if constexpr (_Tag::multi_key) cur->_node_weight--;",
			"            }",
			"            if (old) cur->subtree_weight--;",
			"            return old;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        LLRB(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        ~LLRB() { clear(); }",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(Args... __args) {",
			"            if constexpr (_Tag::multi_key)",
			"                m_root = _insert(m_root, __args..., 1);",
			"            else",
			"                m_root = _insert(m_root, __args...);",
			"            m_root->node_color = false;",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            if (int old = decrease(m_root, __key); old == 1) {",
			"                if (!is_red(m_root->lchild) && !is_red(m_root->rchild)) m_root->node_color = true;",
			"                if (m_root = deleteArbitrary(m_root, __key)) m_root->node_color = false;",
			"                return true;",
			"            } else",
			"                return old;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord += cur->node_weight();",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + cur->node_weight(); __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            node *x = m_root;",
			"            while (x != nullptr) {",
			"                if (__key == x->key) return x;",
			"                if (m_comp(__key, x->key))",
			"                    x = x->lchild;",
			"                else",
			"                    x = x->rchild;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const { return node_weight(find(__key)); }",
			"    };",
			"    namespace LLRBContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = LLRB<_Tp, bool, _Compare, LLRBSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = LLRB<_Tp, bool, _Compare, LLRBMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = LLRB<_Tp, _Fp, _Compare, LLRBMapTag>;",
			"    }",
			"}",
		],
		"description": "llrb tree"
	},
	"memory pool":{
		"prefix": "POOL",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, int batch = 1 << 15>",
			"    struct MemoryPool {",
			"        static inline std::vector<_Tp *> s_pool;",
			"        static inline std::vector<_Tp *> s_gc;",
			"        static inline _Tp *s_cursor = nullptr;",
			"        static inline _Tp *s_end = nullptr;",
			"        static void _reserve(int __count = batch) {",
			"            s_pool.push_back((_Tp *)malloc(__count * sizeof(_Tp)));",
			"            s_cursor = s_pool.back();",
			"            s_end = s_cursor + __count;",
			"        }",
			"        static void *operator new(size_t) {",
			"            if (s_gc.size()) {",
			"                auto it = s_gc.back();",
			"                s_gc.pop_back();",
			"                return it;",
			"            } else if (s_cursor == s_end)",
			"                _reserve();",
			"            return s_cursor++;",
			"        }",
			"        static void operator delete(void *it) { s_gc.push_back((_Tp *)it); }",
			"        static void recycle(_Tp *it) { s_gc.push_back(it); }",
			"    };",
			"}",
		],
		"description": "memory pool"
	},
	"pairing heap":{
		"prefix": "HEAP",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"    class PairingHeap {",
			"        struct node : MemoryPool<node> {",
			"            _Tp val;",
			"            node *sub;",
			"            node *bro;",
			"            node(_Tp _val) : val(_val), sub(nullptr), bro(nullptr) {}",
			"        };",
			"        _Compare m_comp;",
			"        node *m_root;",
			"        int m_size;",
			"        node *merge(node *a, node *b) {",
			"            if (m_comp(a->val, b->val)) std::swap(a, b);",
			"            if (a->sub) b->bro = a->sub;",
			"            a->sub = b;",
			"            return a;",
			"        }",
			"        node *merges(node *x) {",
			"            if (!x || !x->bro) return x;",
			"            node *a = x->bro;",
			"            node *b = a->bro;",
			"            x->bro = a->bro = nullptr;",
			"            return b ? merge(merge(x, a), merges(b)) : merge(x, a);",
			"        }",
			"",
			"    public:",
			"        PairingHeap(_Compare __comp = _Compare()) : m_root(nullptr), m_size(0), m_comp(__comp) {}",
			"        template <typename _Iterator>",
			"        PairingHeap(_Iterator __first, _Iterator __last, _Compare __comp = _Compare()) : m_root(nullptr), m_size(0), m_comp(__comp) { reset(__first, __last); }",
			"        ~PairingHeap() { clear(); }",
			"        void clear() {",
			"            m_root = nullptr;",
			"            m_size = 0;",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            while (__first < __last) push(*__first++);",
			"        }",
			"        void push(_Tp __val) {",
			"            m_size++;",
			"            m_root = m_root ? merge(m_root, new node(__val)) : new node(__val);",
			"        }",
			"        void pop() {",
			"            m_size--;",
			"            delete m_root;",
			"            m_root = merges(m_root->sub);",
			"        }",
			"        _Tp top() const { return m_root->val; }",
			"        void join(PairingHeap<_Tp, _Compare> &other) {",
			"            if (!other.m_root) return;",
			"            m_root = m_root ? merge(m_root, other.m_root) : other.m_root;",
			"            other.m_root = nullptr;",
			"            m_size += other.m_size;",
			"            other.m_size = 0;",
			"        }",
			"        int size() const { return m_size; }",
			"        bool empty() const { return !m_size; }",
			"    };",
			"    template <typename _Compare = std::less<int>, typename _Tp = std::decay_t<typename decltype(std::function(std::declval<_Compare>()))::first_argument_type>>",
			"    PairingHeap(_Compare = _Compare()) -> PairingHeap<_Tp, _Compare>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Compare = std::less<_Tp>>",
			"    PairingHeap(_Iterator, _Iterator, _Compare = _Compare()) -> PairingHeap<_Tp, _Compare>;",
			"}",
		],
		"description": "pairing heap"
	},
	"pb_ds tree":{
		"prefix": "PBDS",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"namespace OY {",
			"    struct PB_DS_TreeSetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    struct PB_DS_TreeMultisetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = true;",
			"    };",
			"    struct PB_DS_TreeMapTag {",
			"        static constexpr bool is_map = true;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    template <typename _Compare, bool multi_key>",
			"    struct PB_DS_less_equal {",
			"        _Compare __comp;",
			"        PB_DS_less_equal(_Compare __comp = _Compare()) : __comp(__comp) {}",
			"        template <typename _Tp, typename _Fp>",
			"        bool operator()(const _Tp &x, const _Fp &y) const {",
			"            if (multi_key)",
			"                return !__comp(y.key, x.key);",
			"            else",
			"                return __comp(x.key, y.key);",
			"        }",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PB_DS_TreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PB_DS_TreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = int, typename _Compare = std::less<_Tp>, typename _Tag = PB_DS_TreeMultisetTag>",
			"    class PB_DS_Tree {",
			"    public:",
			"        using node = _PB_DS_TreeNode<_Tp, _Fp, _Tag::is_map>;",
			"        using iterator = typename __gnu_pbds::tree<node, __gnu_pbds::null_type, PB_DS_less_equal<_Compare, _Tag::multi_key>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>::iterator;",
			"        __gnu_pbds::tree<node, __gnu_pbds::null_type, PB_DS_less_equal<_Compare, _Tag::multi_key>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> m_tree;",
			"        _Compare m_comp;",
			"        static node makeNode(_Tp __key) {",
			"            if constexpr (_Tag::is_map)",
			"                return {__key, _Fp()};",
			"            else",
			"                return {__key};",
			"        }",
			"",
			"    public:",
			"        PB_DS_Tree(_Compare __comp = _Compare()) : m_comp(__comp), m_tree(__comp) {}",
			"        void clear() { m_tree.clear(); }",
			"        template <typename... Args>",
			"        void insert(Args... __args) {",
			"            m_tree.insert({__args...});",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key); p != end())",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        void erase(_Tp __key) { m_tree.erase(find(__key)); }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            for (auto it = find(__count); __count-- && it != end() && !m_comp(__key, it->key);) it = m_tree.erase(it);",
			"        }",
			"        int rank(_Tp __key) const { return m_tree.order_of_key(makeNode(__key)); }",
			"        iterator kth(int __k) const { return m_tree.find_by_order(__k); }",
			"        iterator find(_Tp __key) const {",
			"            if (auto p = lower_bound(__key); p != end() && !m_comp(__key, p->key))",
			"                return p;",
			"            else",
			"                return m_tree.end();",
			"        }",
			"        iterator lower_bound(_Tp __key) const {",
			"            if constexpr (_Tag::multi_key)",
			"                return m_tree.upper_bound(makeNode(__key));",
			"            else",
			"                return m_tree.lower_bound(makeNode(__key));",
			"        }",
			"        iterator upper_bound(_Tp __key) const {",
			"            if constexpr (_Tag::multi_key)",
			"                return m_tree.lower_bound(makeNode(__key));",
			"            else",
			"                return m_tree.upper_bound(makeNode(__key));",
			"        }",
			"        iterator smaller_bound(_Tp __key) const { return prev(lower_bound(__key)); }",
			"        int size() const { return m_tree.size(); }",
			"        bool empty() const { return !size(); }",
			"        iterator end() const { return m_tree.end(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (it1 == end()) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if constexpr (!_Tag::multi_key)",
			"                return it2 != it1;",
			"            else {",
			"                if (it2 == end())",
			"                    return size() - rank(__key);",
			"                else",
			"                    return rank(it2->key) - rank(__key);",
			"            }",
			"        }",
			"    };",
			"    namespace PB_DS_TreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PB_DS_Tree<_Tp, bool, _Compare, PB_DS_TreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PB_DS_Tree<_Tp, __gnu_pbds::null_type, _Compare, PB_DS_TreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PB_DS_Tree<_Tp, _Fp, _Compare, PB_DS_TreeMapTag>;",
			"    }",
			"}",
		],
		"description": "pb_ds tree(rb tree)"
	},
	"persistent avl":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentAVLSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentAVLMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentAVLMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentAVLNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentAVLNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentAVLMultisetTag>",
			"    class PersistentAVL {",
			"#pragma pack(4)",
			"        struct node : _PersistentAVLNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            int subtree_height;",
			"            uint32_t time_stamp;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static inline uint32_t s_timer = 0;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int subtree_height(node *p) { return p ? p->subtree_height : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if (p->time_stamp == s_timer) {",
			"                p->lchild = l;",
			"                p->rchild = r;",
			"                return p;",
			"            }",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, 1, 1, s_timer, l, r};",
			"            else",
			"                return new node{p->key, 1, 1, s_timer, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            p->subtree_height = 1 + std::max(subtree_height(p->lchild), subtree_height(p->rchild));",
			"            return p;",
			"        }",
			"        static node *balance(node *cur) {",
			"            if (int lh = subtree_height(cur->lchild), rh = subtree_height(cur->rchild); lh > rh + 1) {",
			"                if (node *l = cur->lchild, *lr = l->rchild; subtree_height(lr) > rh)",
			"                    return update(raw_copy(lr, update(raw_copy(l, l->lchild, lr->lchild)), update(raw_copy(cur, lr->rchild, cur->rchild))));",
			"                else",
			"                    return update(raw_copy(l, l->lchild, update(raw_copy(cur, l->rchild, cur->rchild))));",
			"            } else if (rh > lh + 1) {",
			"                if (node *r = cur->rchild, *rl = r->lchild; subtree_height(rl) > lh)",
			"                    return update(raw_copy(rl, update(raw_copy(cur, cur->lchild, rl->lchild)), update(raw_copy(r, rl->rchild, r->rchild))));",
			"                else",
			"                    return update(raw_copy(r, update(raw_copy(cur, cur->lchild, r->lchild)), r->rchild));",
			"            } else",
			"                return update(cur);",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else",
			"                return balance(raw_copy(cur, deleteMin(cur->lchild, res), cur->rchild));",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentAVL(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentAVL() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, 1, s_timer + 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r)) : cur;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            s_timer += 2;",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __value, 1, 1, s_timer + 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key))",
			"                    return balance(raw_copy(cur, self(self, cur->lchild), cur->rchild));",
			"                else if (m_comp(cur->key, __key))",
			"                    return balance(raw_copy(cur, cur->lchild, self(self, cur->rchild)));",
			"                else {",
			"                    node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                    p->value = __value;",
			"                    return p;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            s_timer += 2;",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r)) : cur;",
			"                } else {",
			"                    res = true;",
			"                    if (!cur->rchild)",
			"                        return cur->lchild;",
			"                    node *res, *r = deleteMin(cur->rchild, res);",
			"                    return update(raw_copy(res, cur->lchild, r));",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        void copyVersion(int __version) { m_roots.push_back(_root(__version)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = _root(__version); cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            node *cur = _root(__version);",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentAVLContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentAVL<_Tp, bool, _Compare, PersistentAVLSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentAVL<_Tp, bool, _Compare, PersistentAVLMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentAVL<_Tp, _Fp, _Compare, PersistentAVLMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent avl"
	},
	"persistent B tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentBTreeSetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    struct PersistentBTreeMultisetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = true;",
			"    };",
			"    struct PersistentBTreeMapTag {",
			"        static constexpr bool is_map = true;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    template <typename _Compare>",
			"    struct PersistentBTreeLess {",
			"        _Compare __comp;",
			"        PersistentBTreeLess(_Compare __comp = _Compare()) : __comp(__comp) {}",
			"        template <typename _Tp>",
			"        bool operator()(const _Tp &x, const _Tp &y) const { return __comp(x.key, y.key); }",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentBTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentBTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = int, typename _Compare = std::less<_Tp>, typename _Tag = PersistentBTreeMultisetTag, int _K = 3>",
			"    class PersistentBTree {",
			"        using node = _PersistentBTreeNode<_Tp, _Fp, _Tag::is_map>;",
			"        struct block : MemoryPool<block> {",
			"            node keys[_K * 2 - 1];",
			"            int keyNum;",
			"            node min;",
			"            node max;",
			"            int weight;",
			"            block *child[_K * 2];",
			"            block() { child[0] = nullptr; }",
			"            block(const node &item) {",
			"                keys[0] = min = max = item;",
			"                keyNum = weight = 1;",
			"                child[0] = nullptr;",
			"            }",
			"            void push_front(node key, block *p) {",
			"                std::copy_backward(keys, keys + keyNum, keys + keyNum + 1);",
			"                if (child[0]) std::copy_backward(child, child + keyNum + 1, child + keyNum + 2);",
			"                keys[0] = key;",
			"                child[0] = p;",
			"                keyNum++;",
			"            }",
			"            void push_back(node key, block *p) {",
			"                keys[keyNum] = key;",
			"                child[keyNum + 1] = p;",
			"                keyNum++;",
			"            }",
			"            void pop_front() {",
			"                std::copy(keys + 1, keys + keyNum, keys);",
			"                bool is_leaf = !child[0];",
			"                std::copy(child + 1, child + keyNum + 1, child);",
			"                if (is_leaf) child[0] = nullptr;",
			"                keyNum--;",
			"            }",
			"            void pop_back() { keyNum--; }",
			"            void erase(int pos) {",
			"                if (pos + 1 < keyNum) {",
			"                    std::copy(keys + pos + 1, keys + keyNum, keys + pos);",
			"                    std::copy(child + pos + 2, child + keyNum + 1, child + pos + 1);",
			"                }",
			"                keyNum--;",
			"            }",
			"            void insertKey(int pos, node key) {",
			"                if (pos < keyNum)",
			"                    std::copy_backward(keys + pos, keys + keyNum, keys + keyNum + 1);",
			"                keys[pos] = key;",
			"                keyNum++;",
			"            }",
			"            void eraseKey(int pos) {",
			"                if (pos + 1 < keyNum)",
			"                    std::copy(keys + pos + 1, keys + keyNum, keys + pos);",
			"                keyNum--;",
			"            }",
			"            void updateMinMax() {",
			"                if (!child[0]) {",
			"                    min = keys[0];",
			"                    max = keys[keyNum - 1];",
			"                } else {",
			"                    min = child[0]->min;",
			"                    max = child[keyNum]->max;",
			"                }",
			"            }",
			"        };",
			"        PersistentBTreeLess<_Compare> m_comp;",
			"        std::vector<block *> m_roots;",
			"        static node makeNode(_Tp __key) {",
			"            if constexpr (_Tag::is_map)",
			"                return {__key, _Fp()};",
			"            else",
			"                return {__key};",
			"        }",
			"        static void getLeftLast(block *parent, int pos) {",
			"            block *left = new block{*parent->child[pos - 1]};",
			"            block *old_right = parent->child[pos];",
			"            block *right = new block;",
			"            bool is_leaf = !old_right->child[0];",
			"            right->keys[0] = parent->keys[pos - 1]; //  p1->keys[p1->keyNum];",
			"            right->child[0] = left->child[left->keyNum];",
			"            parent->keys[pos - 1] = left->keys[left->keyNum - 1];",
			"            left->pop_back();",
			"            std::copy(old_right->keys, old_right->keys + old_right->keyNum, right->keys + 1);",
			"            std::copy(old_right->child, old_right->child + old_right->keyNum + 1, right->child + 1);",
			"            int w = is_leaf ? 1 : right->child[0]->weight + 1;",
			"            left->max = is_leaf ? left->keys[left->keyNum - 1] : left->child[left->keyNum]->max;",
			"            left->weight -= w;",
			"            right->min = is_leaf ? right->keys[0] : right->child[0]->min;",
			"            right->max = old_right->max;",
			"            right->weight = old_right->weight + w;",
			"            right->keyNum = old_right->keyNum + 1;",
			"            parent->child[pos - 1] = left;",
			"            parent->child[pos] = right;",
			"        }",
			"        static void getRightFirst(block *parent, int pos) {",
			"            block *left = new block{*parent->child[pos]};",
			"            block *old_right = parent->child[pos + 1];",
			"            block *right = new block;",
			"            bool is_leaf = !old_right->child[0];",
			"            int w = is_leaf ? 1 : old_right->child[0]->weight + 1;",
			"            left->push_back(parent->keys[pos], old_right->child[0]);",
			"            parent->keys[pos] = old_right->keys[0];",
			"            std::copy(old_right->keys + 1, old_right->keys + old_right->keyNum, right->keys);",
			"            std::copy(old_right->child + 1, old_right->child + old_right->keyNum + 1, right->child);",
			"            left->max = is_leaf ? left->keys[left->keyNum - 1] : left->child[left->keyNum]->max;",
			"            left->weight += w;",
			"            right->min = is_leaf ? right->keys[0] : right->child[0]->min;",
			"            right->max = old_right->max;",
			"            right->weight = old_right->weight - w;",
			"            right->keyNum = old_right->keyNum - 1;",
			"            parent->child[pos] = left;",
			"            parent->child[pos + 1] = right;",
			"        }",
			"        static void mergeAt(block *parent, int pos) {",
			"            block *left = parent->child[pos];",
			"            block *right = parent->child[pos + 1];",
			"            block *now = new block;",
			"            std::copy(left->keys, left->keys + _K - 1, now->keys);",
			"            now->keys[_K - 1] = parent->keys[pos];",
			"            std::copy(right->keys, right->keys + _K - 1, now->keys + _K);",
			"            std::copy(left->child, left->child + _K, now->child);",
			"            std::copy(right->child, right->child + _K, now->child + _K);",
			"            now->min = left->min;",
			"            now->max = right->max;",
			"            now->keyNum = _K * 2 - 1;",
			"            now->weight = left->weight + right->weight + 1;",
			"            parent->child[pos] = now;",
			"            parent->erase(pos);",
			"        }",
			"        static void splitAt(block *old, block *parent, int pos) {",
			"            block *left = new block;",
			"            block *right = new block;",
			"            left->keyNum = right->keyNum = _K - 1;",
			"            std::copy(old->keys, old->keys + _K - 1, left->keys);",
			"            std::copy(old->keys + _K, old->keys + (_K * 2 - 1), right->keys);",
			"            if (old->child[0]) {",
			"                int w = _K - 1;",
			"                std::copy(old->child, old->child + _K, left->child);",
			"                for (int i = 0; i < _K; i++) {",
			"                    right->child[i] = old->child[_K + i];",
			"                    w += right->child[i]->weight;",
			"                }",
			"                right->min = right->child[0]->min;",
			"                right->max = old->max;",
			"                right->weight = w;",
			"                left->min = old->min;",
			"                left->max = old->child[_K - 1]->max;",
			"                left->weight = old->weight - (w + 1);",
			"            } else {",
			"                right->min = right->keys[0];",
			"                right->max = old->max;",
			"                right->weight = _K - 1;",
			"                left->min = old->min;",
			"                left->max = left->keys[_K - 2];",
			"                left->weight = _K - 1;",
			"            }",
			"            parent->keys[pos] = old->keys[_K - 1];",
			"            parent->child[pos] = left;",
			"            parent->child[pos + 1] = right;",
			"            parent->keyNum++;",
			"        }",
			"        block *_insert(block *cur, const node &item, bool &res) {",
			"            int pos = std::upper_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys;",
			"            if constexpr (!_Tag::multi_key)",
			"                if (pos && !m_comp(cur->keys[pos - 1], item)) return cur;",
			"            if (!cur->child[0]) {",
			"                res = true;",
			"                cur->insertKey(pos, item);",
			"            } else {",
			"                if (cur->child[pos]->keyNum == _K * 2 - 1) {",
			"                    if (pos < cur->keyNum) {",
			"                        std::copy_backward(cur->keys + pos, cur->keys + cur->keyNum, cur->keys + cur->keyNum + 1);",
			"                        std::copy_backward(cur->child + pos + 1, cur->child + cur->keyNum + 1, cur->child + cur->keyNum + 2);",
			"                    }",
			"                    splitAt(cur->child[pos], cur, pos);",
			"                    if (m_comp(cur->keys[pos], item)) pos++;",
			"                    cur->child[pos] = _insert(cur->child[pos], item, res);",
			"                } else",
			"                    cur->child[pos] = _insert(new block{*cur->child[pos]}, item, res);",
			"            }",
			"            if (res) {",
			"                cur->weight++;",
			"                cur->updateMinMax();",
			"            }",
			"            return cur;",
			"        }",
			"        block *_update(block *cur, const node &item, bool &res) {",
			"            int pos = std::upper_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys;",
			"            if constexpr (!_Tag::multi_key)",
			"                if (pos && !m_comp(cur->keys[pos - 1], item)) {",
			"                    node *p = new block(*cur);",
			"                    p->keys[pos - 1] = item;",
			"                    return p;",
			"                }",
			"            if (!cur->child[0]) {",
			"                res = true;",
			"                cur->insertKey(pos, item);",
			"            } else {",
			"                if (cur->child[pos]->keyNum == _K * 2 - 1) {",
			"                    if (pos < cur->keyNum) {",
			"                        std::copy_backward(cur->keys + pos, cur->keys + cur->keyNum, cur->keys + cur->keyNum + 1);",
			"                        std::copy_backward(cur->child + pos + 1, cur->child + cur->keyNum + 1, cur->child + cur->keyNum + 2);",
			"                    }",
			"                    splitAt(cur->child[pos], cur, pos);",
			"                    if (m_comp(cur->keys[pos], item)) pos++;",
			"                    cur->child[pos] = _insert(cur->child[pos], item, res);",
			"                } else",
			"                    cur->child[pos] = _insert(new block{*cur->child[pos]}, item, res);",
			"            }",
			"            if (res) cur->weight++;",
			"            cur->updateMinMax();",
			"            return cur;",
			"        }",
			"        block *_erase(block *cur, const node &item, bool &res) {",
			"            if (int pos = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys; pos == cur->keyNum || m_comp(item, cur->keys[pos])) {",
			"                if (!cur->child[0]) return cur;",
			"                if (cur->child[pos]->keyNum == _K - 1) {",
			"                    if (pos && cur->child[pos - 1]->keyNum >= _K)",
			"                        getLeftLast(cur, pos);",
			"                    else if (pos < cur->keyNum && cur->child[pos + 1]->keyNum >= _K)",
			"                        getRightFirst(cur, pos);",
			"                    else {",
			"                        if (pos) pos--;",
			"                        mergeAt(cur, pos);",
			"                        if (!cur->keyNum) return _erase(cur->child[0], item, res);",
			"                    }",
			"                } else",
			"                    cur->child[pos] = new block{*cur->child[pos]};",
			"                cur->child[pos] = _erase(cur->child[pos], item, res);",
			"                if (res) {",
			"                    cur->weight--;",
			"                    cur->updateMinMax();",
			"                }",
			"                return cur;",
			"            } else {",
			"                res = true;",
			"                if (!--cur->weight) {",
			"                    delete cur;",
			"                    return nullptr;",
			"                }",
			"                if (!cur->child[0]) {",
			"                    cur->eraseKey(pos);",
			"                    cur->updateMinMax();",
			"                } else if (cur->child[pos]->keyNum >= _K) {",
			"                    node leftMax = cur->child[pos]->max;",
			"                    cur->keys[pos] = leftMax;",
			"                    cur->child[pos] = _erase(new block{*cur->child[pos]}, leftMax, res);",
			"                } else if (pos < cur->keyNum && cur->child[pos + 1]->keyNum >= _K) {",
			"                    node rightMin = cur->child[pos + 1]->min;",
			"                    cur->keys[pos] = rightMin;",
			"                    cur->child[pos + 1] = _erase(new block{*cur->child[pos + 1]}, rightMin, res);",
			"                } else {",
			"                    mergeAt(cur, pos);",
			"                    if (!cur->keyNum) return _erase(cur->child[0], item, res);",
			"                    cur->child[pos] = _erase(new block{*cur->child[pos]}, item, res);",
			"                }",
			"                return cur;",
			"            }",
			"        }",
			"        block *&_root(int version) { return ~version ? m_roots[version] : m_roots.back(); }",
			"        block *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { block::_reserve(__count); }",
			"        PersistentBTree(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentBTree() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, Args... __args) {",
			"            block *root = _root(__prevVersion);",
			"            const node &item = node{__args...};",
			"            bool res = false;",
			"            if (!root)",
			"                root = new block(item);",
			"            else {",
			"                if (root->keyNum == _K * 2 - 1) {",
			"                    block *p = new block;",
			"                    p->keyNum = 0;",
			"                    p->child[0] = root;",
			"                    p->weight = root->weight;",
			"                    splitAt(root, p, 0);",
			"                    root = _insert(p, item, res);",
			"                } else",
			"                    root = _insert(new block{*root}, item, res);",
			"            }",
			"            m_roots.push_back(root);",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            block *root = _root(__prevVersion);",
			"            const node &item = node{__key, __value};",
			"            bool res = false;",
			"            if (!root)",
			"                root = new block(item);",
			"            else {",
			"                if (root->keyNum == _K * 2 - 1) {",
			"                    block *p = new block;",
			"                    p->keyNum = 0;",
			"                    p->child[0] = root;",
			"                    p->weight = root->weight;",
			"                    splitAt(root, p, 0);",
			"                    root = _update(p, item, res);",
			"                } else",
			"                    root = _update(new block{*root}, item, res);",
			"            }",
			"            m_roots.push_back(root);",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            m_roots.push_back(_root(__prevVersion) ? _erase(new block{*_root(__prevVersion)}, makeNode(__key), res) : nullptr);",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            node item = makeNode(__key);",
			"            int ord = 0;",
			"            while (cur) {",
			"                int pos = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys;",
			"                ord += pos;",
			"                if (!cur->child[0]) break;",
			"                for (int i = 0; i < pos; i++) ord += cur->child[i]->weight;",
			"                cur = cur->child[pos];",
			"            }",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int k) const {",
			"            block *cur = _root(__version);",
			"            for (int i; cur->child[0]; cur = cur->child[i])",
			"                for (i = 0; k >= cur->child[i]->weight; i++) {",
			"                    k -= cur->child[i]->weight;",
			"                    if (!k--) return cur->keys + i;",
			"                }",
			"            return cur->keys + k;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            node item = makeNode(__key);",
			"            for (int i;; cur = cur->child[i]) {",
			"                if (i = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys; i < cur->keyNum && !m_comp(item, cur->keys[i])) return cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            node item = makeNode(__key);",
			"            for (int i;; cur = cur->child[i]) {",
			"                if (i = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys) res = cur->keys + i - 1;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            node item = makeNode(__key);",
			"            for (int i; cur; cur = i ? cur->child[i - 1] : nullptr) {",
			"                if (i = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys; i < cur->keyNum) res = cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            node item = makeNode(__key);",
			"            for (int i; cur; cur = cur->child[i]) {",
			"                if (i = std::upper_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys; i < cur->keyNum) res = cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        int size(int __version) const { return _root(__version) ? _root(__version)->weight : 0; }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if constexpr (!_Tag::multi_key)",
			"                return it2 != it1;",
			"            else {",
			"                if (!it2)",
			"                    return size(__version) - rank(__version, __key);",
			"                else",
			"                    return rank(__version, it2->key) - rank(__version, __key);",
			"            }",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentBTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>, int _K = 6>",
			"        using Set = PersistentBTree<_Tp, bool, _Compare, PersistentBTreeSetTag, _K>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>, int _K = 6>",
			"        using Multiset = PersistentBTree<_Tp, bool, _Compare, PersistentBTreeMultisetTag, _K>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>, int _K = 6>",
			"        using Map = PersistentBTree<_Tp, _Fp, _Compare, PersistentBTreeMapTag, _K>;",
			"    }",
			"}",
		],
		"description": "persistent B tree"
	},
	"persistent lazy tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct PersistentLazySegAdd {",
			"        _Tp operator()(const _Fp &__x, const _Tp &__y, int __size) const { return __x * __size + __y; }",
			"    };",
			"    template <typename _Tp = int64_t, typename _Fp = _Tp, typename _Operation = std::plus<_Tp>, typename _Mapping = PersistentLazySegAdd<_Tp, _Fp>, typename _Composition = std::plus<_Fp>>",
			"    class PersistentLazySegTree {",
			"        struct _Tp_FpNode : MemoryPool<_Tp_FpNode> {",
			"            _Tp val;",
			"            _Fp inc;",
			"            _Tp_FpNode *lchild;",
			"            _Tp_FpNode *rchild;",
			"            _Tp_FpNode(_Tp _val, _Fp _inc, _Tp_FpNode *_lchild, _Tp_FpNode *_rchild) : val(_val), inc(_inc), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        std::vector<_Tp_FpNode *> m_roots;",
			"        int m_length;",
			"        _Operation m_op;",
			"        _Mapping m_map;",
			"        _Composition m_com;",
			"        _Tp m_defaultValue;",
			"        _Fp m_defaultIncrement;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue && m_com(m_defaultIncrement, m_defaultIncrement) == m_defaultIncrement);",
			"            // if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>) assert(m_map(m_defaultIncrement, m_defaultValue, 1) == m_defaultValue);",
			"            // else assert(m_map(m_defaultIncrement, m_defaultValue) == m_defaultValue);",
			"        }",
			"        _Tp_FpNode *lchild(_Tp_FpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _Tp_FpNode *rchild(_Tp_FpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        _Tp _map(_Fp inc, _Tp val, int length) const {",
			"            if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>)",
			"                return m_map(inc, val, length);",
			"            else",
			"                return m_map(inc, val);",
			"        }",
			"        _Tp_FpNode *_update(_Tp_FpNode *cur, int length) {",
			"            cur->val = _map(cur->inc, m_op(cur->lchild ? cur->lchild->val : m_defaultValue, cur->rchild ? cur->rchild->val : m_defaultValue), length);",
			"            return cur;",
			"        }",
			"        _Tp_FpNode *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"        void _clear() { m_roots.clear(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_Tp_FpNode>::_reserve(__count); }",
			"        PersistentLazySegTree(int __n = 0, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        PersistentLazySegTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        ~PersistentLazySegTree() { _clear(); }",
			"        void resize(int __n) {",
			"            _clear();",
			"            if (m_length = __n) m_roots.push_back(new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr));",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            _clear();",
			"            m_length = __last - __first;",
			"            auto dfs = [&](auto self, _Iterator first, _Iterator last) -> _Tp_FpNode * {",
			"                if (first + 1 == last)",
			"                    return new _Tp_FpNode(*first, m_defaultIncrement, nullptr, nullptr);",
			"                else",
			"                    return _update(new _Tp_FpNode(*first, m_defaultIncrement, self(self, first, first + (last - first + 1) / 2), self(self, first + (last - first + 1) / 2, last)), last - first);",
			"            };",
			"            m_roots.push_back(dfs(dfs, __first, __last));",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        void add(int __prevVersion, int __i, _Fp __inc) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *prev, int left, int right) -> _Tp_FpNode * {",
			"                _Tp_FpNode *cur = prev ? new _Tp_FpNode(*prev) : new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"                if (left == right) {",
			"                    cur->val = _map(__inc, cur->val, 1);",
			"                    cur->inc = m_com(__inc, cur->inc);",
			"                } else {",
			"                    if (__i <= (left + right) / 2)",
			"                        cur->lchild = self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur, right - left + 1);",
			"                }",
			"                return cur;",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion), 0, m_length - 1));",
			"        }",
			"        void add(int __prevVersion, int __left, int __right, _Fp __inc) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *prev, int left, int right) -> _Tp_FpNode * {",
			"                _Tp_FpNode *cur = prev ? new _Tp_FpNode(*prev) : new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"                if (left >= __left && right <= __right) {",
			"                    cur->val = _map(__inc, cur->val, right - left + 1);",
			"                    cur->inc = m_com(__inc, cur->inc);",
			"                } else {",
			"                    if (__left <= (left + right) / 2)",
			"                        cur->lchild = self(self, cur->lchild, left, (left + right) / 2);",
			"                    if (__right > (left + right) / 2)",
			"                        cur->rchild = self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur, right - left + 1);",
			"                }",
			"                return cur;",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion), 0, m_length - 1));",
			"        }",
			"        _Tp query(int __version, int __i) const {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right, _Fp inc) {",
			"                if (left == right)",
			"                    return _map(inc, cur->val, 1);",
			"                else {",
			"                    inc = m_com(cur->inc, inc);",
			"                    if (__i <= (left + right) / 2)",
			"                        return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2, inc) : _map(inc, m_defaultValue, 1);",
			"                    else",
			"                        return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right, inc) : _map(inc, m_defaultValue, 1);",
			"                }",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1, m_defaultIncrement);",
			"        }",
			"        _Tp query(int __version, int __left, int __right) const {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right, _Fp inc) {",
			"                if (left >= __left && right <= __right)",
			"                    return _map(inc, cur->val, right - left + 1);",
			"                else {",
			"                    inc = m_com(cur->inc, inc);",
			"                    if (__right <= (left + right) / 2)",
			"                        return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2, inc) : _map(inc, m_defaultValue, __right - left + 1);",
			"                    else if (__left > (left + right) / 2)",
			"                        return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right, inc) : _map(inc, m_defaultValue, right - __left + 1);",
			"                    else",
			"                        return _map(inc, m_op(cur->lchild ? self(self, cur->lchild, left, (left + right) / 2, m_defaultIncrement) : m_defaultValue, cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right, m_defaultIncrement) : m_defaultValue), std::min(right, __right) - std::max(left, __left) + 1);",
			"                }",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1, m_defaultIncrement);",
			"        }",
			"        _Tp queryAll(int __version) const {",
			"            return _root(__version)->val;",
			"        }",
			"        int kth(int __version, _Tp __k) const {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right, int k, _Fp inc) {",
			"                if (left == right) return left;",
			"                inc += cur->inc;",
			"                if (cur->lchild) {",
			"                    if (_Tp lval = cur->lchild->val + inc * ((left + right) / 2 - left + 1); lval > k)",
			"                        return self(self, cur->lchild, left, (left + right) / 2, k, inc);",
			"                    else",
			"                        return self(self, cur->rchild, (left + right) / 2 + 1, right, k - lval, inc);",
			"                } else",
			"                    return self(self, cur->rchild, (left + right) / 2 + 1, right, k, inc);",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1, __k, 0);",
			"        }",
			"        _Tp periodQuery(int __leftVersion, int __rightVersion, int __i) const {",
			"            if (__leftVersion == 0) return query(__rightVersion, __i);",
			"            auto dfs = [&](auto self, _Tp_FpNode *root1, _Tp_FpNode *root2, int left, int right, _Fp inc) {",
			"                if (root1 == root2) return 0;",
			"                if (left == right)",
			"                    return inc + (root1 ? root2->val - root1->val : root2->val);",
			"                else {",
			"                    inc += root2->inc - (root1 ? root1->inc : 0);",
			"                    if (__i <= (left + right) / 2)",
			"                        return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2, inc);",
			"                    else",
			"                        return self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, inc);",
			"                }",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1, 0);",
			"        }",
			"        _Tp periodQuery(int __leftVersion, int __rightVersion, int __left, int __right) const {",
			"            if (__leftVersion == 0) return query(__rightVersion, __left, __right);",
			"            auto dfs = [&](auto self, _Tp_FpNode *root1, _Tp_FpNode *root2, int left, int right, _Fp inc) -> _Tp {",
			"                if (root1 == root2) return 0;",
			"                if (left >= __left && right <= __right)",
			"                    return inc + (root1 ? root2->val - root1->val : root2->val, right - left + 1);",
			"                else {",
			"                    inc += root2->inc + (root1 ? root1->inc : 0);",
			"                    if (__right <= (left + right) / 2)",
			"                        return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2, inc);",
			"                    else if (__left > (left + right) / 2)",
			"                        return self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, inc);",
			"                    else",
			"                        return inc * (std::min(right, __right) - std::max(left, __left) + 1) + self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2, 0) + self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, 0);",
			"                }",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1, 0);",
			"        }",
			"        int periodKth(int __leftVersion, int __rightVersion, _Tp __k) const {",
			"            if (__leftVersion == 0) return kth(__rightVersion, __k);",
			"            auto dfs = [&](auto self, _Tp_FpNode *root1, _Tp_FpNode *root2, int left, int right, int k, _Fp inc) {",
			"                if (left == right) return left;",
			"                inc += (root2 ? root2->inc : 0) - (root1 ? root1->inc : 0);",
			"                if (!root1 || !root1->lchild) {",
			"                    if (!root2->lchild)",
			"                        return self(self, root1 && root1->rchild ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, k, inc);",
			"                    else if (_Tp lval = root2->lchild->val + inc * ((left + right) / 2 - left + 1); lval > k)",
			"                        return self(self, nullptr, root2->lchild, left, (left + right) / 2, k, inc);",
			"                    else",
			"                        return self(self, root1 && root1->rchild ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, k - lval, inc);",
			"                } else if (_Tp lval = root2->lchild->val - root1->lchild->val + inc * ((left + right) / 2 - left + 1); lval > k)",
			"                    return self(self, root1->lchild, root2->lchild, left, (left + right) / 2, k, inc);",
			"                else",
			"                    return self(self, root1->rchild, root2->rchild, (left + right) / 2 + 1, right, k - lval, inc);",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1, __k, 0);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    template <typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    PersistentLazySegTree(int = 0, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Fp = _Fp()) -> PersistentLazySegTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"    template <typename _Iterator, typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    PersistentLazySegTree(_Iterator, _Iterator, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Fp = _Fp()) -> PersistentLazySegTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"}",
			"",
		],
		"description": "persistent lazy tree"
	},
	"persistent fhq treap":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentFHQTreapSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentFHQTreapMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentFHQTreapMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentFHQTreapNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentFHQTreapNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentFHQTreapMultisetTag>",
			"    class PersistentFHQTreap {",
			"#pragma pack(4)",
			"        struct node : _PersistentFHQTreapNode<_Tp, _Fp, _Tag::is_map> {",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            uint32_t time_stamp;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static inline std::mt19937 s_rand;",
			"        static inline uint32_t s_timer = 0;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if (p->time_stamp == s_timer) {",
			"                p->lchild = l;",
			"                p->rchild = r;",
			"                return p;",
			"            }",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, p->priority, p->subtree_weight, s_timer, l, r};",
			"            else",
			"                return new node{p->key, p->priority, p->subtree_weight, s_timer, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        void split_less(node *p, const _Tp &key, node *&l, node *&r) {",
			"            if (!p)",
			"                l = r = nullptr;",
			"            else if (m_comp(p->key, key)) {",
			"                split_less(p->rchild, key, l, r);",
			"                l = update(raw_copy(p, p->lchild, l));",
			"            } else {",
			"                split_less(p->lchild, key, l, r);",
			"                r = update(raw_copy(p, r, p->rchild));",
			"            }",
			"        }",
			"        void split_less_equal(node *p, const _Tp &key, node *&l, node *&r) {",
			"            if (!p)",
			"                l = r = nullptr;",
			"            else if (m_comp(key, p->key)) {",
			"                split_less_equal(p->lchild, key, l, r);",
			"                r = update(raw_copy(p, r, p->rchild));",
			"            } else {",
			"                split_less_equal(p->rchild, key, l, r);",
			"                l = update(raw_copy(p, p->lchild, l));",
			"            }",
			"        }",
			"        void split_by_key(node *p, const _Tp &key, node *&l, node *&mid, node *&r) {",
			"            if (!p)",
			"                l = mid = r = nullptr;",
			"            else if (m_comp(p->key, key)) {",
			"                split_by_key(p->rchild, key, l, mid, r);",
			"                l = update(raw_copy(p, p->lchild, l));",
			"            } else if (m_comp(key, p->key)) {",
			"                split_by_key(p->lchild, key, l, mid, r);",
			"                r = update(raw_copy(p, r, p->rchild));",
			"            } else {",
			"                node *l_mid, *r_mid;",
			"                split_less(p->lchild, key, l, l_mid);",
			"                split_less_equal(p->rchild, key, r_mid, r);",
			"                mid = update(raw_copy(p, l_mid, r_mid));",
			"            }",
			"        }",
			"        void split_by_rank(node *p, int k, node *&l, node *&r) {",
			"            if (!k) {",
			"                l = nullptr;",
			"                r = p;",
			"            } else if (subtree_weight(p->lchild) > k) {",
			"                split_by_rank(p->lchild, k, l, r);",
			"                r = update(raw_copy(p, r, p->rchild));",
			"            } else if (k -= subtree_weight(p->lchild); !k) {",
			"                l = p->lchild;",
			"                r = update(raw_copy(p, nullptr, p->rchild));",
			"            } else {",
			"                split_by_rank(p->rchild, k - 1, l, r);",
			"                l = update(raw_copy(p, p->lchild, l));",
			"            }",
			"        }",
			"        static node *merge(node *l, node *r) {",
			"            if (!l) return r;",
			"            if (!r) return l;",
			"            if (l->priority > r->priority)",
			"                return update(raw_copy(l, l->lchild, merge(l->rchild, r)));",
			"            else",
			"                return update(raw_copy(r, merge(l, r->lchild), r->rchild));",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        void roll() { s_timer++; }",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentFHQTreap(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentFHQTreap() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            node *l, *r;",
			"            split_less_equal(_root(__prevVersion), __key, l, r);",
			"            if constexpr (!_Tag::multi_key) {",
			"                node *p = l;",
			"                if (p)",
			"                    while (p->rchild) p = p->rchild;",
			"                if (p && !m_comp(p->key, __key)) {",
			"                    m_roots.push_back(_root(__prevVersion));",
			"                    s_timer++;",
			"                    return;",
			"                }",
			"            }",
			"            m_roots.push_back(merge(merge(l, new node{__key, __args..., s_rand(), 1, s_timer + 1, nullptr, nullptr}), r));",
			"            s_timer += 2;",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            node *l, *mid, *r;",
			"            split_by_key(_root(__prevVersion), __key, l, mid, r);",
			"            m_roots.push_back(merge(merge(l, new node{__key, __value, s_rand(), 1, s_timer + 1, nullptr, nullptr}), r));",
			"            s_timer += 2;",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(_root(__prevVersion), __key, l, mid, r);",
			"            if (!mid)",
			"                m_roots.push_back(merge(l, r));",
			"            else",
			"                m_roots.push_back(mid->subtree_weight > 1 ? merge(merge(l, mid->lchild), merge(mid->rchild, r)) : merge(l, r));",
			"            s_timer++;",
			"            return mid;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) {",
			"            node *l, *r;",
			"            split_less(_root(__version), __key, l, r);",
			"            s_timer++;",
			"            return subtree_weight(l);",
			"        }",
			"        const node *kth(int __version, int __k) {",
			"            node *l, *r;",
			"            split_by_rank(_root(__version), __k, l, r);",
			"            node *res = r;",
			"            while (res->lchild) res = res->lchild;",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        const node *find(int __version, _Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(_root(__version), __key, l, mid, r);",
			"            node *res = mid;",
			"            m_roots.push_back(merge(merge(l, mid), r));",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) {",
			"            node *l, *r;",
			"            split_less(_root(__version), __key, l, r);",
			"            node *res = r;",
			"            if (r)",
			"                while (res->lchild) res = res->lchild;",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) {",
			"            node *l, *r;",
			"            split_less_equal(_root(__version), __key, l, r);",
			"            node *res = r;",
			"            if (r)",
			"                while (res->lchild) res = res->lchild;",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) {",
			"            node *l, *r;",
			"            split_less(_root(__version), __key, l, r);",
			"            node *res = l;",
			"            if (l)",
			"                while (res->rchild) res = res->rchild;",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(_root(__version), __key, l, mid, r);",
			"            s_timer++;",
			"            return subtree_weight(mid);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentFHQTreapContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentFHQTreap<_Tp, bool, _Compare, PersistentFHQTreapSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentFHQTreap<_Tp, bool, _Compare, PersistentFHQTreapMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentFHQTreap<_Tp, _Fp, _Compare, PersistentFHQTreapMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent fhq treap"
	},
	"persistent scape goat":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentScapeGoatTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentScapeGoatTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentScapeGoatTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentScapeGoatTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentScapeGoatTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentScapeGoatTreeMultisetTag>",
			"    class PersistentScapeGoatTree {",
			"#pragma pack(4)",
			"        struct node : _PersistentScapeGoatTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            bool node_weight;",
			"            int subtree_weight;",
			"            int subtree_capacity;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>().operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static constexpr int ratio = 4, bias = 4;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int subtree_capacity(node *p) { return p ? p->subtree_capacity : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, p->node_weight, p->subtree_weight, p->subtree_capacity, l, r};",
			"            else",
			"                return new node{p->key, p->node_weight, p->subtree_weight, p->subtree_capacity, l, r};",
			"        }",
			"        static node *raw_copy_true(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, true, p->subtree_weight + 1, p->subtree_capacity, l, r};",
			"            else",
			"                return new node{p->key, true, p->subtree_weight + 1, p->subtree_capacity, l, r};",
			"        }",
			"        static node *raw_copy_false(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, false, p->subtree_weight - 1, p->subtree_capacity, l, r};",
			"            else",
			"                return new node{p->key, false, p->subtree_weight - 1, p->subtree_capacity, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->node_weight + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            p->subtree_capacity = 1 + subtree_capacity(p->lchild) + subtree_capacity(p->rchild);",
			"            return p;",
			"        }",
			"        static void traverse(node *p, node **&s_cursor) {",
			"            if (p->lchild) traverse(p->lchild, s_cursor);",
			"            if (p->node_weight) *s_cursor++ = p;",
			"            if (p->rchild) traverse(p->rchild, s_cursor);",
			"        }",
			"        static node *make_tree(node **first, node **last) {",
			"            if (first == last) return nullptr;",
			"            node **mid = first + (last - first) / 2;",
			"            return update(raw_copy(*mid, make_tree(first, mid), make_tree(mid + 1, last)));",
			"        }",
			"        static node *balance(node *cur) {",
			"            update(cur);",
			"            if (subtree_weight(cur->lchild) <= subtree_weight(cur->rchild) * ratio + bias && subtree_weight(cur->rchild) <= subtree_weight(cur->lchild) * ratio + bias && cur->subtree_capacity * 2 <= cur->subtree_weight * 3) return cur;",
			"            static std::vector<node *> s_buffer;",
			"            static node **s_cursor;",
			"            s_buffer.resize(cur->subtree_weight);",
			"            s_cursor = s_buffer.data();",
			"            traverse(cur, s_cursor);",
			"            return make_tree(s_buffer.data(), s_cursor);",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentScapeGoatTree(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentScapeGoatTree() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., true, 1, 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur->node_weight ? cur : raw_copy_true(cur, cur->lchild, cur->rchild);",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r)) : cur;",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __value, true, 1, 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key))",
			"                    return balance(raw_copy(cur, self(self, cur->lchild), cur->rchild));",
			"                else if (m_comp(cur->key, __key))",
			"                    return balance(raw_copy(cur, cur->lchild, self(self, cur->rchild)));",
			"                else",
			"                    return cur->node_weight ? cur : raw_copy_true(cur, cur->lchild, cur->rchild);",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r)) : cur;",
			"                } else if (cur->node_weight) {",
			"                    res = true;",
			"                    return raw_copy_false(cur, cur->lchild, cur->rchild);",
			"                } else {",
			"                    node *l = self(self, cur->lchild);",
			"                    if (res) return balance(raw_copy(cur, l, cur->rchild));",
			"                    l = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, l)) : cur;",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> int {",
			"                if (!cur)",
			"                    return 0;",
			"                else if (m_comp(cur->key, __key))",
			"                    return subtree_weight(cur->lchild) + cur->node_weight + self(self, cur->rchild);",
			"                else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            auto dfs = [&](auto self, node *cur, int k) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (int l_count = subtree_weight(cur->lchild); k < l_count)",
			"                    return self(self, cur->lchild, k);",
			"                else if (k -= l_count + cur->node_weight; k < 0)",
			"                    return cur;",
			"                else",
			"                    return self(self, cur->rchild, k);",
			"            };",
			"            return dfs(dfs, _root(__version), __k);",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key))",
			"                    return self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    return self(self, cur->rchild);",
			"                else if (cur->node_weight)",
			"                    return cur;",
			"                else if (node *res = self(self, cur->rchild))",
			"                    return res;",
			"                else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key)) {",
			"                    node *res = self(self, cur->lchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->rchild);",
			"                    return res;",
			"                } else if (!m_comp(cur->key, __key) && cur->node_weight)",
			"                    return cur;",
			"                else",
			"                    return self(self, cur->rchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key)) {",
			"                    node *res = self(self, cur->lchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->rchild);",
			"                    return res;",
			"                } else",
			"                    return self(self, cur->rchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(cur->key, __key)) {",
			"                    node *res = self(self, cur->rchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->lchild);",
			"                    return res;",
			"                } else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentScapeGoatContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentScapeGoatTree<_Tp, bool, _Compare, PersistentScapeGoatTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentScapeGoatTree<_Tp, bool, _Compare, PersistentScapeGoatTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentScapeGoatTree<_Tp, _Fp, _Compare, PersistentScapeGoatTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent scape goat tree"
	},
	"persistent size balanced tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentSizeBalancedTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentSizeBalancedTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentSizeBalancedTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentSizeBalancedTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentSizeBalancedTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentSizeBalancedTreeMultisetTag>",
			"    class PersistentSizeBalancedTree {",
			"#pragma pack(4)",
			"        struct node : _PersistentSizeBalancedTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int lchild_weight(node *p) { return p && p->lchild ? p->lchild->subtree_weight : 0; }",
			"        static int rchild_weight(node *p) { return p && p->rchild ? p->rchild->subtree_weight : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, 1, l, r};",
			"            else",
			"                return new node{p->key, 1, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *set_lchild(node *p, node *l) {",
			"            p->lchild = l;",
			"            return p;",
			"        }",
			"        static node *set_rchild(node *p, node *r) {",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *set_lrchild(node *p, node *l, node *r) {",
			"            p->lchild = l;",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p, int d) {",
			"            if (node *q = p->lchild; !d)",
			"                return set_rchild(q, update(set_lchild(p, q->rchild)));",
			"            else",
			"                return raw_copy(q, q->lchild, update(set_lchild(p, q->rchild)));",
			"        }",
			"        static node *lrotate(node *p, int d) {",
			"            if (node *q = p->rchild; !d)",
			"                return set_lchild(q, update(set_rchild(p, q->lchild)));",
			"            else",
			"                return raw_copy(q, update(set_rchild(p, q->lchild)), q->rchild);",
			"        }",
			"        static node *lrrotate(node *p, int d) {",
			"            if (node *l = p->lchild, *lr = l->rchild; !d)",
			"                return set_lrchild(lr, update(set_rchild(l, lr->lchild)), update(set_lchild(p, lr->rchild)));",
			"            else if (d == 1)",
			"                return raw_copy(lr, update(raw_copy(l, l->lchild, lr->lchild)), update(set_lchild(p, lr->rchild)));",
			"            else",
			"                return raw_copy(lr, update(raw_copy(l, l->lchild, lr->lchild)), update(raw_copy(p, lr->rchild, p->rchild)));",
			"        }",
			"        static node *rlrotate(node *p, int d) {",
			"            if (node *r = p->rchild, *rl = r->lchild; !d)",
			"                return set_lrchild(rl, update(set_rchild(p, rl->lchild)), update(set_lchild(r, rl->rchild)));",
			"            else if (d == 1)",
			"                return raw_copy(rl, update(set_rchild(p, rl->lchild)), update(raw_copy(r, rl->rchild, r->rchild)));",
			"            else",
			"                return raw_copy(rl, update(raw_copy(p, p->lchild, rl->lchild)), update(raw_copy(r, rl->rchild, r->rchild)));",
			"        }",
			"        static node *lbalance(node *cur, int d) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->lchild) < lchild_weight(cur->rchild))",
			"                cur = rlrotate(cur, d);",
			"            else if (subtree_weight(cur->lchild) < rchild_weight(cur->rchild))",
			"                cur = lrotate(cur, d);",
			"            else",
			"                return update(cur);",
			"            return rbalance(lbalance(set_lrchild(cur, rbalance(cur->lchild, d + 1), lbalance(cur->rchild, d + 1)), d + 1), d + 1);",
			"        }",
			"        static node *rbalance(node *cur, int d) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->rchild) < rchild_weight(cur->lchild))",
			"                cur = lrrotate(cur, d);",
			"            else if (subtree_weight(cur->rchild) < lchild_weight(cur->lchild))",
			"                cur = rrotate(cur, d);",
			"            else",
			"                return update(cur);",
			"            return rbalance(lbalance(set_lrchild(cur, rbalance(cur->lchild, d + 1), lbalance(cur->rchild, d + 1)), d + 1), d + 1);",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else",
			"                return update(raw_copy(cur, deleteMin(cur->lchild, res), cur->rchild));",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentSizeBalancedTree(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentSizeBalancedTree() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? rbalance(raw_copy(cur, l, cur->rchild), 0) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? lbalance(raw_copy(cur, cur->lchild, r), 0) : cur;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __value, 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key))",
			"                    return rbalance(raw_copy(cur, self(self, cur->lchild), cur->rchild));",
			"                else if (m_comp(cur->key, __key))",
			"                    return lbalance(raw_copy(cur, cur->lchild, self(self, cur->rchild)));",
			"                else {",
			"                    node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                    p->value = __value;",
			"                    return p;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? update(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? update(raw_copy(cur, cur->lchild, r)) : cur;",
			"                } else {",
			"                    res = true;",
			"                    if (!cur->rchild)",
			"                        return cur->lchild;",
			"                    node *res, *r = deleteMin(cur->rchild, res);",
			"                    return update(raw_copy(res, cur->lchild, r));",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = _root(__version); cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            node *cur = _root(__version);",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentSizeBalancedTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentSizeBalancedTree<_Tp, bool, _Compare, PersistentSizeBalancedTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentSizeBalancedTree<_Tp, bool, _Compare, PersistentSizeBalancedTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentSizeBalancedTree<_Tp, _Fp, _Compare, PersistentSizeBalancedTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent size balanced tree"
	},
	"persistent splay":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentSplaySetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentSplayMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentSplayMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentSplayNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentSplayNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentSplayMultisetTag>",
			"    class PersistentSplay {",
			"#pragma pack(4)",
			"        struct node : _PersistentSplayNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            uint32_t time_stamp;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        int m_state;",
			"        static inline uint32_t s_timer;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if (p->time_stamp == s_timer) return set_lrchild(p, l, r);",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, 1, s_timer, l, r};",
			"            else",
			"                return new node{p->key, 1, s_timer, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            if (p) p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *set_lchild(node *p, node *l) {",
			"            p->lchild = l;",
			"            return p;",
			"        }",
			"        static node *set_rchild(node *p, node *r) {",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *set_lrchild(node *p, node *l, node *r) {",
			"            p->lchild = l;",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *l = p->lchild;",
			"            return raw_copy(l, l->lchild, update(raw_copy(p, l->rchild, p->rchild)));",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *r = p->rchild;",
			"            return raw_copy(r, update(raw_copy(p, p->lchild, r->lchild)), r->rchild);",
			"        }",
			"        static node *rrrotate(node *p) {",
			"            node *l = p->lchild, *ll = l->lchild;",
			"            return raw_copy(ll, ll->lchild, update(raw_copy(l, ll->rchild, update(raw_copy(p, l->rchild, p->rchild)))));",
			"        }",
			"        static node *llrotate(node *p) {",
			"            node *r = p->rchild, *rr = r->rchild;",
			"            return raw_copy(rr, update(raw_copy(r, update(raw_copy(p, p->lchild, r->lchild)), rr->lchild)), rr->rchild);",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *l = p->lchild, *lr = l->rchild;",
			"            return raw_copy(lr, update(raw_copy(l, l->lchild, lr->lchild)), update(raw_copy(p, lr->rchild, p->rchild)));",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *r = p->rchild, *rl = r->lchild;",
			"            return raw_copy(rl, update(raw_copy(p, p->lchild, rl->lchild)), update(raw_copy(r, rl->rchild, r->rchild)));",
			"        }",
			"        node *update_from_lchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 1;",
			"            if (m_state == 3) {",
			"                m_state = 0;",
			"                return rrrotate(cur);",
			"            } else if (m_state == 5) {",
			"                m_state = 0;",
			"                return lrrotate(cur);",
			"            } else if (m_state == 1 && cur == root)",
			"                return rrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *update_from_rchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 2;",
			"            if (m_state == 4) {",
			"                m_state = 0;",
			"                return rlrotate(cur);",
			"            } else if (m_state == 6) {",
			"                m_state = 0;",
			"                return llrotate(cur);",
			"            } else if (m_state == 2 && cur == root)",
			"                return lrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *splay_max(node *cur, node *const &root) {",
			"            if (cur->rchild) {",
			"                cur->rchild = splay_max(cur->rchild, root);",
			"                m_state++;",
			"                if (m_state == 2) {",
			"                    m_state = 0;",
			"                    return llrotate(cur);",
			"                } else if (m_state == 1 && cur == root)",
			"                    return lrotate(cur);",
			"                else",
			"                    return cur;",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        node *splay_kth(node *cur, node *const &root, int k) {",
			"            if (k < subtree_weight(cur->lchild)) {",
			"                cur->lchild = splay_kth(cur->lchild, root, k);",
			"                return update_from_lchild(cur, root);",
			"            } else if (k -= subtree_weight(cur->lchild); k--) {",
			"                cur->rchild = splay_kth(cur->rchild, root, k);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        template <typename... Args>",
			"        node *splay_insert(node *cur, node *const &root, _Tp key, Args... args) {",
			"            if (!cur) {",
			"                m_state = 0;",
			"                return new node{key, args..., 1, s_timer + 1, nullptr, nullptr};",
			"            } else if (m_comp(key, cur->key)) {",
			"                node *p = splay_insert(cur->lchild, root, key, args...);",
			"                if (m_state < 0) return cur;",
			"                p = raw_copy(cur, p, cur->rchild);",
			"                if (cur == root && !m_state) return rrotate(p);",
			"                return update_from_lchild(p, root);",
			"            } else {",
			"                if constexpr (!_Tag::multi_key) {",
			"                    if (!m_comp(cur->key, key)) {",
			"                        m_state = -1;",
			"                        return cur;",
			"                    }",
			"                }",
			"                node *p = splay_insert(cur->rchild, root, key, args...);",
			"                if (m_state < 0) return cur;",
			"                p = raw_copy(cur, cur->lchild, p);",
			"                if (cur == root && !m_state) return lrotate(p);",
			"                return update_from_rchild(p, root);",
			"            }",
			"        }",
			"        node *splay_update(node *cur, node *const &root, _Tp key, _Fp value) {",
			"            if (!cur) {",
			"                m_state = 0;",
			"                return new node{key, value, 1, s_timer + 1, nullptr, nullptr};",
			"            } else if (m_comp(key, cur->key)) {",
			"                node *p = splay_update(cur->lchild, root, key, value);",
			"                if (m_state < 0) return cur;",
			"                p = raw_copy(cur, p, cur->rchild);",
			"                if (cur == root && !m_state) return rrotate(p);",
			"                return update_from_lchild(p, root);",
			"            } else if (m_comp(cur->key, key)) {",
			"                node *p = splay_update(cur->rchild, root, key, value);",
			"                if (m_state < 0) return cur;",
			"                p = raw_copy(cur, cur->lchild, p);",
			"                if (cur == root && !m_state) return lrotate(p);",
			"                return update_from_rchild(p, root);",
			"            } else {",
			"                m_state = 0;",
			"                node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                p->value = value;",
			"                return p;",
			"            }",
			"        }",
			"        node *splay_find(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_find(cur->lchild, root, key);",
			"                return update_from_lchild(cur, root);",
			"            } else if (m_comp(cur->key, key)) {",
			"                cur->rchild = splay_find(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        node *splay_smaller_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(cur->key, key)) {",
			"                cur->rchild = splay_smaller_bound(cur->rchild, root, key);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                cur->lchild = splay_smaller_bound(cur->lchild, root, key);",
			"                return update_from_lchild(cur, root);",
			"            }",
			"        }",
			"        node *splay_upper_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_upper_bound(cur->lchild, root, key);",
			"                if (m_state < 0) {",
			"                    m_state = 0;",
			"                    return cur;",
			"                }",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                cur->rchild = splay_upper_bound(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            }",
			"        }",
			"        node *splay_lower_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (!m_comp(cur->key, key)) {",
			"                cur->lchild = splay_lower_bound(cur->lchild, root, key);",
			"                if (m_state < 0) {",
			"                    m_state = 0;",
			"                    return cur;",
			"                }",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                cur->rchild = splay_lower_bound(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            }",
			"        }",
			"        node *&_root(int version) { return ~version ? m_roots[version] : m_roots.back(); }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentSplay(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentSplay() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, Args... __args) {",
			"            m_roots.push_back(update(splay_insert(_root(__prevVersion), _root(__prevVersion), __args...)));",
			"            s_timer += 2;",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            m_roots.push_back(update(splay_update(_root(__prevVersion), _root(__prevVersion), __key, __value)));",
			"            s_timer += 2;",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            node *root = update(splay_find(_root(__prevVersion), _root(__prevVersion), __key));",
			"            if (~m_state) {",
			"                node *r = root->rchild;",
			"                if (root->lchild) {",
			"                    root = update(splay_max(root->lchild, root->lchild));",
			"                    if (r) root = update(raw_copy(root, root->lchild, r));",
			"                } else",
			"                    root = r;",
			"            }",
			"            m_roots.push_back(root);",
			"            s_timer++;",
			"            return ~m_state;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_lower_bound(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? subtree_weight(_root(__version)->lchild) : subtree_weight(_root(__version));",
			"        }",
			"        const node *kth(int __version, int __k) {",
			"            _root(__version) = update(splay_kth(_root(__version), _root(__version), __k));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        const node *find(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_find(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_lower_bound(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_upper_bound(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_smaller_bound(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) {",
			"            node *root1, *root2;",
			"            if (!(root1 = update(lower_bound(_root(__version), _root(__version), __key)))) return 0;",
			"            int smaller = subtree_weight(root1->lchild);",
			"            if (!(root2 = update(upper_bound(_root(__version), _root(__version), __key)))) {",
			"                s_timer++;",
			"                return size(__version) - smaller;",
			"            } else {",
			"                s_timer++;",
			"                return subtree_weight(root2->lchild) - smaller;",
			"            }",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentSplayContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentSplay<_Tp, bool, _Compare, PersistentSplaySetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentSplay<_Tp, bool, _Compare, PersistentSplayMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentSplay<_Tp, _Fp, _Compare, PersistentSplayMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent splay tree"
	},
	"persistent treap":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentTreapSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentTreapMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentTreapMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentTreapNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentTreapNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentTreapMultisetTag>",
			"    class PersistentTreap {",
			"#pragma pack(4)",
			"        struct node : _PersistentTreapNode<_Tp, _Fp, _Tag::is_map> {",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static inline std::mt19937 s_rand;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, p->priority, p->subtree_weight, l, r};",
			"            else",
			"                return new node{p->key, p->priority, p->subtree_weight, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentTreap(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentTreap() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., s_rand(), 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    if (!res) return cur;",
			"                    if (subtree_priority(l) > cur->priority) {",
			"                        l->rchild = update(raw_copy(cur, l->rchild, cur->rchild));",
			"                        return update(l);",
			"                    } else {",
			"                        cur = raw_copy(cur, l, cur->rchild);",
			"                        cur->subtree_weight++;",
			"                        return cur;",
			"                    }",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    node *r = self(self, cur->rchild);",
			"                    if (!res) return cur;",
			"                    if (subtree_priority(r) > cur->priority) {",
			"                        r->lchild = update(raw_copy(cur, cur->lchild, r->lchild));",
			"                        return update(r);",
			"                    } else {",
			"                        cur = raw_copy(cur, cur->lchild, r);",
			"                        cur->subtree_weight++;",
			"                        return cur;",
			"                    }",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return new node{__key, __value, s_rand(), 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    if (subtree_priority(l) > cur->priority) {",
			"                        l->rchild = update(raw_copy(cur, l->rchild, cur->rchild));",
			"                        return update(l);",
			"                    } else {",
			"                        cur = raw_copy(cur, l, cur->rchild);",
			"                        cur->subtree_weight++;",
			"                        return cur;",
			"                    }",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    if (subtree_priority(r) > cur->priority) {",
			"                        r->lchild = update(raw_copy(cur, cur->lchild, r->lchild));",
			"                        return update(r);",
			"                    } else {",
			"                        cur = raw_copy(cur, cur->lchild, r);",
			"                        cur->subtree_weight++;",
			"                        return cur;",
			"                    }",
			"                } else {",
			"                    node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                    p->value = __value;",
			"                    return p;",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? update(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? update(raw_copy(cur, cur->lchild, r)) : cur;",
			"                } else {",
			"                    res = true;",
			"                    if (node *l = cur->lchild, *r = cur->rchild; !l)",
			"                        return r;",
			"                    else if (!r)",
			"                        return l;",
			"                    else if (l->subtree_weight > r->subtree_weight)",
			"                        return update(raw_copy(l, l->lchild, self(self, raw_copy(cur, l->rchild, r))));",
			"                    else",
			"                        return update(raw_copy(r, self(self, raw_copy(cur, l, r->lchild)), r->rchild));",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = _root(__version); cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            node *cur = _root(__version);",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentTreapContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentTreap<_Tp, bool, _Compare, PersistentTreapSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentTreap<_Tp, bool, _Compare, PersistentTreapMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentTreap<_Tp, _Fp, _Compare, PersistentTreapMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent treap"
	},
	"persistent tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation = std::plus<_Tp>>",
			"    struct PersistentSegTree {",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        std::vector<_TpNode *> m_roots;",
			"        int m_length;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            //assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        _TpNode *_update(_TpNode *cur) {",
			"            cur->val = m_op(cur->lchild ? cur->lchild->val : m_defaultValue, cur->rchild ? cur->rchild->val : m_defaultValue);",
			"            return cur;",
			"        }",
			"        _TpNode *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"        void _clear() { m_roots.clear(); }",
			"        static void setBufferSize(int __count) { MemoryPool<_TpNode>::_reserve(__count); }",
			"        PersistentSegTree(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        PersistentSegTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            _clear();",
			"            if (m_length = __n) m_roots.push_back(new _TpNode(m_defaultValue, nullptr, nullptr));",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            _clear();",
			"            m_length = __last - __first;",
			"            auto dfs = [&](auto self, _Iterator first, _Iterator last) -> _TpNode * {",
			"                if (first + 1 == last)",
			"                    return new _TpNode(*first, nullptr, nullptr);",
			"                else",
			"                    return _update(new _TpNode(*first, self(self, first, first + (last - first + 1) / 2), self(self, first + (last - first + 1) / 2, last)));",
			"            };",
			"            m_roots.push_back(dfs(dfs, __first, __last));",
			"        }",
			"        void copyVersion(int __prevVersion) {",
			"            m_roots.push_back(_root(__prevVersion));",
			"        }",
			"        void update(int __prevVersion, int __i, _Tp __val) {",
			"            auto dfs = [&](auto self, _TpNode *prev, int left, int right) -> _TpNode * {",
			"                _TpNode *cur = prev ? new _TpNode(*prev) : new _TpNode(m_defaultValue, nullptr, nullptr);",
			"                if (left == right)",
			"                    cur->val = __val;",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        cur->lchild = self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"                return cur;",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion), 0, m_length - 1));",
			"        }",
			"        void add(int __prevVersion, int __i, _Tp __inc) {",
			"            auto dfs = [&](auto self, _TpNode *prev, int left, int right) -> _TpNode * {",
			"                _TpNode *cur = prev ? new _TpNode(*prev) : new _TpNode(m_defaultValue, nullptr, nullptr);",
			"                if (left == right)",
			"                    cur->val = m_op(cur->val, __inc);",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        cur->lchild = self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"                return cur;",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion), 0, m_length - 1));",
			"        }",
			"        _Tp query(int __version, int __i) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) {",
			"                if (left == right)",
			"                    return cur->val;",
			"                else if (__i <= (left + right) / 2)",
			"                    return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue;",
			"                else",
			"                    return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue;",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1);",
			"        }",
			"        _Tp query(int __version, int __left, int __right) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) {",
			"                if (left >= __left && right <= __right)",
			"                    return cur->val;",
			"                else if (__right <= (left + right) / 2)",
			"                    return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue;",
			"                else if (__left > (left + right) / 2)",
			"                    return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue;",
			"                else",
			"                    return m_op(cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue, cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue);",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1);",
			"        }",
			"        _Tp queryAll(int __version) const {",
			"            return _root(__version)->val;",
			"        }",
			"        int kth(int __version, _Tp __k) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right, int k) {",
			"                if (left == right) return left;",
			"                if (cur->lchild) {",
			"                    if (cur->lchild->val > k)",
			"                        return self(self, cur->lchild, left, (left + right) / 2, k);",
			"                    else",
			"                        return self(self, cur->rchild, (left + right) / 2 + 1, right, k - cur->lchild->val);",
			"                } else",
			"                    return self(self, cur->rchild, (left + right) / 2 + 1, right, k);",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1, __k);",
			"        }",
			"        _Tp periodQuery(int __leftVersion, int __rightVersion, int __i) const {",
			"            if (__leftVersion == 0) return query(__rightVersion, __i);",
			"            auto dfs = [&](auto self, _TpNode *root1, _TpNode *root2, int left, int right) {",
			"                if (root1 == root2) return 0;",
			"                if (left == right)",
			"                    return root1 ? root2->val - root1->val : root2->val;",
			"                else if (__i <= (left + right) / 2)",
			"                    return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2);",
			"                else",
			"                    return self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right);",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1);",
			"        }",
			"        _Tp periodQuery(int __leftVersion, int __rightVersion, int __left, int __right) const {",
			"            if (__leftVersion == 0) return query(__rightVersion, __left, __right);",
			"            auto dfs = [&](auto self, _TpNode *root1, _TpNode *root2, int left, int right) -> _Tp {",
			"                if (root1 == root2) return 0;",
			"                if (left >= __left && right <= __right)",
			"                    return root1 ? root2->val - root1->val : root2->val;",
			"                else if (__right <= (left + right) / 2)",
			"                    return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2);",
			"                else if (__left > (left + right) / 2)",
			"                    return self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right);",
			"                else",
			"                    return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2) + self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right);",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1);",
			"        }",
			"        int periodKth(int __leftVersion, int __rightVersion, _Tp __k) const {",
			"            if (__leftVersion == 0) return kth(__rightVersion, __k);",
			"            auto dfs = [&](auto self, _TpNode *root1, _TpNode *root2, int left, int right, int k) {",
			"                if (left == right) return left;",
			"                if (!root1 || !root1->lchild) {",
			"                    if (!root2->lchild)",
			"                        return self(self, root1 && root1->rchild ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, k);",
			"                    else if (root2->lchild->val > k)",
			"                        return self(self, nullptr, root2->lchild, left, (left + right) / 2, k);",
			"                    else",
			"                        return self(self, root1 && root1->rchild ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, k - root2->lchild->val);",
			"                } else if (root2->lchild->val - root1->lchild->val > k)",
			"                    return self(self, root1->lchild, root2->lchild, left, (left + right) / 2, k);",
			"                else",
			"                    return self(self, root1->rchild, root2->rchild, (left + right) / 2 + 1, right, k - root2->lchild->val + root1->lchild->val);",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1, __k);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    PersistentSegTree(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp()) -> PersistentSegTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int64_t>",
			"    PersistentSegTree(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> PersistentSegTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    PersistentSegTree(int = 0, _Operation = _Operation(), _Tp = _Tp()) -> PersistentSegTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    PersistentSegTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp()) -> PersistentSegTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    PersistentSegTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> PersistentSegTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>>",
			"    PersistentSegTree(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp()) -> PersistentSegTree<_Tp, _Operation>;",
			"}",
		],
		"description": "persistent tree"
	},
	"persistent weight balanced leafy tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentWeightBalancedLeafySetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentWeightBalancedLeafyMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentWeightBalancedLeafyMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentWeightBalancedLeafyTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentWeightBalancedLeafyTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentWeightBalancedLeafyMultisetTag>",
			"    class PersistentWeightBalancedLeafyTree {",
			"#pragma pack(4)",
			"        struct node : _PersistentWeightBalancedLeafyTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static constexpr int ratio = 4, bias = 2;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, p->subtree_weight, l, r};",
			"            else",
			"                return new node{p->key, p->subtree_weight, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->lchild->subtree_weight + p->rchild->subtree_weight;",
			"            p->key = p->rchild->key;",
			"            return p;",
			"        }",
			"        static node *set_lchild(node *p, node *l) {",
			"            p->lchild = l;",
			"            return p;",
			"        }",
			"        static node *set_rchild(node *p, node *r) {",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *set_lrchild(node *p, node *l, node *r) {",
			"            p->lchild = l;",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *lrotate(node *p, int reuse) {",
			"            if (node *r = p->rchild; reuse == 2)",
			"                return update(set_lchild(r, update(set_rchild(p, r->lchild))));",
			"            else if (reuse == 1)",
			"                return update(raw_copy(r, update(set_rchild(p, r->lchild)), r->rchild));",
			"            else",
			"                return update(raw_copy(r, update(raw_copy(p, p->lchild, r->lchild)), r->rchild));",
			"        }",
			"        static node *rrotate(node *p, int reuse) {",
			"            if (node *l = p->lchild; reuse == 2)",
			"                return update(set_rchild(l, update(set_lchild(p, l->rchild))));",
			"            else if (reuse == 1)",
			"                return update(raw_copy(l, l->lchild, update(set_lchild(p, l->rchild))));",
			"            else",
			"                return update(raw_copy(l, l->lchild, update(raw_copy(p, l->rchild, p->rchild))));",
			"        }",
			"        static node *balance(node *cur, bool is_insert) {",
			"            if (cur->lchild->subtree_weight > cur->rchild->subtree_weight * ratio + bias) {",
			"                if (cur->lchild->rchild->subtree_weight > cur->lchild->lchild->subtree_weight * (ratio - 1) + bias)",
			"                    cur->lchild = lrotate(cur->lchild, 0);",
			"                return rrotate(cur, 1 + is_insert);",
			"            } else if (cur->rchild->subtree_weight > cur->lchild->subtree_weight * ratio + bias) {",
			"                if (cur->rchild->lchild->subtree_weight > cur->rchild->rchild->subtree_weight * (ratio - 1) + bias)",
			"                    cur->rchild = rrotate(cur->rchild, 0);",
			"                return lrotate(cur, 1 + is_insert);",
			"            } else",
			"                return update(cur);",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentWeightBalancedLeafyTree(_Tp __maxKey = std::numeric_limits<_Tp>::max(), _Compare __comp = _Compare()) : m_comp(__comp) {",
			"            node *root = new node;",
			"            root->key = __maxKey;",
			"            root->subtree_weight = 1;",
			"            root->lchild = nullptr;",
			"            root->rchild = nullptr;",
			"            m_roots.push_back(root);",
			"        }",
			"        ~PersistentWeightBalancedLeafyTree() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur->lchild) {",
			"                    res = true;",
			"                    node *p = raw_copy(cur, new node{__key, __args..., 1, nullptr, nullptr}, cur);",
			"                    p->subtree_weight = 2;",
			"                    return p;",
			"                } else if (m_comp(cur->lchild->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r), true) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(__key, cur->lchild->key)) return cur;",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild), true) : cur;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur->lchild) {",
			"                    if (m_comp(__key, cur->key)) {",
			"                        node *p = raw_copy(cur, new node{__key, __value, 1, nullptr, nullptr}, cur);",
			"                        p->subtree_weight = 2;",
			"                        return p;",
			"                    } else {",
			"                        node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                        p->value = __value;",
			"                        return p;",
			"                    }",
			"                } else if (m_comp(cur->lchild->key, __key))",
			"                    return balance(raw_copy(cur, cur->lchild, self(self, cur->rchild)), true);",
			"                else",
			"                    return balance(raw_copy(cur, self(self, cur->lchild), cur->rchild), true);",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur->lchild) {",
			"                    if (m_comp(__key, cur->key)) return cur;",
			"                    res = true;",
			"                    return nullptr;",
			"                } else if (!m_comp(cur->lchild->key, __key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    if (!res) return cur;",
			"                    if (!l) return cur->rchild;",
			"                    return balance(raw_copy(cur, l, cur->rchild), false);",
			"                } else {",
			"                    node *r = self(self, cur->rchild);",
			"                    if (!res) return cur;",
			"                    if (!r) return cur->lchild;",
			"                    return balance(raw_copy(cur, cur->lchild, r), false);",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = _root(__version); cur->lchild;)",
			"                if (m_comp(cur->lchild->key, __key)) {",
			"                    ord += cur->lchild->subtree_weight;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            node *cur = _root(__version);",
			"            while (cur->lchild)",
			"                if (int l_count = cur->lchild->subtree_weight; __k < l_count)",
			"                    cur = cur->lchild;",
			"                else {",
			"                    __k -= l_count;",
			"                    cur = cur->rchild;",
			"                }",
			"            return cur;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            node *cur = _root(__version);",
			"            while (cur->lchild)",
			"                if (m_comp(cur->lchild->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    cur = cur->lchild;",
			"            return m_comp(__key, cur->key) ? nullptr : cur;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            node *cur = _root(__version);",
			"            while (cur->lchild)",
			"                if (m_comp(cur->lchild->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    cur = cur->lchild;",
			"            return cur;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            node *cur = _root(__version);",
			"            while (cur->lchild)",
			"                if (m_comp(__key, cur->lchild->key))",
			"                    cur = cur->lchild;",
			"                else",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur->lchild;) {",
			"                if (m_comp(cur->lchild->key, __key)) {",
			"                    res = cur->lchild;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            if (res)",
			"                while (res->rchild) res = res->rchild;",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)) - 1; }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentWeightBalancedLeafyTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentWeightBalancedLeafyTree<_Tp, bool, _Compare, PersistentWeightBalancedLeafySetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentWeightBalancedLeafyTree<_Tp, bool, _Compare, PersistentWeightBalancedLeafyMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentWeightBalancedLeafyTree<_Tp, _Fp, _Compare, PersistentWeightBalancedLeafyMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent weight balanced leafy tree"
	},
	"range manager":{
		"prefix": "RANGE",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct RangeManager : std::map<_Tp, _Tp> {",
			"        _Tp m_length = 0;",
			"        using std::map<_Tp, _Tp>::map, std::map<_Tp, _Tp>::upper_bound, std::map<_Tp, _Tp>::begin, std::map<_Tp, _Tp>::end, std::map<_Tp, _Tp>::emplace, std::map<_Tp, _Tp>::erase;",
			"        static _Tp length(const std::pair<_Tp, _Tp> &__range) { return __range.second - __range.first + 1; }",
			"        std::pair<std::vector<std::pair<_Tp, _Tp>>, typename std::map<_Tp, _Tp>::iterator> addRange(std::pair<_Tp, _Tp> __range) {",
			"            std::vector<std::pair<_Tp, _Tp>> deleted;",
			"            auto it = upper_bound(__range.first);",
			"            if (it != begin() && std::prev(it)->second + 1 >= __range.first) {",
			"                if (std::prev(it)->second >= __range.second) return {{*std::prev(it)}, std::prev(it)};",
			"                __range.first = std::prev(it)->first;",
			"                deleted.emplace_back(*std::prev(it));",
			"                it = erase(std::prev(it));",
			"            }",
			"            for (; it != end() && it->first <= __range.second + 1; it = erase(it)) {",
			"                if (it->second > __range.second) __range.second = it->second;",
			"                deleted.emplace_back(*it);",
			"            }",
			"            for (auto &range : deleted) m_length -= length(range);",
			"            auto inserted = emplace(__range.first, __range.second).first;",
			"            m_length += length(*inserted);",
			"            return {deleted, inserted};",
			"        }",
			"        std::pair<std::vector<std::pair<_Tp, _Tp>>, std::vector<std::pair<_Tp, _Tp>>> removeRange(std::pair<_Tp, _Tp> __range) {",
			"            std::vector<std::pair<_Tp, _Tp>> deleted, inserted;",
			"            auto it = upper_bound(__range.first);",
			"            if (it != begin() && std::prev(it)->second + 1 >= __range.first) {",
			"                it = std::prev(it);",
			"                deleted.emplace_back(*it);",
			"                if (it->second >= __range.second) {",
			"                    if (it->second > __range.second) inserted.emplace_back(*emplace(__range.second + 1, it->second).first);",
			"                    if (it->first < __range.first) {",
			"                        it->second = __range.first - 1;",
			"                        inserted.emplace_back(*it);",
			"                    } else",
			"                        erase(it);",
			"                    for (auto &range : deleted) m_length -= length(range);",
			"                    for (auto &range : inserted) m_length += length(range);",
			"                    return {deleted, inserted};",
			"                }",
			"                if (it->first < __range.first) {",
			"                    it->second = __range.first - 1;",
			"                    inserted.emplace_back(*it);",
			"                    it = std::next(it);",
			"                } else",
			"                    it = erase(it);",
			"            }",
			"            for (; it != end() && it->first <= __range.second; it = erase(it)) {",
			"                deleted.emplace_back(*it);",
			"                if (it->second > __range.second) inserted.emplace_back(*emplace(__range.second + 1, it->second).first);",
			"            }",
			"            for (auto &range : deleted) m_length -= length(range);",
			"            for (auto &range : inserted) m_length += length(range);",
			"            return {deleted, inserted};",
			"        }",
			"        typename std::map<_Tp, _Tp>::const_iterator any_of(const std::pair<_Tp, _Tp> &__range) const {",
			"            if (auto it = upper_bound(__range.second); it != begin() && std::prev(it)->second >= __range.first) return std::prev(it);",
			"            return end();",
			"        }",
			"        typename std::map<_Tp, _Tp>::const_iterator all_of(const std::pair<_Tp, _Tp> &__range) const {",
			"            if (auto it = upper_bound(__range.second); it != begin() && std::prev(it)->first <= __range.first && std::prev(it)->second >= __range.second) return std::prev(it);",
			"            return end();",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &__os, const RangeManager &__rm) {",
			"            __os << '[';",
			"            uint32_t index = 0;",
			"            for (auto &[l, r] : __rm) {",
			"                if (index++) __os << \", \";",
			"                __os << '[' << l << \", \" << r << ']';",
			"            }",
			"            return __os << ']';",
			"        }",
			"    };",
			"}",
		],
		"description": "range manager"
	},
	"scape goat tree":{
		"prefix": "SGT",
		"body": [
			"namespace OY {",
			"    struct ScapeGoatTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct ScapeGoatTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct ScapeGoatTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _ScapeGoatTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _ScapeGoatTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = ScapeGoatTreeMultisetTag>",
			"    class ScapeGoatTree {",
			"        struct node : _ScapeGoatTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            bool node_weight;",
			"            int subtree_weight;",
			"            int subtree_capacity;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>().operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static constexpr int ratio = 4, bias = 4;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int subtree_capacity(node *p) { return p ? p->subtree_capacity : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->node_weight + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            p->subtree_capacity = 1 + subtree_capacity(p->lchild) + subtree_capacity(p->rchild);",
			"            return p;",
			"        }",
			"        static void traverse(node *p, node **&s_cursor) {",
			"            if (p->lchild) traverse(p->lchild, s_cursor);",
			"            if (p->node_weight)",
			"                *s_cursor++ = p;",
			"            else",
			"                delete p;",
			"            if (p->rchild) traverse(p->rchild, s_cursor);",
			"        }",
			"        static node *make_tree(node **first, node **last) {",
			"            if (first == last) return nullptr;",
			"            node **mid = first + (last - first) / 2;",
			"            (*mid)->lchild = make_tree(first, mid);",
			"            (*mid)->rchild = make_tree(mid + 1, last);",
			"            return update(*mid);",
			"        }",
			"        static node *balance(node *cur) {",
			"            update(cur);",
			"            if (subtree_weight(cur->lchild) <= subtree_weight(cur->rchild) * ratio + bias && subtree_weight(cur->rchild) <= subtree_weight(cur->lchild) * ratio + bias && cur->subtree_capacity * 2 <= cur->subtree_weight * 3) return cur;",
			"            static std::vector<node *> s_buffer;",
			"            static node **s_cursor;",
			"            s_buffer.resize(cur->subtree_weight);",
			"            s_cursor = s_buffer.data();",
			"            traverse(cur, s_cursor);",
			"            return make_tree(s_buffer.data(), s_cursor);",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        ScapeGoatTree(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __args..., true, 1, 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return balance(cur);",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) {",
			"                            if (!cur->node_weight) {",
			"                                cur->node_weight = true;",
			"                                cur->subtree_weight++;",
			"                            }",
			"                            return cur;",
			"                        }",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return balance(cur);",
			"                }",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key))",
			"                    cur->lchild = self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    cur->rchild = self(self, cur->rchild);",
			"                else if (cur->node_weight) {",
			"                    cur->node_weight = false;",
			"                    cur->subtree_weight--;",
			"                    res = true;",
			"                } else {",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    if (!res) cur->lchild = self(self, cur->lchild);",
			"                }",
			"                return res ? balance(cur) : cur;",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"            return res;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> int {",
			"                if (!cur)",
			"                    return 0;",
			"                else if (m_comp(cur->key, __key))",
			"                    return subtree_weight(cur->lchild) + cur->node_weight + self(self, cur->rchild);",
			"                else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        const node *kth(int __k) const {",
			"            auto dfs = [&](auto self, node *cur, int k) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (int l_count = subtree_weight(cur->lchild); k < l_count)",
			"                    return self(self, cur->lchild, k);",
			"                else if (k -= l_count + cur->node_weight; k < 0)",
			"                    return cur;",
			"                else",
			"                    return self(self, cur->rchild, k);",
			"            };",
			"            return dfs(dfs, m_root, __k);",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key))",
			"                    return self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    return self(self, cur->rchild);",
			"                else if (cur->node_weight)",
			"                    return cur;",
			"                else if (node *res = self(self, cur->rchild))",
			"                    return res;",
			"                else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key)) {",
			"                    node *res = self(self, cur->lchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->rchild);",
			"                    return res;",
			"                } else if (!m_comp(cur->key, __key) && cur->node_weight)",
			"                    return cur;",
			"                else",
			"                    return self(self, cur->rchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key)) {",
			"                    node *res = self(self, cur->lchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->rchild);",
			"                    return res;",
			"                } else",
			"                    return self(self, cur->rchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(cur->key, __key)) {",
			"                    node *res = self(self, cur->rchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->lchild);",
			"                    return res;",
			"                } else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace ScapeGoatContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = ScapeGoatTree<_Tp, bool, _Compare, ScapeGoatTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = ScapeGoatTree<_Tp, bool, _Compare, ScapeGoatTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = ScapeGoatTree<_Tp, _Fp, _Compare, ScapeGoatTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "scape goat tree"
	},
	"segtree":{
		"prefix": "SEG",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation = std::plus<_Tp>>",
			"    class SegTree {",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        _TpNode *m_root;",
			"        int m_length;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            //assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        _TpNode *_update(_TpNode *cur) {",
			"            cur->val = m_op(cur->lchild ? cur->lchild->val : m_defaultValue, cur->rchild ? cur->rchild->val : m_defaultValue);",
			"            return cur;",
			"        }",
			"        void _clear(_TpNode *p) {",
			"            // if (p->lchild) delete p->lchild;",
			"            // if (p->rchild) delete p->rchild;",
			"            // delete p;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_TpNode>::_reserve(__count); }",
			"        SegTree(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_root(nullptr), m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        SegTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_root(nullptr), m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        ~SegTree() {",
			"            if (m_root) _clear(m_root);",
			"        }",
			"        void resize(int __n) {",
			"            if (m_root) _clear(m_root);",
			"            m_root = (m_length = __n) ? new _TpNode(m_defaultValue, nullptr, nullptr) : nullptr;",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            if (m_root) _clear(m_root);",
			"            m_length = __last - __first;",
			"            auto dfs = [&](auto self, _Iterator first, _Iterator last) -> _TpNode * {",
			"                if (first + 1 == last)",
			"                    return new _TpNode(*first, nullptr, nullptr);",
			"                else",
			"                    return _update(new _TpNode(m_defaultValue, self(self, first, first + (last - first + 1) / 2), self(self, first + (last - first + 1) / 2, last)));",
			"            };",
			"            m_root = dfs(dfs, __first, __last);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) -> void {",
			"                if (left == right)",
			"                    cur->val = __val;",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        self(self, lchild(cur), left, (left + right) / 2);",
			"                    else",
			"                        self(self, rchild(cur), (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void add(int __i, _Tp __inc) {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) -> void {",
			"                if (left == right)",
			"                    cur->val = m_op(cur->val, __inc);",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        self(self, lchild(cur), left, (left + right) / 2);",
			"                    else",
			"                        self(self, rchild(cur), (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp query(int __i) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) {",
			"                if (left == right)",
			"                    return cur->val;",
			"                else if (__i <= (left + right) / 2)",
			"                    return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue;",
			"                else",
			"                    return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue;",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp query(int __left, int __right) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) {",
			"                if (left >= __left && right <= __right)",
			"                    return cur->val;",
			"                else if (__right <= (left + right) / 2)",
			"                    return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue;",
			"                else if (__left > (left + right) / 2)",
			"                    return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue;",
			"                else",
			"                    return m_op(cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue, cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue);",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp queryAll() const { return m_root->val; }",
			"        int kth(_Tp __k) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right, int k) {",
			"                if (left == right) return left;",
			"                if (cur->lchild) {",
			"                    if (cur->lchild->val > k)",
			"                        return self(self, cur->lchild, left, (left + right) / 2, k);",
			"                    else",
			"                        return self(self, cur->rchild, (left + right) / 2 + 1, right, k - cur->lchild->val);",
			"                } else",
			"                    return self(self, cur->rchild, (left + right) / 2 + 1, right, k);",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1, __k);",
			"        }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    SegTree(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp()) -> SegTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int64_t>",
			"    SegTree(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> SegTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    SegTree(int = 0, _Operation = _Operation(), _Tp = _Tp()) -> SegTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SegTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp()) -> SegTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SegTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> SegTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>>",
			"    SegTree(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp()) -> SegTree<_Tp, _Operation>;",
			"}",
		],
		"description": "segtree"
	},
	"segtree 2d":{
		"prefix": "SEG2D",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation = std::plus<_Tp>>",
			"    class SegTree2d {",
			"#pragma pack(4)",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        struct _TpTree : MemoryPool<_TpTree> {",
			"            _TpNode *root;",
			"            _TpTree *lchild;",
			"            _TpTree *rchild;",
			"            _TpTree() : root(nullptr), lchild(nullptr), rchild(nullptr) {}",
			"        };",
			"#pragma pack()",
			"        _TpTree *m_root;",
			"        int m_row;",
			"        int m_column;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        static _TpTree *lchild(_TpTree *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpTree;",
			"            return cur->lchild;",
			"        }",
			"        static _TpTree *rchild(_TpTree *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpTree;",
			"            return cur->rchild;",
			"        }",
			"        _TpNode *root(_TpTree *cur) {",
			"            if (!cur->root)",
			"                cur->root = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->root;",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        void _add(_TpNode *cur, int left, int right, int col, _Tp inc) {",
			"            cur->val = m_op(cur->val, inc);",
			"            if (left == right) return;",
			"            if (int mid = (left + right) / 2; col <= mid)",
			"                _add(lchild(cur), left, mid, col, inc);",
			"            else",
			"                _add(rchild(cur), mid + 1, right, col, inc);",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col) const {",
			"            if (left == right)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col) : m_defaultValue;",
			"            else",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col) : m_defaultValue;",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col1, int col2) const {",
			"            if (left >= col1 && right <= col2)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col2 <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue;",
			"            else if (col1 > mid)",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue;",
			"            else",
			"                return m_op(cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue, cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue);",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __treeCount, int __nodeCount) {",
			"            MemoryPool<_TpTree>::_reserve(__treeCount);",
			"            MemoryPool<_TpNode>::_reserve(__nodeCount);",
			"        }",
			"        SegTree2d(int __row, int __column, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_root(nullptr), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__row, __column);",
			"        }",
			"        template <typename Ref>",
			"        SegTree2d(Ref __ref, int __row, int __column, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_root(nullptr), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__ref, __row, __column);",
			"        }",
			"        ~SegTree2d() {",
			"            if (m_root) {",
			"                // _clear(m_root);",
			"                m_root = nullptr;",
			"            }",
			"        }",
			"        void resize(int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_root = new _TpTree;",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            auto build_leaf = [&](auto self, int left, int right, int row) {",
			"                if (left == right) return new _TpNode(__ref(row, left), nullptr, nullptr);",
			"                int mid = (left + right) / 2;",
			"                _TpNode *lchild = self(self, left, mid, row);",
			"                _TpNode *rchild = self(self, mid + 1, right, row);",
			"                return new _TpNode(m_op(lchild->val, rchild->val), lchild, rchild);",
			"            };",
			"            auto build_nonleaf = [&](auto self, _TpNode *lc, _TpNode *rc) -> _TpNode * {",
			"                _TpNode *p = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"                p->val = m_op(lc->val, rc->val);",
			"                if (lc->lchild) {",
			"                    p->lchild = self(self, lc->lchild, rc->lchild);",
			"                    p->rchild = self(self, lc->rchild, rc->rchild);",
			"                }",
			"                return p;",
			"            };",
			"            auto build = [&](auto self, int left, int right) -> _TpTree * {",
			"                _TpTree *p = new _TpTree;",
			"                if (left == right)",
			"                    p->root = build_leaf(build_leaf, 0, m_column - 1, left);",
			"                else {",
			"                    int mid = (left + right) / 2;",
			"                    p->lchild = self(self, left, mid);",
			"                    p->rchild = self(self, mid + 1, right);",
			"                    p->root = build_nonleaf(build_nonleaf, p->lchild->root, p->rchild->root);",
			"                }",
			"                return p;",
			"            };",
			"            m_root = build(build, 0, m_row - 1);",
			"        }",
			"        void add(int __row, int __column, _Tp __inc) {",
			"            auto dfs = [&](auto self, _TpTree *cur, int row1, int row2) {",
			"                _add(root(cur), 0, m_column - 1, __column, __inc);",
			"                if (row1 == row2) return;",
			"                if (int mid = (row1 + row2) / 2; __row <= mid)",
			"                    self(self, lchild(cur), row1, mid);",
			"                else",
			"                    self(self, rchild(cur), mid + 1, row2);",
			"            };",
			"            dfs(dfs, m_root, 0, m_row - 1);",
			"        }",
			"        _Tp query(int __row, int __column) const {",
			"            auto dfs = [&](auto self, _TpTree *cur, int left, int right) {",
			"                if (left == right)",
			"                    return cur->root ? _query(cur->root, 0, m_column - 1, __column) : m_defaultValue;",
			"                else if (int mid = (left + right) / 2; __row <= mid)",
			"                    return cur->lchild ? self(self, cur->lchild, left, mid) : m_defaultValue;",
			"                else",
			"                    return cur->rchild ? self(self, cur->rchild, mid + 1, right) : m_defaultValue;",
			"            };",
			"            return dfs(dfs, m_root, 0, m_row - 1);",
			"        }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const {",
			"            auto dfs = [&](auto self, _TpTree *cur, int left, int right) {",
			"                if (left >= __row1 && right <= __row2)",
			"                    return cur->root ? _query(cur->root, 0, m_column - 1, __column1, __column2) : m_defaultValue;",
			"                else if (int mid = (left + right) / 2; __row2 <= mid)",
			"                    return cur->lchild ? self(self, cur->lchild, left, mid) : m_defaultValue;",
			"                else if (__row1 > (left + right) / 2)",
			"                    return cur->rchild ? self(self, cur->rchild, mid + 1, right) : m_defaultValue;",
			"                else",
			"                    return m_op(cur->lchild ? self(self, cur->lchild, left, mid) : m_defaultValue, cur->rchild ? self(self, cur->rchild, mid + 1, right) : m_defaultValue);",
			"            };",
			"            return dfs(dfs, m_root, 0, m_row - 1);",
			"        }",
			"        _Tp queryAll() const { return query(0, m_row - 1, 0, m_column - 1); }",
			"        int rowKth(int __row1, int __row2, _Tp __k) const {",
			"            static std::vector<_TpNode *> roots_plus;",
			"            roots_plus.clear();",
			"            auto dfs = [&](auto self, _TpTree *cur, int left, int right) {",
			"                if (left >= __row1 && right <= __row2) {",
			"                    if (cur->root) roots_plus.push_back(cur->root);",
			"                    return;",
			"                }",
			"                int mid = (left + right) / 2;",
			"                if (__row1 <= mid && cur->lchild) self(self, cur->lchild, left, mid);",
			"                if (__row2 > mid && cur->rchild) self(self, cur->rchild, mid + 1, right);",
			"            };",
			"            if (m_root) dfs(dfs, m_root, 0, m_row - 1);",
			"            int left = 0, right = m_column - 1;",
			"#define FILTER(vec, prop)                    \\",
			"    {                                        \\",
			"        int i = 0;                           \\",
			"        for (auto a : vec)                   \\",
			"            if (a->prop) vec[i++] = a->prop; \\",
			"        vec.resize(i);                       \\",
			"    }",
			"            while (left < right) {",
			"                _Tp sum = 0;",
			"                for (_TpNode *root : roots_plus) sum += root->lchild ? root->lchild->val : 0;",
			"                if (__k < sum) {",
			"                    right = (left + right) / 2;",
			"                    FILTER(roots_plus, lchild);",
			"                } else {",
			"                    left = (left + right) / 2 + 1;",
			"                    __k -= sum;",
			"                    FILTER(roots_plus, rchild);",
			"                }",
			"            }",
			"            return left;",
			"#undef FILTER",
			"        }",
			"    };",
			"    template <typename _Tp = int, typename _Operation = std::plus<_Tp>>",
			"    SegTree2d(int, int, _Operation = _Operation(), _Tp = _Tp()) -> SegTree2d<_Tp, _Operation>;",
			"    template <typename Ref, typename _Tp = typename std::iterator_traits<typename decltype(std::mem_fn(&Ref::operator()))::result_type>::value_type, typename _Operation = std::plus<_Tp>>",
			"    SegTree2d(Ref, int, int, _Operation = _Operation(), std::enable_if_t<std::is_invocable_v<Ref, int>, _Tp> = _Tp()) -> SegTree2d<_Tp, _Operation>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>, typename _Operation = std::plus<_Tp>>",
			"    SegTree2d(Ref, int, int, _Operation = _Operation(), std::enable_if_t<std::is_invocable_v<Ref, int, int>, _Tp> = _Tp()) -> SegTree2d<_Tp, _Operation>;",
			"}",
		],
		"description": "segtree 2d"
	},
	"seg-binary indexed tree":{
		"prefix": "SEGBIT",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    class SegBIT {",
			"#pragma pack(4)",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"#pragma pack()",
			"        std::vector<_TpNode *> m_sub;",
			"        int m_row;",
			"        int m_column;",
			"        int m_length;",
			"        _Plus m_plus;",
			"        _Minus m_minus;",
			"        _Tp m_defaultValue;",
			"        _TpNode *sub(int i) {",
			"            if (!m_sub[i]) m_sub[i] = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return m_sub[i];",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        void _add(_TpNode *cur, int left, int right, int col, _Tp inc) {",
			"            cur->val = m_plus(cur->val, inc);",
			"            if (left == right) return;",
			"            if (int mid = (left + right) / 2; col <= mid)",
			"                _add(lchild(cur), left, mid, col, inc);",
			"            else",
			"                _add(rchild(cur), mid + 1, right, col, inc);",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col) const {",
			"            if (left == right)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col) : m_defaultValue;",
			"            else",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col) : m_defaultValue;",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col1, int col2) const {",
			"            if (left >= col1 && right <= col2)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col2 <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue;",
			"            else if (col1 > mid)",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue;",
			"            else",
			"                return m_plus(cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue, cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue);",
			"        }",
			"        void _clear(_TpNode *cur) {",
			"            if (cur->lchild) _clear(cur->lchild);",
			"            if (cur->rchild) _clear(cur->rchild);",
			"            delete cur;",
			"        }",
			"        void _clear() {",
			"            // for (_TpNode *root : m_sub)",
			"            //     if (root) _clear(root);",
			"            m_sub.clear();",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_TpNode>::_reserve(__count); }",
			"        SegBIT(int __row, int __column, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) { resize(__row, __column); }",
			"        template <typename Ref>",
			"        SegBIT(Ref __ref, int __row, int __column, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) { reset(__ref, __row, __column); }",
			"        ~SegBIT() { _clear(); }",
			"        void resize(int __row, int __column) {",
			"            _clear();",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_length = m_row > 1 ? 1 << (32 - std::__countl_zero<uint32_t>(m_row - 1)) : 1;",
			"            m_sub.assign(m_length, nullptr);",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            _clear();",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_length = m_row > 1 ? 1 << (32 - std::__countl_zero<uint32_t>(m_row - 1)) : 1;",
			"            auto build_leaf = [&](auto self, int left, int right, int row) {",
			"                if (left == right) return new _TpNode(__ref(row, left), nullptr, nullptr);",
			"                int mid = (left + right) / 2;",
			"                _TpNode *lchild = self(self, left, mid, row);",
			"                _TpNode *rchild = self(self, mid + 1, right, row);",
			"                return new _TpNode(m_plus(lchild->val, rchild->val), lchild, rchild);",
			"            };",
			"            auto build_sum = [&](auto self, _TpNode *cur, _TpNode *other) {",
			"                cur->val = m_plus(cur->val, other->val);",
			"                if (!other->lchild) return;",
			"                self(self, lchild(cur), other->lchild);",
			"                self(self, rchild(cur), other->rchild);",
			"            };",
			"            m_sub.resize(m_length);",
			"            for (int i = 0; i < m_row; i++) m_sub[i] = build_leaf(build_leaf, 0, m_column - 1, i);",
			"            for (int i = 0; i < m_length; i++)",
			"                if (int j = i + (1 << std::__countr_zero<uint32_t>(i + 1)); j < m_length) build_sum(build_sum, sub(j), m_sub[i]);",
			"        }",
			"        void add(int __row, int __column, _Tp __inc) {",
			"            while (__row < m_length) {",
			"                _add(sub(__row), 0, m_column - 1, __column, __inc);",
			"                __row += 1 << std::__countr_zero<uint32_t>(__row + 1);",
			"            }",
			"        }",
			"        _Tp presum(int __row, int __column) const {",
			"            _Tp ret = m_defaultValue;",
			"            while (__row >= 0) {",
			"                ret = m_plus(ret, m_sub[__row] ? _query(m_sub[__row], 0, m_column - 1, __column) : m_defaultValue);",
			"                __row -= 1 << std::__countr_zero<uint32_t>(__row + 1);",
			"            }",
			"            return ret;",
			"        }",
			"        _Tp presum(int __row, int __column1, int __column2) const {",
			"            _Tp ret = m_defaultValue;",
			"            while (__row >= 0) {",
			"                ret = m_plus(ret, m_sub[__row] ? _query(m_sub[__row], 0, m_column - 1, __column1, __column2) : m_defaultValue);",
			"                __row -= 1 << std::__countr_zero<uint32_t>(__row + 1);",
			"            }",
			"            return ret;",
			"        }",
			"        _Tp query(int __row, int __column) const { return m_minus(presum(__row, __column), presum(__row - 1, __column)); }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const { return m_minus(presum(__row2, __column1, __column2), presum(__row1 - 1, __column1, __column2)); }",
			"        _Tp queryAll() const { return presum(m_row - 1, 0, m_column - 1); }",
			"        int rowKth(int __row1, int __row2, _Tp __k) const {",
			"            static std::vector<_TpNode *> roots_plus, roots_minus;",
			"            roots_plus.clear();",
			"            roots_minus.clear();",
			"            while (__row2 >= 0) {",
			"                if (m_sub[__row2]) roots_plus.push_back(m_sub[__row2]);",
			"                __row2 -= 1 << std::__countr_zero<uint32_t>(__row2 + 1);",
			"            }",
			"            __row1--;",
			"            while (__row1 >= 0) {",
			"                if (m_sub[__row1]) roots_minus.push_back(m_sub[__row1]);",
			"                __row1 -= 1 << std::__countr_zero<uint32_t>(__row1 + 1);",
			"            }",
			"            int left = 0, right = m_column - 1;",
			"#define FILTER(vec, prop)                    \\",
			"    {                                        \\",
			"        int i = 0;                           \\",
			"        for (auto a : vec)                   \\",
			"            if (a->prop) vec[i++] = a->prop; \\",
			"        vec.resize(i);                       \\",
			"    }",
			"            while (left < right) {",
			"                _Tp sum = 0;",
			"                for (_TpNode *root : roots_plus) sum += root->lchild ? root->lchild->val : 0;",
			"                for (_TpNode *root : roots_minus) sum -= root->lchild ? root->lchild->val : 0;",
			"                if (__k < sum) {",
			"                    right = (left + right) / 2;",
			"                    FILTER(roots_plus, lchild);",
			"                    FILTER(roots_minus, lchild);",
			"                } else {",
			"                    left = (left + right) / 2 + 1;",
			"                    __k -= sum;",
			"                    FILTER(roots_plus, rchild);",
			"                    FILTER(roots_minus, rchild);",
			"                }",
			"            }",
			"            return left;",
			"#undef FILTER",
			"        }",
			"    };",
			"    template <typename _Tp = int, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    SegBIT(int, int, _Plus = _Plus(), _Minus = _Minus(), _Tp = _Tp()) -> SegBIT<_Tp, _Plus, _Minus>;",
			"    template <typename Ref, typename _Tp = typename std::iterator_traits<typename decltype(std::mem_fn(&Ref::operator()))::result_type>::value_type, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    SegBIT(Ref, int, int, _Plus = _Plus(), _Minus = _Minus(), std::enable_if_t<std::is_invocable_v<Ref, int>, _Tp> = _Tp()) -> SegBIT<_Tp, _Plus, _Minus>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    SegBIT(Ref, int, int, _Plus = _Plus(), _Minus = _Minus(), std::enable_if_t<std::is_invocable_v<Ref, int, int>, _Tp> = _Tp()) -> SegBIT<_Tp, _Plus, _Minus>;",
			"}",
		],
		"description": "seg-binary indexedc tree"
	},
	"seg-zkwtree":{
		"prefix": "SEGZKW",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation = std::plus<_Tp>>",
			"    class SegZkwTree {",
			"#pragma pack(4)",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"#pragma pack()",
			"        std::vector<_TpNode *> m_sub;",
			"        int m_row;",
			"        int m_column;",
			"        int m_depth;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        _TpNode *sub(int i) {",
			"            if (!m_sub[i]) m_sub[i] = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return m_sub[i];",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        void _add(_TpNode *cur, int left, int right, int col, _Tp inc) {",
			"            cur->val = m_op(cur->val, inc);",
			"            if (left == right) return;",
			"            if (int mid = (left + right) / 2; col <= mid)",
			"                _add(lchild(cur), left, mid, col, inc);",
			"            else",
			"                _add(rchild(cur), mid + 1, right, col, inc);",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col) const {",
			"            if (left == right)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col) : m_defaultValue;",
			"            else",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col) : m_defaultValue;",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col1, int col2) const {",
			"            if (left >= col1 && right <= col2)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col2 <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue;",
			"            else if (col1 > mid)",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue;",
			"            else",
			"                return m_op(cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue, cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue);",
			"        }",
			"        void _clear(_TpNode *cur) {",
			"            if (cur->lchild) _clear(cur->lchild);",
			"            if (cur->rchild) _clear(cur->rchild);",
			"            delete cur;",
			"        }",
			"        void _clear() {",
			"            // for (_TpNode *root : m_sub)",
			"            //     if (root) _clear(root);",
			"            m_sub.clear();",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_TpNode>::_reserve(__count); }",
			"        SegZkwTree(int __row, int __column, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__row, __column);",
			"        }",
			"        template <typename Ref>",
			"        SegZkwTree(Ref __ref, int __row, int __column, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__ref, __row, __column);",
			"        }",
			"        ~SegZkwTree() { _clear(); }",
			"        void resize(int __row, int __column) {",
			"            _clear();",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_depth = 32 - (m_row > 1 ? std::__countl_zero<uint32_t>(m_row - 1) : 32);",
			"            m_sub.resize(1 << (m_depth + 1), nullptr);",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            _clear();",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_depth = 32 - (m_row > 1 ? std::__countl_zero<uint32_t>(m_row - 1) : 32);",
			"            auto build_leaf = [&](auto self, int left, int right, int row) {",
			"                if (left == right) return new _TpNode(__ref(row, left), nullptr, nullptr);",
			"                int mid = (left + right) / 2;",
			"                _TpNode *lchild = self(self, left, mid, row);",
			"                _TpNode *rchild = self(self, mid + 1, right, row);",
			"                return new _TpNode(m_op(lchild->val, rchild->val), lchild, rchild);",
			"            };",
			"            auto build_nonleaf = [&](auto self, _TpNode *lc, _TpNode *rc) -> _TpNode * {",
			"                _TpNode *p = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"                p->val = m_op(lc->val, rc->val);",
			"                if (lc->lchild) {",
			"                    p->lchild = self(self, lc->lchild, rc->lchild);",
			"                    p->rchild = self(self, lc->rchild, rc->rchild);",
			"                }",
			"                return p;",
			"            };",
			"            m_sub.resize(1 << (m_depth + 1));",
			"            for (int i = 0; i < m_row; i++) m_sub[i + (1 << m_depth)] = build_leaf(build_leaf, 0, m_column - 1, i);",
			"            for (int i = (1 << m_depth) - 1; i; i--) m_sub[i] = build_nonleaf(build_nonleaf, m_sub[i << 1], m_sub[i << 1 ^ 1]);",
			"        }",
			"        void add(int __row, int __column, _Tp __inc) {",
			"            for (int i = __row + (1 << m_depth); i; i >>= 1) _add(sub(i), 0, m_column - 1, __column, __inc);",
			"        }",
			"        _Tp query(int __row, int __column) const { return m_sub[__row] ? _query(m_sub[__row], 0, m_column - 1, __column) : m_defaultValue; }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const {",
			"            __row1 += 1 << m_depth;",
			"            __row2 += 1 << m_depth;",
			"            if (__row1 == __row2) return m_sub[__row1] ? _query(m_sub[__row1], 0, m_column - 1, __column1, __column2) : m_defaultValue;",
			"            _Tp res = m_sub[__row1] ? _query(m_sub[__row1], 0, m_column - 1, __column1, __column2) : m_defaultValue;",
			"            int j = 31 - std::__countl_zero<uint32_t>(__row1 ^ __row2);",
			"            for (int i = 0; i < j; i++)",
			"                if (!(__row1 >> i & 1)) res = m_op(res, m_sub[__row1 >> i ^ 1] ? _query(m_sub[__row1 >> i ^ 1], 0, m_column - 1, __column1, __column2) : m_defaultValue);",
			"            for (int i = j - 1; i >= 0; i--)",
			"                if (__row2 >> i & 1) res = m_op(res, m_sub[__row2 >> i ^ 1] ? _query(m_sub[__row2 >> i ^ 1], 0, m_column - 1, __column1, __column2) : m_defaultValue);",
			"            return m_op(res, m_sub[__row2] ? _query(m_sub[__row2], 0, m_column - 1, __column1, __column2) : m_defaultValue);",
			"        }",
			"        _Tp queryAll() const { return query(0, m_row - 1, 0, m_column - 1); }",
			"        int rowKth(int __row1, int __row2, _Tp __k) const {",
			"            static std::vector<_TpNode *> roots_plus;",
			"            roots_plus.clear();",
			"            __row1 += 1 << m_depth;",
			"            __row2 += 1 << m_depth;",
			"            if (__row1 < __row2) {",
			"                if (m_sub[__row1]) roots_plus.push_back(m_sub[__row1]);",
			"                int j = 31 - std::__countl_zero<uint32_t>(__row1 ^ __row2);",
			"                for (int i = 0; i < j; i++)",
			"                    if (!(__row1 >> i & 1) && m_sub[__row1 >> i ^ 1]) roots_plus.push_back(m_sub[__row1 >> i ^ 1]);",
			"                for (int i = j - 1; i >= 0; i--)",
			"                    if ((__row2 >> i & 1) && m_sub[__row2 >> i ^ 1]) roots_plus.push_back(m_sub[__row2 >> i ^ 1]);",
			"                if (m_sub[__row2]) roots_plus.push_back(m_sub[__row2]);",
			"            } else if (m_sub[__row1])",
			"                roots_plus.push_back(m_sub[__row1]);",
			"            int left = 0, right = m_column - 1;",
			"#define FILTER(vec, prop)                    \\",
			"    {                                        \\",
			"        int i = 0;                           \\",
			"        for (auto a : vec)                   \\",
			"            if (a->prop) vec[i++] = a->prop; \\",
			"        vec.resize(i);                       \\",
			"    }",
			"            while (left < right) {",
			"                _Tp sum = 0;",
			"                for (_TpNode *root : roots_plus) sum += root->lchild ? root->lchild->val : 0;",
			"                if (__k < sum) {",
			"                    right = (left + right) / 2;",
			"                    FILTER(roots_plus, lchild);",
			"                } else {",
			"                    left = (left + right) / 2 + 1;",
			"                    __k -= sum;",
			"                    FILTER(roots_plus, rchild);",
			"                }",
			"            }",
			"            return left;",
			"#undef FILTER",
			"        }",
			"    };",
			"    template <typename _Tp = int, typename _Operation = std::plus<_Tp>>",
			"    SegZkwTree(int, int, _Operation = _Operation(), _Tp = _Tp()) -> SegZkwTree<_Tp, _Operation>;",
			"    template <typename Ref, typename _Tp = typename std::iterator_traits<typename decltype(std::mem_fn(&Ref::operator()))::result_type>::value_type, typename _Operation = std::plus<_Tp>>",
			"    SegZkwTree(Ref, int, int, _Operation = _Operation(), std::enable_if_t<std::is_invocable_v<Ref, int>, _Tp> = _Tp()) -> SegZkwTree<_Tp, _Operation>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>, typename _Operation = std::plus<_Tp>>",
			"    SegZkwTree(Ref, int, int, _Operation = _Operation(), std::enable_if_t<std::is_invocable_v<Ref, int, int>, _Tp> = _Tp()) -> SegZkwTree<_Tp, _Operation>;",
			"}",
		],
		"description": "seg-zkwtree"
	},
	"sift heap":{
		"prefix": "SIFT",
		"body": [
			"namespace OY {",
			"    template <typename _Sequence>",
			"    struct SiftGetter {",
			"        _Sequence &m_sequence;",
			"        SiftGetter(_Sequence &__sequence) : m_sequence(__sequence) {}",
			"        auto &operator()(uint32_t __index) const { return m_sequence[__index]; }",
			"    };",
			"    template <typename _Mapping, typename _Compare = std::less<void>>",
			"    struct SiftHeap {",
			"        std::vector<uint32_t> m_heap;",
			"        std::vector<uint32_t> m_pos;",
			"        _Mapping m_map;",
			"        _Compare m_comp;",
			"        SiftHeap(uint32_t __n, _Mapping __map, _Compare __comp = _Compare()) : m_pos(__n, -1), m_map(__map), m_comp(__comp) { m_heap.reserve(__n); }",
			"        void siftUp(uint32_t __i) {",
			"            uint32_t curpos = m_pos[__i];",
			"            auto curvalue = m_map(__i);",
			"            for (uint32_t p; curpos && m_comp(m_map(p = m_heap[curpos - 1 >> 1]), curvalue); curpos = curpos - 1 >> 1) m_heap[m_pos[p] = curpos] = p;",
			"            m_heap[m_pos[__i] = curpos] = __i;",
			"        }",
			"        void siftDown(uint32_t __i) {",
			"            uint32_t curpos = m_pos[__i];",
			"            auto curvalue = m_map(__i);",
			"            for (uint32_t c; (c = curpos * 2 + 1) < m_heap.size(); curpos = c) {",
			"                if (c + 1 < m_heap.size() && m_comp(m_map(m_heap[c]), m_map(m_heap[c + 1]))) c++;",
			"                if (!m_comp(curvalue, m_map(m_heap[c]))) break;",
			"                m_pos[m_heap[curpos] = m_heap[c]] = curpos;",
			"            }",
			"            m_heap[m_pos[__i] = curpos] = __i;",
			"        }",
			"        void push(uint32_t __i) {",
			"            if (!~m_pos[__i]) {",
			"                m_pos[__i] = m_heap.size();",
			"                m_heap.push_back(__i);",
			"            }",
			"            siftUp(__i);",
			"        }",
			"        uint32_t top() const { return m_heap.front(); }",
			"        void pop() {",
			"            m_pos[m_heap.front()] = -1;",
			"            if (m_heap.size() > 1) {",
			"                m_pos[m_heap.back()] = 0;",
			"                m_heap.front() = m_heap.back();",
			"                m_heap.pop_back();",
			"                siftDown(m_heap.front());",
			"            } else",
			"                m_heap.pop_back();",
			"        }",
			"        bool empty() const { return m_heap.empty(); }",
			"        uint32_t size() const { return m_heap.size(); }",
			"    };",
			"    template <typename _Tp, typename _Compare>",
			"    SiftHeap(uint32_t, std::vector<_Tp> &, _Compare) -> SiftHeap<SiftGetter<std::vector<_Tp>>, _Compare>;",
			"    template <typename _Tp,uint32_t _N, typename _Compare>",
			"    SiftHeap(uint32_t, _Tp(&)[_N], _Compare) -> SiftHeap<SiftGetter<_Tp[_N]>, _Compare>;",
			"}",
		],
		"description": "Sift Heap"
	},
	"size balanced tree":{
		"prefix": "SBT",
		"body": [
			"namespace OY {",
			"    struct SizeBalancedTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _SizeBalancedTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SizeBalancedTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = SizeBalancedTreeMultisetTag>",
			"    class SizeBalancedTree {",
			"        struct node : _SizeBalancedTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int lchild_weight(node *p) { return p && p->lchild ? p->lchild->subtree_weight : 0; }",
			"        static int rchild_weight(node *p) { return p && p->rchild ? p->rchild->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return r;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return r;",
			"        }",
			"        static node *lbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->lchild) < lchild_weight(cur->rchild))",
			"                cur = rlrotate(cur);",
			"            else if (subtree_weight(cur->lchild) < rchild_weight(cur->rchild))",
			"                cur = lrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *rbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->rchild) < rchild_weight(cur->lchild))",
			"                cur = lrrotate(cur);",
			"            else if (subtree_weight(cur->rchild) < lchild_weight(cur->lchild))",
			"                cur = rrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur) return nullptr;",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else {",
			"                cur->lchild = deleteMin(cur->lchild, res);",
			"                return update(cur);",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        SizeBalancedTree(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return _Tag::multi_key || res ? rbalance(cur) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return _Tag::multi_key || res ? lbalance(cur) : cur;",
			"                };",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    cur->rchild = self(self, cur->rchild);",
			"                } else if (!cur->rchild) {",
			"                    delete cur;",
			"                    return cur->lchild;",
			"                } else {",
			"                    node *res;",
			"                    cur->rchild = deleteMin(cur->rchild, res);",
			"                    res->lchild = cur->lchild;",
			"                    res->rchild = cur->rchild;",
			"                    delete cur;",
			"                    cur = res;",
			"                }",
			"                return update(cur);",
			"            };",
			"            int old_weight = size();",
			"            m_root = dfs(dfs, m_root);",
			"            return old_weight != size();",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace SizeBalancedTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = SizeBalancedTree<_Tp, bool, _Compare, SizeBalancedTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = SizeBalancedTree<_Tp, bool, _Compare, SizeBalancedTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = SizeBalancedTree<_Tp, _Fp, _Compare, SizeBalancedTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "size balanced tree"
	},
	"size balanced segtree":{
		"prefix": "SBSEG",
		"body": [
			"namespace OY {",
			"    struct SizeBalancedSegTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedSegTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedSegTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _SizeBalancedSegTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SizeBalancedSegTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = SizeBalancedSegTreeMultisetTag>",
			"    class SizeBalancedSegTree {",
			"#pragma pack(4)",
			"        struct node : _SizeBalancedSegTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        struct treenode : MemoryPool<treenode> {",
			"            node *root;",
			"            treenode *lchild;",
			"            treenode *rchild;",
			"            treenode() : root(nullptr), lchild(nullptr), rchild(nullptr) {}",
			"        };",
			"#pragma pack()",
			"        treenode *m_root;",
			"        _Compare m_comp;",
			"        int m_length;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int lchild_weight(node *p) { return p && p->lchild ? p->lchild->subtree_weight : 0; }",
			"        static int rchild_weight(node *p) { return p && p->rchild ? p->rchild->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return r;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return r;",
			"        }",
			"        static node *lbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->lchild) < lchild_weight(cur->rchild))",
			"                cur = rlrotate(cur);",
			"            else if (subtree_weight(cur->lchild) < rchild_weight(cur->rchild))",
			"                cur = lrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *rbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->rchild) < rchild_weight(cur->lchild))",
			"                cur = lrrotate(cur);",
			"            else if (subtree_weight(cur->rchild) < lchild_weight(cur->lchild))",
			"                cur = rrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur) return nullptr;",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else {",
			"                cur->lchild = deleteMin(cur->lchild, res);",
			"                return update(cur);",
			"            }",
			"        }",
			"        void _clear() {",
			"            m_root = nullptr;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __treeCount, int __nodeCount) {",
			"            MemoryPool<treenode>::_reserve(__treeCount);",
			"            MemoryPool<node>::_reserve(__nodeCount);",
			"        }",
			"        SizeBalancedSegTree(int __n = 0, _Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) { resize(__n); }",
			"        template <typename _Iterator>",
			"        SizeBalancedSegTree(_Iterator __first, _Iterator __last, _Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) { reset(__first, __last); }",
			"        ~SizeBalancedSegTree() { _clear(); }",
			"        void resize(int __n) {",
			"            _clear();",
			"            m_length = __n;",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            static_assert(!_Tag::is_map);",
			"            _clear();",
			"            std::vector<_Tp> data(__first, __last);",
			"            m_length = __last - __first;",
			"            auto makenode = [&](auto self, auto first, auto last) -> node * {",
			"                if (first == last) return nullptr;",
			"                auto mid = first + (last - first) / 2;",
			"                return new node{*mid, int(last - first), self(self, first, mid), self(self, mid + 1, last)};",
			"            };",
			"            auto dfs = [&](auto self, auto first, auto last) -> treenode * {",
			"                if (first == last) return nullptr;",
			"                treenode *p = new treenode;",
			"                if (last - first > 1) {",
			"                    auto mid = first + (last - first + 1) / 2;",
			"                    p->lchild = self(self, first, mid);",
			"                    p->rchild = self(self, mid, last);",
			"                    std::inplace_merge(first, mid, last);",
			"                }",
			"                p->root = makenode(makenode, first, last);",
			"                return p;",
			"            };",
			"            m_root = dfs(dfs, data.data(), data.data() + m_length);",
			"        }",
			"        template <typename... Args>",
			"        void insert(int __i, _Tp __key, Args... __args) {",
			"            auto dfs = [&](auto self, treenode *cur, int left, int right) -> treenode * {",
			"                if (!cur) cur = new treenode;",
			"                cur->root = insert(cur->root, __key, __args...);",
			"                if (left < right) {",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        cur->lchild = self(self, cur->lchild, left, mid);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, mid + 1, right);",
			"                }",
			"                return cur;",
			"            };",
			"            m_root = dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void update(int __i, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, treenode *cur, int left, int right) {",
			"                if (!cur) cur = new treenode;",
			"                cur->root = update(cur->root, __key, __value);",
			"                if (left < right) {",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        cur->lchild = self(self, cur->lchild, left, mid);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, mid + 1, right);",
			"                }",
			"                return cur;",
			"            };",
			"            m_root = dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void erase(int __i, _Tp __key) {",
			"            auto dfs = [&](auto self, treenode *cur, int left, int right) -> treenode * {",
			"                if (!cur) return nullptr;",
			"                cur->root = erase(cur->root, __key);",
			"                if (left < right) {",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        cur->lchild = self(self, cur->lchild, left, mid);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, mid + 1, right);",
			"                }",
			"                return cur;",
			"            };",
			"            m_root = dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        int rank(int __left, int __right, _Tp __key) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += rank(root, __key);",
			"            return sum;",
			"        }",
			"        node *kth(int __left, int __right, int __k, _Tp __min, _Tp __max) const {",
			"            std::vector<node *> roots = find_roots(__left, __right);",
			"            int len = __max - __min;",
			"            while (len) {",
			"                int half = len + 1 >> 1;",
			"                auto mid = __min + half;",
			"                int sum = 0;",
			"                for (node *root : roots) sum += rank(root, mid);",
			"                if (sum > __k) {",
			"                    __max = mid - 1;",
			"                    len = half - 1;",
			"                } else {",
			"                    __min = mid;",
			"                    len -= half;",
			"                }",
			"            }",
			"            for (node *root : roots)",
			"                if (auto it = find(root, __min)) return it;",
			"            return nullptr;",
			"        }",
			"        node *lower_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = lower_bound(root, __key); it && (!res || m_comp(it->key, res->key))) res = it;",
			"            return res;",
			"        }",
			"        node *upper_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = upper_bound(root, __key); it && (!res || m_comp(it->key, res->key))) res = it;",
			"            return res;",
			"        }",
			"        node *smaller_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = smaller_bound(root, __key); it && (!res || m_comp(res->key, it->key))) res = it;",
			"            return res;",
			"        }",
			"        int size(int __left, int __right) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += size(root);",
			"            return sum;",
			"        }",
			"        bool empty(int __left, int __right) const {",
			"            for (auto root : find_roots(__left, __right))",
			"                if (size(root)) return false;",
			"            return true;",
			"        }",
			"        int count(int __left, int __right, _Tp __key) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += count(root, __key);",
			"            return sum;",
			"        }",
			"        std::vector<node *> find_roots(int __left, int __right) const {",
			"            static std::vector<node *> res;",
			"            res.clear();",
			"            auto dfs = [&](auto self, treenode *cur, int left, int right) {",
			"                if (!cur) return;",
			"                if (left >= __left && right <= __right) {",
			"                    if (cur->root) res.push_back(cur->root);",
			"                } else {",
			"                    int mid = (left + right) / 2;",
			"                    if (__left <= mid) self(self, cur->lchild, left, mid);",
			"                    if (__right > mid) self(self, cur->rchild, mid + 1, right);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"            return res;",
			"        }",
			"        template <typename... Args>",
			"        node *insert(node *__root, _Tp __key, Args... __args) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return _Tag::multi_key || res ? rbalance(cur) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return _Tag::multi_key || res ? lbalance(cur) : cur;",
			"                };",
			"            };",
			"            return dfs(dfs, __root);",
			"        }",
			"        node *update(node *__root, _Tp __key, _Fp __value) {",
			"            if (auto p = find(__root, __key))",
			"                p->value = __value;",
			"            else",
			"                __root = insert(__root, __key, __value);",
			"            return __root;",
			"        }",
			"        node *erase(node *__cur, _Tp __key) {",
			"            if (!__cur)",
			"                return nullptr;",
			"            else if (m_comp(__key, __cur->key)) {",
			"                __cur->lchild = erase(__cur->lchild, __key);",
			"            } else if (m_comp(__cur->key, __key)) {",
			"                __cur->rchild = erase(__cur->rchild, __key);",
			"            } else if (!__cur->rchild) {",
			"                delete __cur;",
			"                return __cur->lchild;",
			"            } else {",
			"                node *res;",
			"                __cur->rchild = deleteMin(__cur->rchild, res);",
			"                res->lchild = __cur->lchild;",
			"                res->rchild = __cur->rchild;",
			"                delete __cur;",
			"                __cur = res;",
			"            }",
			"            return update(__cur);",
			"        }",
			"        int rank(node *__root, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = __root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        node *kth(node *__root, int __k) const {",
			"            node *cur = __root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        node *find(node *__root, _Tp __key) const {",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        node *lower_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        node *upper_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        node *smaller_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(node *__root) const { return subtree_weight(__root); }",
			"        bool empty(node *__root) const { return !size(__root); }",
			"        int count(node *__root, _Tp __key) const {",
			"            auto it1 = lower_bound(__root, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__root, __key);",
			"            if (!it2)",
			"                return size(__root) - rank(__root, __key);",
			"            else",
			"                return rank(__root, it2->key) - rank(__root, __key);",
			"        }",
			"    };",
			"    namespace SizeBalancedSegTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = SizeBalancedSegTree<_Tp, bool, _Compare, SizeBalancedSegTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = SizeBalancedSegTree<_Tp, bool, _Compare, SizeBalancedSegTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = SizeBalancedSegTree<_Tp, _Fp, _Compare, SizeBalancedSegTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "size balanced segtree"
	},
	"size balanced zkwtree":{
		"prefix": "SBZKW",
		"body": [
			"namespace OY {",
			"    struct SizeBalancedZkwTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedZkwTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedZkwTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _SizeBalancedZkwTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SizeBalancedZkwTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = SizeBalancedZkwTreeMultisetTag>",
			"    class SizeBalancedZkwTree {",
			"#pragma pack(4)",
			"        struct node : _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_sub;",
			"        _Compare m_comp;",
			"        int m_length;",
			"        int m_depth;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int lchild_weight(node *p) { return p && p->lchild ? p->lchild->subtree_weight : 0; }",
			"        static int rchild_weight(node *p) { return p && p->rchild ? p->rchild->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return r;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return r;",
			"        }",
			"        static node *lbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->lchild) < lchild_weight(cur->rchild))",
			"                cur = rlrotate(cur);",
			"            else if (subtree_weight(cur->lchild) < rchild_weight(cur->rchild))",
			"                cur = lrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *rbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->rchild) < rchild_weight(cur->lchild))",
			"                cur = lrrotate(cur);",
			"            else if (subtree_weight(cur->rchild) < lchild_weight(cur->lchild))",
			"                cur = rrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur) return nullptr;",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else {",
			"                cur->lchild = deleteMin(cur->lchild, res);",
			"                return update(cur);",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        SizeBalancedZkwTree(int __n = 0, _Compare __comp = _Compare()) : m_comp(__comp) { resize(__n); }",
			"        template <typename _Iterator>",
			"        SizeBalancedZkwTree(_Iterator __first, _Iterator __last, _Compare __comp = _Compare()) : m_comp(__comp) { reset(__first, __last); }",
			"        ~SizeBalancedZkwTree() { clear(); }",
			"        void resize(int __n) {",
			"            clear();",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32);",
			"            m_sub.assign(1 << (m_depth + 1), nullptr);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            static_assert(!_Tag::is_map);",
			"            clear();",
			"            auto makenode = [&](auto self, auto first, auto last) -> node * {",
			"                if (first == last) return nullptr;",
			"                auto mid = first + (last - first) / 2;",
			"                return new node{*mid, int(last - first), self(self, first, mid), self(self, mid + 1, last)};",
			"            };",
			"            std::vector<_Tp> data(__first, __last);",
			"            m_length = data.size();",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32);",
			"            m_sub.assign(1 << (m_depth + 1), nullptr);",
			"            for (int d = m_depth, len = 1; d >= 0; d--, len <<= 1) {",
			"                int it = 0;",
			"                int i = 1 << d, o = m_length - len;",
			"                for (; it <= o; i++, it += len) {",
			"                    if (len > 1) std::inplace_merge(data.data() + it, data.data() + it + len / 2, data.data() + it + len);",
			"                    m_sub[i] = makenode(makenode, data.data() + it, data.data() + it + len);",
			"                }",
			"                if (len > 1 and m_length - it > len / 2) std::inplace_merge(data.data() + it, data.data() + it + len / 2, data.data() + m_length);",
			"                m_sub[i] = makenode(makenode, data.data() + it, data.data() + m_length);",
			"            }",
			"        }",
			"        void clear() {",
			"            m_sub.clear();",
			"        }",
			"        template <typename... Args>",
			"        void insert(int __i, _Tp __key, Args... __args) {",
			"            for (int i = __i + (1 << m_depth); i; i >>= 1) m_sub[i] = insert(m_sub[i], __key, __args...);",
			"        }",
			"        void update(int __i, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            for (int i = __i + (1 << m_depth); i; i >>= 1) m_sub[i] = update(m_sub[i], __key, __value);",
			"        }",
			"        void erase(int __i, _Tp __key) {",
			"            for (int i = __i + (1 << m_depth); i; i >>= 1) m_sub[i] = erase(m_sub[i], __key);",
			"        }",
			"        int rank(int __left, int __right, _Tp __key) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += rank(root, __key);",
			"            return sum;",
			"        }",
			"        node *kth(int __left, int __right, int __k, _Tp __min, _Tp __max) const {",
			"            std::vector<node *> roots = find_roots(__left, __right);",
			"            int len = __max - __min;",
			"            while (len) {",
			"                int half = len + 1 >> 1;",
			"                auto mid = __min + half;",
			"                int sum = 0;",
			"                for (node *root : roots) sum += rank(root, mid);",
			"                if (sum > __k) {",
			"                    __max = mid - 1;",
			"                    len = half - 1;",
			"                } else {",
			"                    __min = mid;",
			"                    len -= half;",
			"                }",
			"            }",
			"            for (node *root : roots)",
			"                if (auto it = find(root, __min)) return it;",
			"            return nullptr;",
			"        }",
			"        node *lower_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = lower_bound(root, __key); it && (!res || m_comp(it->key, res->key))) res = it;",
			"            return res;",
			"        }",
			"        node *upper_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = upper_bound(root, __key); it && (!res || m_comp(it->key, res->key))) res = it;",
			"            return res;",
			"        }",
			"        node *smaller_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = smaller_bound(root, __key); it && (!res || m_comp(res->key, it->key))) res = it;",
			"            return res;",
			"        }",
			"        int size(int __left, int __right) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += size(root);",
			"            return sum;",
			"        }",
			"        bool empty(int __left, int __right) const {",
			"            for (auto root : find_roots(__left, __right))",
			"                if (size(root)) return false;",
			"            return true;",
			"        }",
			"        int count(int __left, int __right, _Tp __key) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += count(root, __key);",
			"            return sum;",
			"        }",
			"        std::vector<node *> find_roots(int __left, int __right) const {",
			"            static std::vector<node *> res;",
			"            res.clear();",
			"            __left += 1 << m_depth;",
			"            __right += 1 << m_depth;",
			"            if (__left < __right) {",
			"                if (m_sub[__left]) res.push_back(m_sub[__left]);",
			"                int j = 31 - std::__countl_zero<uint32_t>(__left ^ __right);",
			"                for (int i = 0; i < j; i++)",
			"                    if (!(__left >> i & 1) && m_sub[__left >> i ^ 1]) res.push_back(m_sub[__left >> i ^ 1]);",
			"                for (int i = j - 1; i >= 0; i--)",
			"                    if ((__right >> i & 1) && m_sub[__right >> i ^ 1]) res.push_back(m_sub[__right >> i ^ 1]);",
			"                if (m_sub[__right]) res.push_back(m_sub[__right]);",
			"            } else if (m_sub[__left])",
			"                res.push_back(m_sub[__left]);",
			"            return res;",
			"        }",
			"        template <typename... Args>",
			"        node *insert(node *__root, _Tp __key, Args... __args) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return _Tag::multi_key || res ? rbalance(cur) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return _Tag::multi_key || res ? lbalance(cur) : cur;",
			"                };",
			"            };",
			"            return dfs(dfs, __root);",
			"        }",
			"        node *update(node *__root, _Tp __key, _Fp __value) {",
			"            if (auto p = find(__root, __key))",
			"                p->value = __value;",
			"            else",
			"                __root = insert(__root, __key, __value);",
			"            return __root;",
			"        }",
			"        node *erase(node *__cur, _Tp __key) {",
			"            if (!__cur)",
			"                return nullptr;",
			"            else if (m_comp(__key, __cur->key))",
			"                __cur->lchild = erase(__cur->lchild, __key);",
			"            else if (m_comp(__cur->key, __key))",
			"                __cur->rchild = erase(__cur->rchild, __key);",
			"            else if (!__cur->rchild) {",
			"                delete __cur;",
			"                return __cur->lchild;",
			"            } else {",
			"                node *res;",
			"                __cur->rchild = deleteMin(__cur->rchild, res);",
			"                res->lchild = __cur->lchild;",
			"                res->rchild = __cur->rchild;",
			"                delete __cur;",
			"                __cur = res;",
			"            }",
			"            return update(__cur);",
			"        }",
			"        int rank(node *__root, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = __root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        node *kth(node *__root, int __k) const {",
			"            node *cur = __root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        node *find(node *__root, _Tp __key) const {",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        node *lower_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        node *upper_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        node *smaller_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(node *__root) const { return subtree_weight(__root); }",
			"        bool empty(node *__root) const { return !size(__root); }",
			"        int count(node *__root, _Tp __key) const {",
			"            auto it1 = lower_bound(__root, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__root, __key);",
			"            if (!it2)",
			"                return size(__root) - rank(__root, __key);",
			"            else",
			"                return rank(__root, it2->key) - rank(__root, __key);",
			"        }",
			"    };",
			"    namespace SizeBalancedZkwTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = SizeBalancedZkwTree<_Tp, bool, _Compare, SizeBalancedZkwTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = SizeBalancedZkwTree<_Tp, bool, _Compare, SizeBalancedZkwTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = SizeBalancedZkwTree<_Tp, _Fp, _Compare, SizeBalancedZkwTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "size balanced zkwtree"
	},
	"skip list":{
		"prefix": "SKIP",
		"body": [
			"namespace OY {",
			"    struct SkipListSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SkipListMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SkipListMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, typename _Tag>",
			"    struct _SkipListNode;",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SkipListNode<_Tp, _Fp, SkipListSetTag> { _Tp key; };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SkipListNode<_Tp, _Fp, SkipListMultisetTag> {",
			"        _Tp key;",
			"        int _node_weight;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SkipListNode<_Tp, _Fp, SkipListMapTag> {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp = int, typename _Compare = std::less<_Tp>, typename _Tag = SkipListMultisetTag>",
			"    class SkipList {",
			"        struct node : _SkipListNode<_Tp, _Fp, _Tag> {",
			"            constexpr int node_weight() const {",
			"                if constexpr (_Tag::multi_key)",
			"                    return this->_node_weight;",
			"                else",
			"                    return 1;",
			"            }",
			"            struct node_next {",
			"                node *pointer;",
			"                int distance;",
			"            };",
			"            std::vector<node_next> next;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"        node *m_head;",
			"        _Compare m_comp;",
			"        int m_height;",
			"        int m_size;",
			"        static bool testJump() { return rand() % 100 < 53; }",
			"        template <typename... Args>",
			"        int _insert(node *cur, int h, node *&res, _Tp __key, Args... __args) {",
			"            int distance = 0;",
			"            while (true) {",
			"                auto &&[nxt, dis] = cur->next[h];",
			"                if (!nxt || m_comp(__key, nxt->key))",
			"                    break;",
			"                else if (m_comp(nxt->key, __key)) {",
			"                    distance += dis + nxt->node_weight();",
			"                    cur = nxt;",
			"                } else {",
			"                    if constexpr (_Tag::multi_key) {",
			"                        res = nxt;",
			"                        res->_node_weight++;",
			"                        return distance + dis;",
			"                    } else",
			"                        return -1;",
			"                }",
			"            }",
			"            if (h) {",
			"                int next_level_distance = _insert(cur, h - 1, res, __key, __args...);",
			"                if (!res) return -1;",
			"                auto &&[nxt, dis] = cur->next[h];",
			"                dis++;",
			"                if (next_level_distance < 0) return -1;",
			"                if (!testJump()) {",
			"                    res->next.shrink_to_fit();",
			"                    return -1;",
			"                }",
			"                res->next.push_back({nxt, dis - next_level_distance - res->node_weight()});",
			"                cur->next[h] = {res, next_level_distance};",
			"                return distance + next_level_distance;",
			"            } else {",
			"                node *nxt = cur->next[h].pointer;",
			"                res = new node{__key, __args..., {{nxt, 0}}};",
			"                cur->next[h] = {res, 0};",
			"                return distance;",
			"            }",
			"        }",
			"        node *_erase(node *cur, int h, _Tp key) {",
			"            while (node *nxt = cur->next[h].pointer) {",
			"                if (!m_comp(nxt->key, key)) break;",
			"                cur = nxt;",
			"            }",
			"            if (h) {",
			"                if (node *res = _erase(cur, h - 1, key)) {",
			"                    if (cur->next[h].pointer != res)",
			"                        cur->next[h].distance--;",
			"                    else if (!_Tag::multi_key || !res->node_weight())",
			"                        cur->next[h] = {res->next[h].pointer, cur->next[h].distance + res->next[h].distance};",
			"                    return res;",
			"                } else",
			"                    return nullptr;",
			"            } else if (node *nxt = cur->next[h].pointer; !nxt || m_comp(key, nxt->key))",
			"                return nullptr;",
			"            else {",
			"                if constexpr (_Tag::multi_key) nxt->_node_weight--;",
			"                if (!_Tag::multi_key || !nxt->node_weight()) cur->next[h].pointer = nxt->next[h].pointer;",
			"                return nxt;",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        SkipList() : m_height(1), m_size(0) {",
			"            m_head = new node;",
			"            m_head->next.push_back({nullptr, 0});",
			"        }",
			"        void clear() {",
			"            m_head = nullptr;",
			"        }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            node *res = nullptr;",
			"            int distance;",
			"            if constexpr (_Tag::multi_key)",
			"                distance = _insert(m_head, m_height - 1, res, __key, __args..., 1);",
			"            else",
			"                distance = _insert(m_head, m_height - 1, res, __key, __args...);",
			"            m_size += bool(res);",
			"            if (distance < 0 || !testJump()) return;",
			"            m_height++;",
			"            m_head->next.push_back({res, distance});",
			"            res->next.push_back({nullptr, m_size - distance - res->node_weight()});",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            if (node *res = _erase(m_head, m_height - 1, __key)) {",
			"                if (!_Tag::multi_key || !res->node_weight()) delete res;",
			"                m_size--;",
			"                return true;",
			"            } else",
			"                return false;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            node *cur = m_head;",
			"            int ord = 0;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer && m_comp(cur->next[h].pointer->key, __key)) {",
			"                    ord += cur->next[h].distance + cur->next[h].pointer->node_weight();",
			"                    cur = cur->next[h].pointer;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            if (__k < 0 || __k >= m_size) return nullptr;",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].distance <= __k) {",
			"                    __k -= cur->next[h].distance;",
			"                    if (__k -= cur->next[h].pointer->node_weight(); __k < 0)",
			"                        return cur->next[h].pointer;",
			"                    else",
			"                        cur = cur->next[h].pointer;",
			"                }",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer) {",
			"                    if (m_comp(cur->next[h].pointer->key, __key))",
			"                        cur = cur->next[h].pointer;",
			"                    else if (!m_comp(__key, cur->next[h].pointer->key))",
			"                        return cur->next[h].pointer;",
			"                    else",
			"                        break;",
			"                }",
			"            return nullptr;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer && m_comp(cur->next[h].pointer->key, __key)) cur = cur->next[h].pointer;",
			"            return cur;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer) {",
			"                    if (m_comp(cur->next[h].pointer->key, __key))",
			"                        cur = cur->next[h].pointer;",
			"                    else if (!m_comp(__key, cur->next[h].pointer->key))",
			"                        return cur->next[h].pointer;",
			"                    else",
			"                        break;",
			"                }",
			"            return nullptr;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer && !m_comp(__key, cur->next[h].pointer->key)) cur = cur->next[h].pointer;",
			"            return cur->next[0].pointer;",
			"        }",
			"        int size() const { return m_size; }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            if (auto it = find(__key))",
			"                return it->node_weight();",
			"            else",
			"                return 0;",
			"        }",
			"    };",
			"    namespace SkipListContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = SkipList<_Tp, bool, _Compare, SkipListSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = SkipList<_Tp, bool, _Compare, SkipListMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = SkipList<_Tp, _Fp, _Compare, SkipListMapTag>;",
			"    }",
			"}",
		],
		"description": "skip list"
	},
	"splay":{
		"prefix": "SPLAY",
		"body": [
			"namespace OY {",
			"    struct SplaySetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SplayMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SplayMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _SplayNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SplayNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = SplayMultisetTag>",
			"    class Splay {",
			"        struct node : _SplayNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node*)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        int m_state;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            if (p) p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *rrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *s = q->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            q->lchild = s->rchild;",
			"            s->rchild = update(q);",
			"            return s;",
			"        }",
			"        static node *llrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *s = q->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            q->rchild = s->lchild;",
			"            s->lchild = update(q);",
			"            return s;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return r;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return r;",
			"        }",
			"        node *update_from_lchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 1;",
			"            if (m_state == 3) {",
			"                m_state = 0;",
			"                return rrrotate(cur);",
			"            } else if (m_state == 5) {",
			"                m_state = 0;",
			"                return lrrotate(cur);",
			"            } else if (m_state == 1 && cur == root)",
			"                return rrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *update_from_rchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 2;",
			"            if (m_state == 4) {",
			"                m_state = 0;",
			"                return rlrotate(cur);",
			"            } else if (m_state == 6) {",
			"                m_state = 0;",
			"                return llrotate(cur);",
			"            } else if (m_state == 2 && cur == root)",
			"                return lrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *splay_max(node *cur, node *const &root) {",
			"            if (cur->rchild) {",
			"                cur->rchild = splay_max(cur->rchild, root);",
			"                m_state++;",
			"                if (m_state == 2) {",
			"                    m_state = 0;",
			"                    return llrotate(cur);",
			"                } else if (m_state == 1 && cur == root)",
			"                    return lrotate(cur);",
			"            } else",
			"                m_state = 0;",
			"            return cur;",
			"        }",
			"        node *splay_kth(node *cur, node *const &root, int k) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (k < subtree_weight(cur->lchild)) {",
			"                cur->lchild = splay_kth(cur->lchild, root, k);",
			"                return update_from_lchild(cur, root);",
			"            } else if (k -= subtree_weight(cur->lchild); k--) {",
			"                cur->rchild = splay_kth(cur->rchild, root, k);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        template <typename... Args>",
			"        node *splay_insert(node *cur, node *const &root, _Tp key, Args... args) {",
			"            if (!cur) {",
			"                m_state = 0;",
			"                return new node{key, args..., 1, nullptr, nullptr};",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_insert(cur->lchild, root, key, args...);",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                if constexpr (!_Tag::multi_key) {",
			"                    if (!m_comp(cur->key, key)) {",
			"                        m_state = -1;",
			"                        return cur;",
			"                    }",
			"                }",
			"                cur->rchild = splay_insert(cur->rchild, root, key, args...);",
			"                return update_from_rchild(cur, root);",
			"            }",
			"        }",
			"        node *splay_find(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_find(cur->lchild, root, key);",
			"                return update_from_lchild(cur, root);",
			"            } else if (m_comp(cur->key, key)) {",
			"                cur->rchild = splay_find(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        node *splay_smaller_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(cur->key, key)) {",
			"                cur->rchild = splay_smaller_bound(cur->rchild, root, key);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                cur->lchild = splay_smaller_bound(cur->lchild, root, key);",
			"                return update_from_lchild(cur, root);",
			"            }",
			"        }",
			"        node *splay_upper_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_upper_bound(cur->lchild, root, key);",
			"                if (m_state < 0) {",
			"                    m_state = 0;",
			"                    return cur;",
			"                }",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                cur->rchild = splay_upper_bound(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            }",
			"        }",
			"        node *splay_lower_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (!m_comp(cur->key, key)) {",
			"                cur->lchild = splay_lower_bound(cur->lchild, root, key);",
			"                if (m_state < 0) {",
			"                    m_state = 0;",
			"                    return cur;",
			"                }",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                cur->rchild = splay_lower_bound(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        Splay(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(Args... __args) { m_root = update(splay_insert(m_root, m_root, __args...)); }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            m_root = update(splay_find(m_root, m_root, __key));",
			"            if (!~m_state) return false;",
			"            delete m_root;",
			"            node *r = m_root->rchild;",
			"            if (m_root->lchild) {",
			"                m_root = update(splay_max(m_root->lchild, m_root->lchild));",
			"                if (r) {",
			"                    m_root->rchild = r;",
			"                    update(m_root);",
			"                }",
			"            } else",
			"                m_root = r;",
			"            return true;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) {",
			"            m_root = update(splay_lower_bound(m_root, m_root, __key));",
			"            return ~m_state ? subtree_weight(m_root->lchild) : subtree_weight(m_root);",
			"        }",
			"        const node *kth(int __k) {",
			"            m_root = update(splay_kth(m_root, m_root, __k));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        const node *find(_Tp __key) {",
			"            m_root = update(splay_find(m_root, m_root, __key));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) {",
			"            m_root = update(splay_lower_bound(m_root, m_root, __key));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        const node *upper_bound(_Tp __key) {",
			"            m_root = update(splay_upper_bound(m_root, m_root, __key));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        const node *smaller_bound(_Tp __key) {",
			"            m_root = update(splay_smaller_bound(m_root, m_root, __key));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) {",
			"            if (!(m_root = update(lower_bound(m_root, m_root, __key)))) return 0;",
			"            int smaller = subtree_weight(m_root->lchild);",
			"            if (!(m_root = update(upper_bound(m_root, m_root, __key))))",
			"                return size() - smaller;",
			"            else",
			"                return subtree_weight(m_root->lchild) - smaller;",
			"        }",
			"    };",
			"    namespace SplayContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = Splay<_Tp, bool, _Compare, SplaySetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = Splay<_Tp, bool, _Compare, SplayMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = Splay<_Tp, _Fp, _Compare, SplayMapTag>;",
			"    }",
			"}",
		],
		"description": "splay"
	},
	"splay array":{
		"prefix": "SPLAY",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    class SplayArray {",
			"        struct node : MemoryPool<node> {",
			"            _Tp key;",
			"            bool reversed;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            node() = default;",
			"            void reverse() { reversed = reversed ? false : true; }",
			"            void push_down() {",
			"                reverse();",
			"                std::swap(lchild, rchild);",
			"                if (lchild) lchild->reverse();",
			"                if (rchild) rchild->reverse();",
			"            }",
			"        };",
			"        node *m_root;",
			"        int m_state;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            if (p) p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *rrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *s = q->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            q->lchild = s->rchild;",
			"            s->rchild = update(q);",
			"            return s;",
			"        }",
			"        static node *llrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *s = q->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            q->rchild = s->lchild;",
			"            s->lchild = update(q);",
			"            return s;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *s = q->rchild;",
			"            p->lchild = s->rchild;",
			"            s->rchild = update(p);",
			"            q->rchild = s->lchild;",
			"            s->lchild = update(q);",
			"            return s;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *s = q->lchild;",
			"            p->rchild = s->lchild;",
			"            s->lchild = update(p);",
			"            q->lchild = s->rchild;",
			"            s->rchild = update(q);",
			"            return s;",
			"        }",
			"        node *update_from_lchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 1;",
			"            if (m_state == 3) {",
			"                m_state = 0;",
			"                return rrrotate(cur);",
			"            } else if (m_state == 5) {",
			"                m_state = 0;",
			"                return lrrotate(cur);",
			"            } else if (m_state == 1 && cur == root)",
			"                return rrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *update_from_rchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 2;",
			"            if (m_state == 4) {",
			"                m_state = 0;",
			"                return rlrotate(cur);",
			"            } else if (m_state == 6) {",
			"                m_state = 0;",
			"                return llrotate(cur);",
			"            } else if (m_state == 2 && cur == root)",
			"                return lrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *splay_max(node *cur, node *const &root) {",
			"            if (cur->reversed) cur->push_down();",
			"            if (cur->rchild) {",
			"                cur->rchild = splay_max(cur->rchild, root);",
			"                if (++m_state == 2) {",
			"                    m_state = 0;",
			"                    return llrotate(cur);",
			"                } else if (m_state == 1 && cur == root)",
			"                    return lrotate(cur);",
			"            } else",
			"                m_state = 0;",
			"            return cur;",
			"        }",
			"        node *splay_min(node *cur, node *const &root) {",
			"            if (cur->reversed) cur->push_down();",
			"            if (cur->lchild) {",
			"                cur->lchild = splay_min(cur->lchild, root);",
			"                if (++m_state == 2) {",
			"                    m_state = 0;",
			"                    return rrrotate(cur);",
			"                } else if (m_state == 1 && cur == root)",
			"                    return rrotate(cur);",
			"            } else",
			"                m_state = 0;",
			"            return cur;",
			"        }",
			"        node *splay_kth(node *cur, node *const &root, int k) {",
			"            if (cur->reversed) cur->push_down();",
			"            if (k < subtree_weight(cur->lchild)) {",
			"                cur->lchild = splay_kth(cur->lchild, root, k);",
			"                return update_from_lchild(cur, root);",
			"            } else if (k -= subtree_weight(cur->lchild); k) {",
			"                cur->rchild = splay_kth(cur->rchild, root, k - 1);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        node *make_tree(_Iterator first, _Iterator last) {",
			"            auto _make_tree = [](auto self, _Iterator first, _Iterator last) -> node * {",
			"                if (first == last) return nullptr;",
			"                if (first + 1 == last) return new node{{}, *first, false, 1, nullptr, nullptr};",
			"                _Iterator mid = first + (last - first) / 2;",
			"                node *p = new node{{}, *mid, false, 1, self(self, first, mid), self(self, mid + 1, last)};",
			"                return update(p);",
			"            };",
			"            return _make_tree(_make_tree, first, last);",
			"        }",
			"        void _clear(node *cur) {}",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        SplayArray() : m_root(nullptr) {}",
			"        template <typename _Iterator>",
			"        SplayArray(_Iterator __first, _Iterator __last) : m_root(make_tree(__first, __last)) {}",
			"        void clear() {",
			"            if (m_root) _clear(m_root);",
			"            m_root = nullptr;",
			"        }",
			"        void insert(int __pos, _Tp __key) {",
			"            if (!__pos)",
			"                push_front(__key);",
			"            else if (__pos == size())",
			"                push_back(__key);",
			"            else {",
			"                m_root = splay_kth(m_root, m_root, __pos);",
			"                node *p = new node{{}, __key, false, 1, m_root->lchild, nullptr};",
			"                m_root->lchild = nullptr;",
			"                p->rchild = update(m_root);",
			"                m_root = update(p);",
			"            }",
			"        }",
			"        void insert(int __pos, SplayArray<_Tp> &__toInsert) {",
			"            if (__pos == size())",
			"                join(__toInsert);",
			"            else {",
			"                SplayArray<_Tp> sub = subArray(__pos, size() - 1);",
			"                join(__toInsert);",
			"                join(sub);",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void insert(int __pos, _Iterator __first, _Iterator __last) {",
			"            if (SplayArray<_Tp> toInsert(__first, __last); toInsert.size()) insert(__pos, toInsert);",
			"        }",
			"        void update(int __pos, _Tp __key) { at(__pos)->key = __key; }",
			"        void erase(int __pos) {",
			"            if (!__pos)",
			"                pop_front();",
			"            else if (__pos == size() - 1)",
			"                pop_back();",
			"            else {",
			"                m_root = splay_kth(m_root, m_root, __pos);",
			"                node *lchild = m_root->lchild = splay_max(m_root->lchild, m_root->lchild);",
			"                lchild->rchild = m_root->rchild;",
			"                delete m_root;",
			"                m_root = update(lchild);",
			"            }",
			"        }",
			"        void erase(int __left, int __right) {",
			"            if (!__left) {",
			"                node *p = splay_kth(m_root, m_root, __right);",
			"                m_root = p->rchild;",
			"                p->rchild = nullptr;",
			"                _clear(p);",
			"            } else if (__right == size() - 1) {",
			"                node *p = splay_kth(m_root, m_root, __left);",
			"                m_root = p->lchild;",
			"                p->lchild = nullptr;",
			"                _clear(p);",
			"            } else {",
			"                node *p = splay_kth(m_root, m_root, __right + 1);",
			"                node *q = splay_kth(p->lchild, p->lchild, __left);",
			"                p->lchild = q->lchild;",
			"                m_root = update(p);",
			"                q->lchild = nullptr;",
			"                _clear(q);",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void assign(_Iterator __first, _Iterator __last) {",
			"            clear();",
			"            m_root = make_tree(__first, __last);",
			"        }",
			"        void reverse(int __left, int __right) {",
			"            if (!__left) {",
			"                if (__right == size() - 1)",
			"                    m_root->reverse();",
			"                else {",
			"                    m_root = update(splay_kth(m_root, m_root, __right + 1));",
			"                    m_root->lchild->reverse();",
			"                }",
			"            } else if (__right == size() - 1) {",
			"                m_root = update(splay_kth(m_root, m_root, __left - 1));",
			"                m_root->rchild->reverse();",
			"            } else {",
			"                m_root = update(splay_kth(m_root, m_root, __right + 1));",
			"                m_root->lchild = update(splay_kth(m_root->lchild, m_root->lchild, __left - 1));",
			"                m_root->lchild->rchild->reverse();",
			"            }",
			"        }",
			"        void push_front(_Tp __key) {",
			"            if (!m_root)",
			"                m_root = new node{{}, __key, false, 1, nullptr, nullptr};",
			"            else {",
			"                m_root = splay_min(m_root, m_root);",
			"                m_root->lchild = new node{{}, __key, false, 1, nullptr, nullptr};",
			"                m_root = update(m_root);",
			"            }",
			"        }",
			"        void pop_front() {",
			"            m_root = splay_min(m_root, m_root);",
			"            node *rchild = m_root->rchild;",
			"            delete m_root;",
			"            m_root = rchild;",
			"        }",
			"        void push_back(_Tp __key) {",
			"            if (!m_root)",
			"                m_root = new node{{}, __key, false, 1, nullptr, nullptr};",
			"            else {",
			"                m_root = splay_max(m_root, m_root);",
			"                m_root->rchild = new node{{}, __key, false, 1, nullptr, nullptr};",
			"                m_root = update(m_root);",
			"            }",
			"        }",
			"        void pop_back() {",
			"            m_root = splay_max(m_root, m_root);",
			"            node *lchild = m_root->lchild;",
			"            delete m_root;",
			"            m_root = lchild;",
			"        }",
			"        node *at(int __pos) { return m_root = update(splay_kth(m_root, m_root, __pos)); }",
			"        _Tp &operator[](int __index) { return at(__index)->key; }",
			"        node *front() { return m_root = update(splay_min(m_root, m_root)); }",
			"        node *back() { return m_root = update(splay_max(m_root, m_root)); }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        SplayArray<_Tp> subArray(int __left, int __right) {",
			"            SplayArray<_Tp> sub;",
			"            if (!__left) {",
			"                node *p = splay_kth(m_root, m_root, __right);",
			"                m_root = p->rchild;",
			"                p->rchild = nullptr;",
			"                sub.m_root = update(p);",
			"            } else if (__right == size() - 1) {",
			"                node *p = splay_kth(m_root, m_root, __left);",
			"                m_root = p->lchild;",
			"                p->lchild = nullptr;",
			"                sub.m_root = update(p);",
			"            } else {",
			"                node *p = splay_kth(m_root, m_root, __right + 1);",
			"                node *q = splay_kth(p->lchild, p->lchild, __left);",
			"                p->lchild = q->lchild;",
			"                m_root = update(p);",
			"                q->lchild = nullptr;",
			"                sub.m_root = update(q);",
			"            }",
			"            return sub;",
			"        }",
			"        void join(SplayArray<_Tp> &__other) {",
			"            if (!m_root)",
			"                m_root = __other.m_root;",
			"            else {",
			"                m_root = splay_max(m_root, m_root);",
			"                m_root->rchild = __other.m_root;",
			"            }",
			"            __other.m_root = nullptr;",
			"            m_root = update(m_root);",
			"        }",
			"        template <typename _Sequence = std::vector<_Tp>>",
			"        _Sequence to_sequence() const {",
			"            _Sequence v;",
			"            v.reserve(size());",
			"            auto dfs = [&](auto self, node *cur) -> void {",
			"                if (cur->reversed) cur->push_down();",
			"                if (cur->lchild) self(self, cur->lchild);",
			"                v.push_back(cur->key);",
			"                if (cur->rchild) self(self, cur->rchild);",
			"            };",
			"            if (m_root) dfs(dfs, m_root);",
			"            return v;",
			"        }",
			"        template <typename _Sequence = std::vector<_Tp>>",
			"        _Sequence to_sequence(int __left, int __right) {",
			"            _Sequence v;",
			"            v.reserve(__right - __left + 1);",
			"            auto dfs = [&](auto self, node *cur) -> void {",
			"                if (cur->reversed) cur->push_down();",
			"                if (cur->lchild) self(self, cur->lchild);",
			"                if (v.size() == __right - __left + 1) return;",
			"                v.push_back(cur->key);",
			"                if (v.size() == __right - __left + 1) return;",
			"                if (cur->rchild) self(self, cur->rchild);",
			"            };",
			"            m_root = update(splay_kth(m_root, m_root, __left));",
			"            v.push_back(m_root->key);",
			"            if (__right > __left) dfs(dfs, m_root->rchild);",
			"            return v;",
			"        }",
			"    };",
			"    template <typename _Tp = int>",
			"    SplayArray() -> SplayArray<_Tp>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SplayArray(_Iterator, _Iterator) -> SplayArray<_Tp>;",
			"}",
		],
		"description": "splay array"
	},
	"sqrt tree":{
		"prefix": "SQRT",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = int64_t, typename _Operation = std::plus<_Tp>>",
			"    class SqrtTree {",
			"        int m_length;",
			"        int m_depth;",
			"        int m_mask;",
			"        int m_blockSize;",
			"        int m_blockCount;",
			"        std::vector<Accumulator<_Tp, _Operation, ACCUMULATE_PREFIX | ACCUMULATE_SUFFIX>> m_fix;",
			"        STTable<_Tp, _Operation> m_inter;",
			"        std::vector<ZkwTree<_Tp, _Operation>> m_subtree;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            //assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"",
			"    public:",
			"        SqrtTree(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp(), _Tp __initValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue), m_inter(0, __op, __defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        SqrtTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue), m_inter(0, __op, __defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32) >> 1;",
			"            while (std::__countr_zero<uint32_t>(m_length) != m_depth) m_length++;",
			"            m_mask = (1 << m_depth) - 1;",
			"            m_blockSize = 1 << m_depth;",
			"            m_blockCount = m_length >> m_depth;",
			"            m_fix.clear();",
			"            m_fix.reserve(m_blockCount);",
			"            m_fix.emplace_back(m_blockSize, m_op, m_defaultValue);",
			"            for (int i = 1; i < m_blockCount; i++) m_fix.push_back(m_fix[0]);",
			"            m_subtree.clear();",
			"            m_subtree.reserve(m_blockCount);",
			"            m_subtree.emplace_back(m_blockSize, m_op, m_defaultValue);",
			"            for (int i = 1; i < m_blockCount; i++) m_subtree.push_back(m_subtree[0]);",
			"            std::vector<_Tp> sub_val(m_blockCount, m_subtree[0].queryAll());",
			"            m_inter.reset(sub_val.begin(), sub_val.end());",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32) >> 1;",
			"            while (std::__countr_zero<uint32_t>(m_length) != m_depth) m_length++;",
			"            std::vector<_Tp> data;",
			"            data.reserve(m_length);",
			"            data.insert(data.end(), __first, __last);",
			"            data.insert(data.end(), m_length - (__last - __first), m_defaultValue);",
			"            m_mask = (1 << m_depth) - 1;",
			"            m_blockSize = 1 << m_depth;",
			"            m_blockCount = m_length >> m_depth;",
			"            m_fix.clear();",
			"            m_fix.reserve(m_blockCount);",
			"            for (int i = 0; i < m_blockCount; i++) m_fix.emplace_back(data.data() + i * m_blockSize, data.data() + (i + 1) * m_blockSize, m_op, m_defaultValue);",
			"            m_subtree.clear();",
			"            m_subtree.reserve(m_blockCount);",
			"            for (int i = 0; i < m_blockCount; i++) m_subtree.emplace_back(data.data() + i * m_blockSize, data.data() + (i + 1) * m_blockSize, m_op);",
			"            std::vector<_Tp> sub_val;",
			"            for (int i = 0; i < m_blockCount; i++) sub_val.push_back(m_subtree[i].queryAll());",
			"            m_inter.reset(sub_val.begin(), sub_val.end());",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            m_fix[__i >> m_depth].update(__i & m_mask, __val);",
			"            m_subtree[__i >> m_depth].update(__i & m_mask, __val);",
			"            m_inter.update(__i >> m_depth, m_subtree[__i >> m_depth].queryAll());",
			"        }",
			"        _Tp query(int __i) const { return m_subtree[__i >> m_depth].query(__i & m_mask); }",
			"        _Tp query(int __left, int __right) const {",
			"            int l1 = __left >> m_depth, l2 = __left & m_mask;",
			"            int r1 = __right >> m_depth, r2 = __right & m_mask;",
			"            if (l1 == r1)",
			"                return m_subtree[l1].query(l2, r2);",
			"            else if (l1 + 1 == r1)",
			"                return m_op(m_fix[l1].querySuffix(l2), m_fix[r1].queryPrefix(r2));",
			"            else",
			"                return m_op(m_op(m_fix[l1].querySuffix(l2), m_inter.query(l1 + 1, r1 - 1)), m_fix[r1].queryPrefix(r2));",
			"        }",
			"        _Tp queryAll() const { return m_inter.queryAll(); }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    SqrtTree(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int64_t>",
			"    SqrtTree(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    SqrtTree(int = 0, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SqrtTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SqrtTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>>",
			"    SqrtTree(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, _Operation>;",
			"}",
			"",
		],
		"description": "sqrt tree"
	},
	"st table":{
        "prefix": "ST",
        "body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Maximum>",
			"    struct STTable {",
			"        std::vector<std::vector<_Tp>> m_sub;",
			"        _Maximum m_maxi;",
			"        int m_length;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            // assert(m_maxi(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        STTable(int __n = 0, _Maximum __maxi = std::max<_Tp>, _Tp __defaultValue = _Tp()) : m_maxi(__maxi), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        STTable(_Iterator __first, _Iterator __last, _Maximum __maxi = std::max<_Tp>, _Tp __defaultValue = _Tp()) : m_maxi(__maxi), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            int d = m_length > 1 ? 32 - std::__countl_zero<uint32_t>(m_length - 1) : 1;",
			"            m_sub.resize(d);",
			"            m_sub[0].assign(__n, m_defaultValue);",
			"            for (int i = 1; i < d; i++) {",
			"                m_sub[i].clear();",
			"                m_sub[i].reserve(m_length - (1 << i) + 1);",
			"                for (int j = 0; j <= m_length - (1 << i); j++)",
			"                    m_sub[i].push_back(m_maxi(m_sub[i - 1][j], m_sub[i - 1][j + (1 << i - 1)]));",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            int d = m_length > 1 ? 32 - std::__countl_zero<uint32_t>(m_length - 1) : 1;",
			"            m_sub.resize(d);",
			"            m_sub[0].assign(__first, __last);",
			"            for (int i = 1; i < d; i++) {",
			"                m_sub[i].clear();",
			"                m_sub[i].reserve(m_length - (1 << i) + 1);",
			"                for (int j = 0; j <= m_length - (1 << i); j++)",
			"                    m_sub[i].push_back(m_maxi(m_sub[i - 1][j], m_sub[i - 1][j + (1 << i - 1)]));",
			"            }",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            m_sub[0][__i] = __val;",
			"            for (int i = 1; i < m_sub.size(); i++)",
			"                for (int j = std::max(0, __i - (1 << i) + 1), end = std::min(__i, int(m_sub[i].size() - 1)); j <= end; j++)",
			"                    m_sub[i][j] = m_maxi(m_sub[i - 1][j], m_sub[i - 1][j + (1 << i - 1)]);",
			"        }",
			"        _Tp query(int __i) const {",
			"            return m_sub[0][__i];",
			"        }",
			"        _Tp query(int __left, int __right) const {",
			"            if (__left == __right) return m_sub[0][__left];",
			"            int d = 31 - std::__countl_zero<uint32_t>(__right - __left);",
			"            return m_maxi(m_sub[d][__left], m_sub[d][__right - (1 << d) + 1]);",
			"        }",
			"        _Tp queryAll() const {",
			"            return query(0, m_length - 1);",
			"        }",
			"    };",
			"    template <typename _Tp = int>",
			"    STTable(int = 0, const _Tp &(*)(const _Tp &, const _Tp &) = std::max<_Tp>, _Tp = _Tp()) -> STTable<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int>",
			"    STTable(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> STTable<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Maximum, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Maximum::operator()))::result_type>>",
			"    STTable(int, _Maximum, _Tp = _Tp()) -> STTable<_Tp, _Maximum>;",
			"    template <typename _Iterator, typename _Maximum, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    STTable(_Iterator, _Iterator, _Maximum, _Tp = _Tp()) -> STTable<_Tp, _Maximum>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    STTable(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &) = std::max<_Tp>, _Tp = _Tp()) -> STTable<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    STTable(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> STTable<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"}",
        ],
        "description": "st table"
    },
	"treap":{
		"prefix": "TREAP",
		"body": [
			"namespace OY {",
			"    struct TreapSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct TreapMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct TreapMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _TreapNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _TreapNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = TreapMultisetTag>",
			"    class Treap {",
			"        struct node : _TreapNode<_Tp, _Fp, _Tag::is_map> {",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static inline std::mt19937 s_rand;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return update(q);",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return update(q);",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        Treap(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) {",
			"                    res = true;",
			"                    cur = new node{__key, __args..., s_rand(), 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    if (_Tag::multi_key || res) {",
			"                        if (subtree_priority(cur->lchild) > cur->priority)",
			"                            return rrotate(cur);",
			"                        else",
			"                            cur->subtree_weight++;",
			"                    }",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    if (_Tag::multi_key || res) {",
			"                        if (subtree_priority(cur->rchild) > cur->priority)",
			"                            return lrotate(cur);",
			"                        else",
			"                            cur->subtree_weight++;",
			"                    }",
			"                }",
			"                return cur;",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key))",
			"                    cur->lchild = self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    cur->rchild = self(self, cur->rchild);",
			"                else {",
			"                    delete cur;",
			"                    if (!cur->lchild)",
			"                        return cur->rchild;",
			"                    else if (!cur->rchild)",
			"                        return cur->lchild;",
			"                    else if (cur->lchild->subtree_weight > cur->rchild->subtree_weight) {",
			"                        node *q = cur->lchild;",
			"                        cur->lchild = q->rchild;",
			"                        q->rchild = self(self, cur);",
			"                        cur = q;",
			"                    } else {",
			"                        node *q = cur->rchild;",
			"                        cur->rchild = q->lchild;",
			"                        q->lchild = self(self, cur);",
			"                        cur = q;",
			"                    }",
			"                }",
			"                return update(cur);",
			"            };",
			"            int oldsize = size();",
			"            m_root = dfs(dfs, m_root);",
			"            return oldsize != size();",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace TreapContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = Treap<_Tp, bool, _Compare, TreapSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = Treap<_Tp, bool, _Compare, TreapMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = Treap<_Tp, _Fp, _Compare, TreapMapTag>;",
			"    }",
			"}",
		],
		"description": "treap"
	},
	"union and find":{
        "prefix": "UNION",
        "body": [
			"namespace OY {",
			"    struct UnionFind {",
			"        uint32_t m_groupCnt;",
			"        std::vector<uint32_t> m_parent, m_size;",
			"        UnionFind(uint32_t __n = 0) { resize(__n); }",
			"        void resize(uint32_t __n) {",
			"            m_groupCnt = __n;",
			"            m_parent.resize(__n);",
			"            std::iota(m_parent.begin(), m_parent.end(), 0);",
			"            m_size.resize(__n);",
			"            std::fill(m_size.begin(), m_size.end(), 1);",
			"        }",
			"        uint32_t find(uint32_t __i) { return m_parent[__i] == __i ? __i : m_parent[__i] = find(m_parent[__i]); }",
			"        uint32_t size(uint32_t __i) { return m_size[find(__i)]; }",
			"        void uniteTo(uint32_t __headA, uint32_t __headB) {",
			"            if (__headA == __headB) return;",
			"            m_parent[__headA] = __headB;",
			"            m_size[__headB] += m_size[__headA];",
			"            m_groupCnt--;",
			"        }",
			"        bool uniteBySize(uint32_t __a, uint32_t __b) {",
			"            if (__a = find(__a), __b = find(__b); __a == __b) return false;",
			"            if (m_size[__a] > m_size[__b]) std::swap(__a, __b);",
			"            uniteTo(__a, __b);",
			"            return true;",
			"        }",
			"        bool uniteByID(uint32_t __a, uint32_t __b) {",
			"            if (__a = find(__a), __b = find(__b); __a == __b) return false;",
			"            if (__a < __b) std::swap(__a, __b);",
			"            uniteTo(__a, __b);",
			"            return true;",
			"        }",
			"        bool isSame(uint32_t __a, uint32_t __b) { return find(__a) == find(__b); }",
			"        bool isHead(uint32_t __i) { return __i == m_parent[__i]; }",
			"        uint32_t count() const { return m_groupCnt; }",
			"        std::vector<uint32_t> heads() {",
			"            std::vector<uint32_t> ret;",
			"            ret.reserve(m_groupCnt);",
			"            for (uint32_t i = 0; i < m_parent.size(); i++)",
			"                if (isHead(i)) ret.push_back(i);",
			"            return ret;",
			"        }",
			"        std::vector<std::vector<uint32_t>> groups() {",
			"            std::vector<std::vector<uint32_t>> ret;",
			"            ret.resize(m_groupCnt);",
			"            uint32_t index[m_parent.size()];",
			"            for (uint32_t i = 0, j = 0; i < m_parent.size(); i++)",
			"                if (isHead(i)) {",
			"                    ret[j].reserve(m_size[i]);",
			"                    index[i] = j++;",
			"                }",
			"            for (uint32_t i = 0; i < m_parent.size(); i++)",
			"                ret[index[find(i)]].push_back(i);",
			"            return ret;",
			"        }",
			"    };",
			"}",
        ],
        "description": "union and find"
    },
	"weight balanced leafy tree":{
		"prefix": "WBLT",
		"body": [
			"namespace OY {",
			"    struct WeightBalancedLeafySetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct WeightBalancedLeafyMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct WeightBalancedLeafyMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _WeightBalancedLeafyTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _WeightBalancedLeafyTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = WeightBalancedLeafyMultisetTag>",
			"    class WeightBalancedLeafyTree {",
			"        struct node : _WeightBalancedLeafyTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static constexpr int ratio = 4, bias = 2;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->lchild->subtree_weight + p->rchild->subtree_weight;",
			"            p->key = p->rchild->key;",
			"            return p;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->rchild;",
			"            q->rchild = q->lchild;",
			"            q->lchild = p->lchild;",
			"            p->lchild = update(q);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->lchild;",
			"            q->lchild = q->rchild;",
			"            q->rchild = p->rchild;",
			"            p->rchild = update(q);",
			"            return p;",
			"        }",
			"        static node *balance(node *cur) {",
			"            if (cur->lchild->subtree_weight > cur->rchild->subtree_weight * ratio + bias) {",
			"                if (cur->lchild->rchild->subtree_weight > cur->lchild->lchild->subtree_weight * (ratio - 1) + bias)",
			"                    cur->lchild = lrotate(cur->lchild);",
			"                return update(rrotate(cur));",
			"            } else if (cur->rchild->subtree_weight > cur->lchild->subtree_weight * ratio + bias) {",
			"                if (cur->rchild->lchild->subtree_weight > cur->rchild->rchild->subtree_weight * (ratio - 1) + bias)",
			"                    cur->rchild = rrotate(cur->rchild);",
			"                return update(lrotate(cur));",
			"            } else",
			"                return update(cur);",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        WeightBalancedLeafyTree(_Tp __maxKey = std::numeric_limits<_Tp>::max(), _Compare __comp = _Compare()) : m_comp(__comp) {",
			"            m_root = new node;",
			"            m_root->key = __maxKey;",
			"            m_root->subtree_weight = 1;",
			"            m_root->lchild = nullptr;",
			"            m_root->rchild = nullptr;",
			"        }",
			"        ~WeightBalancedLeafyTree() { clear(); }",
			"        void clear() {",
			"            m_root->subtree_weight = 1;",
			"            m_root->lchild = nullptr;",
			"            m_root->rchild = nullptr;",
			"        }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if(!cur->lchild){",
			"                    cur->lchild = new node{__key, __args..., 1, nullptr, nullptr};",
			"                    cur->rchild = new node(*cur);",
			"                    cur->rchild->lchild = nullptr;",
			"                    cur->rchild->rchild = nullptr;",
			"                    cur->subtree_weight=2;",
			"                    return cur;",
			"                }",
			"                else if (m_comp(cur->lchild->key, __key)) {",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return balance(cur);",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(__key, cur->lchild->key)) return cur;",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return balance(cur);",
			"                };",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur->lchild) {",
			"                    if (m_comp(__key, cur->key)) return cur;",
			"                    delete cur;",
			"                    return nullptr;",
			"                } else if (m_comp(cur->lchild->key, __key)) {",
			"                    if (cur->rchild = self(self, cur->rchild)) return balance(cur);",
			"                    delete cur;",
			"                    return cur->lchild;",
			"                } else if (cur->lchild = self(self, cur->lchild))",
			"                    return balance(cur);",
			"                delete cur;",
			"                return cur->rchild;",
			"            };",
			"            int old_weight = size();",
			"            m_root = dfs(dfs, m_root);",
			"            return old_weight != size();",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur->lchild;)",
			"                if (m_comp(cur->lchild->key, __key)) {",
			"                    ord += cur->lchild->subtree_weight;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (cur->lchild)",
			"                if (int l_count = cur->lchild->subtree_weight; __k < l_count)",
			"                    cur = cur->lchild;",
			"                else {",
			"                    __k -= l_count;",
			"                    cur = cur->rchild;",
			"                }",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            node *cur = m_root;",
			"            while (cur->lchild)",
			"                if (m_comp(cur->lchild->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    cur = cur->lchild;",
			"            return m_comp(__key, cur->key) ? nullptr : cur;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *cur = m_root;",
			"            while (cur->lchild)",
			"                if (m_comp(cur->lchild->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    cur = cur->lchild;",
			"            return cur;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *cur = m_root;",
			"            while (cur->lchild)",
			"                if (m_comp(__key, cur->lchild->key))",
			"                    cur = cur->lchild;",
			"                else",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur->lchild;) {",
			"                if (m_comp(cur->lchild->key, __key)) {",
			"                    res = cur->lchild;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            if (res)",
			"                while (res->rchild) res = res->rchild;",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root) - 1; }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace WeightBalancedLeafyTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = WeightBalancedLeafyTree<_Tp, bool, _Compare, WeightBalancedLeafySetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = WeightBalancedLeafyTree<_Tp, bool, _Compare, WeightBalancedLeafyMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = WeightBalancedLeafyTree<_Tp, _Fp, _Compare, WeightBalancedLeafyMapTag>;",
			"    }",
			"}",
		],
		"description": "weight balanced leafy tree"
	},
	"zkw tree":{
		"prefix": "ZKW",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = int64_t, typename _Operation = std::plus<_Tp>>",
			"    class ZkwTree {",
			"        std::vector<_Tp> m_sub;",
			"        int m_length;",
			"        int m_depth;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            //assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        void _update(int cur) {",
			"            m_sub[cur] = m_op(m_sub[cur * 2], m_sub[cur * 2 + 1]);",
			"        }",
			"",
			"    public:",
			"        ZkwTree(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        ZkwTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32);",
			"            m_sub.assign(1 << (m_depth + 1), m_defaultValue);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero<uint32_t>(m_length - 1) : 32);",
			"            m_sub.resize(1 << (m_depth + 1));",
			"            std::copy(__first, __last, m_sub.begin() + (1 << m_depth));",
			"            std::fill(m_sub.begin() + (1 << m_depth) + m_length, m_sub.end(), m_defaultValue);",
			"            for (int i = 1 << m_depth; --i;) _update(i);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            __i += 1 << m_depth;",
			"            m_sub[__i] = __val;",
			"            while (__i >>= 1) _update(__i);",
			"        }",
			"        void add(int __i, _Tp __inc) {",
			"            __i += 1 << m_depth;",
			"            m_sub[__i] = m_op(m_sub[__i], __inc);",
			"            while (__i >>= 1) _update(__i);",
			"        }",
			"        _Tp query(int __i) const {",
			"            return m_sub[(1 << m_depth) + __i];",
			"        }",
			"        _Tp query(int __left, int __right) const {",
			"            if (__left == __right) return m_sub[(1 << m_depth) + __left];",
			"            __left += 1 << m_depth;",
			"            __right += 1 << m_depth;",
			"            _Tp res = m_sub[__left];",
			"            int j = 31 - std::__countl_zero<uint32_t>(__left ^ __right);",
			"            for (int i = 0; i < j; i++)",
			"                if (!(__left >> i & 1)) res = m_op(res, m_sub[__left >> i ^ 1]);",
			"            for (int i = j - 1; i >= 0; i--)",
			"                if (__right >> i & 1) res = m_op(res, m_sub[__right >> i ^ 1]);",
			"            return m_op(res, m_sub[__right]);",
			"        }",
			"        _Tp queryAll() const {",
			"            return m_sub[1];",
			"        }",
			"        int kth(_Tp __k) const {",
			"            int i = 1;",
			"            while (i < 1 << m_depth)",
			"                if (m_sub[i *= 2] <= __k) __k -= m_sub[i++];",
			"            return i - (1 << m_depth);",
			"        }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    ZkwTree(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int64_t>",
			"    ZkwTree(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    ZkwTree(int = 0, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    ZkwTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    ZkwTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>>",
			"    ZkwTree(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, _Operation>;",
			"}",
		],
		"description": "zkw tree"
	},
	
	"barrett reduce":{
		"prefix": "BRT",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    struct Barrett {",
			"        _ModType m_P;",
			"        __uint128_t m_Pinv;",
			"        constexpr Barrett() = default;",
			"        constexpr explicit Barrett(_ModType __P) : m_P(__P), m_Pinv(-uint64_t(__P) / __P + 1) {}",
			"        constexpr _ModType mod() const { return m_P; }",
			"        constexpr _ModType mod(uint64_t __a) const {",
			"            __a -= uint64_t(m_Pinv * __a >> 64) * m_P + m_P;",
			"            if (__a >= m_P) __a += m_P;",
			"            return __a;",
			"        }",
			"        constexpr _ModType plus(_ModType __a, _ModType __b) {",
			"            if (__a += __b; __a >= m_P) __a -= m_P;",
			"            return __a;",
			"        }",
			"        constexpr _ModType minus(_ModType __a, _ModType __b) {",
			"            if (__a += m_P - __b; __a >= m_P) __a -= m_P;",
			"            return __a;",
			"        }",
			"        constexpr _ModType multiply(uint64_t __a, uint64_t __b) const {",
			"            if constexpr (std::is_same_v<_ModType, uint64_t>)",
			"                return multiply_ld(__a, __b);",
			"            else",
			"                return multiply_64(__a, __b);",
			"        }",
			"        constexpr _ModType multiply_64(uint64_t __a, uint64_t __b) const {",
			"            // assert(__a * __b < 1ull << 64);",
			"            return mod(__a * __b);",
			"        }",
			"        constexpr _ModType multiply_128(uint64_t __a, uint64_t __b) const {",
			"            return __uint128_t(__a) * __b % m_P;",
			"        }",
			"        constexpr _ModType multiply_ld(uint64_t __a, uint64_t __b) const {",
			"            // assert(m_P < 1ull << 63 && __a < m_P && __b < m_P);",
			"            int64_t res = __a * __b - uint64_t(1.L / m_P * __a * __b) * m_P;",
			"            if (res < 0)",
			"                res += m_P;",
			"            else if (res >= m_P)",
			"                res -= m_P;",
			"            return res;",
			"        }",
			"        constexpr _ModType pow(uint64_t __a, uint64_t __n) const {",
			"            if constexpr (std::is_same_v<_ModType, uint64_t>)",
			"                return pow_ld(__a, __n);",
			"            else",
			"                return pow_64(__a, __n);",
			"        }",
			"        constexpr _ModType pow_64(uint64_t __a, uint64_t __n) const {",
			"            // assert(m_P < 1ull << 32);",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_64(res, b);",
			"                b = multiply_64(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        constexpr _ModType pow_128(uint64_t __a, uint64_t __n) const {",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_128(res, b);",
			"                b = multiply_128(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        constexpr _ModType pow_ld(uint64_t __a, uint64_t __n) const {",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_ld(res, b);",
			"                b = multiply_ld(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Tp>",
			"        constexpr _Tp divide(_Tp __a) const {",
			"            if (__a < m_P) return 0;",
			"            _Tp res = m_Pinv * __a >> 64;",
			"            if (__a - res * m_P >= m_P) res++;",
			"            return res;",
			"        }",
			"        template <typename _Tp>",
			"        constexpr std::pair<_Tp, _Tp> divmod(_Tp __a) const {",
			"            _Tp quo = (__a * m_Pinv) >> 64, rem = __a - quo * m_P;",
			"            if (rem >= m_P) {",
			"                quo++;",
			"                rem -= m_P;",
			"            }",
			"            return {quo, rem};",
			"        }",
			"    };",
			"    using Barrett32 = Barrett<uint32_t>;",
			"    using Barrett64 = Barrett<uint64_t>;",
			"}",
		],
		"description": "barrett reduce"
	},
	"Big int":{
		"prefix": "BIG",
		"body": [
			"namespace OY {",
			"#pragma pack(4)",
			"    template <uint32_t _B = 10, uint32_t _W = 6, uint32_t _MAXN = 1 << 20, uint64_t _P = 9223372036737335297, uint64_t _R = 3>",
			"    struct BigInt {",
			"        using bint = BigInt<_B, _W, _MAXN, _P, _R>;",
			"        static constexpr struct _Bases {",
			"            uint64_t val[_W * 2 + 1];",
			"            constexpr _Bases() : val{} {",
			"                for (uint32_t i = 0; i <= _W * 2; i++) val[i] = i ? val[i - 1] * _B : 1;",
			"            }",
			"        } bases{};",
			"        static constexpr uint32_t _N = bases.val[_W];",
			"        static inline bint s_divThresh = bint(__int128_t(LLONG_MAX) / _N - 1);",
			"        static inline Montgomery64 s_mg = Montgomery64(_P);",
			"        static inline uint64_t s_roots[std::__bit_ceil(_MAXN / _W) << 1], s_dftBuffer[std::__bit_ceil(_MAXN / _W) << 2], s_rootSize = 1;",
			"        static inline std::mt19937 s_rander;",
			"        int *m_data;",
			"        uint32_t m_length;",
			"        bool m_negative;",
			"        BigInt() : m_length(0), m_negative(false) {}",
			"        template <typename _Tp, std::enable_if_t<std::is_integral_v<_Tp> | std::is_same_v<_Tp, __int128_t>, bool> = true>",
			"        explicit BigInt(_Tp __number) : m_length(0), m_negative(false) {",
			"            if (!__number) return;",
			"            bool neg = false;",
			"            if (__number < _Tp(0)) {",
			"                neg = true;",
			"                __number = -__number;",
			"            }",
			"            static int s_buffer[256], *s_cursor;",
			"            for (s_cursor = s_buffer; __number; __number /= _N) *s_cursor++ = __number % _N;",
			"            std::copy(s_buffer, s_cursor, m_data = malloc(m_length = s_cursor - s_buffer));",
			"            if (neg) setSign(true);",
			"        }",
			"        explicit BigInt(const char *__number) : BigInt(fromString(__number)) {}",
			"        explicit BigInt(const std::string &__number) : BigInt(fromString(__number.data(), __number.size())) {}",
			"        BigInt(bint &&__other) : m_data(__other.m_data), m_length(__other.m_length), m_negative(__other.m_negative) { __other.m_length = 0; }",
			"        BigInt(const bint &__other) : m_length(__other.m_length), m_negative(__other.m_negative) {",
			"            if (m_length) std::copy_n(__other.m_data, m_length, m_data = malloc(m_length));",
			"        }",
			"        ~BigInt() {",
			"            if (m_length) free(m_data);",
			"        }",
			"        static char fromInt(uint32_t __c) {",
			"            if (__c < 10)",
			"                return '0' + __c;",
			"            else if (__c < 36)",
			"                return 'a' + (__c - 10);",
			"            else",
			"                return 'A' + (__c - 36);",
			"        }",
			"        static uint32_t fromChar(char __c) {",
			"            if (__c <= '9')",
			"                return __c - '0';",
			"            else if (__c <= 'Z')",
			"                return __c - 'A' + 36;",
			"            else",
			"                return __c - 'a' + 10;",
			"        }",
			"        static bint fromString(const char *__number) { return fromString(__number, std::strlen(__number)); }",
			"        static bint fromString(const char *__number, uint32_t __length) {",
			"            uint32_t cursor = std::find_if((__number[0] == '+' || __number[0] == '-') ? __number + 1 : __number, __number + __length, [](char c) { return c != '0'; }) - __number;",
			"            if (cursor == __length) return bint();",
			"            auto [quot, rem] = std::div(int(__length - cursor), int(_W));",
			"            bint res(empty(quot + (rem > 0), __number[0] == '-'));",
			"            uint32_t i = res.m_length - 1;",
			"            if (rem) {",
			"                uint32_t digit = 0;",
			"                for (uint32_t j = rem; j--;) digit = digit * _B + fromChar(__number[cursor++]);",
			"                res.m_data[i--] = digit;",
			"            }",
			"            while (cursor < __length) {",
			"                uint32_t digit = 0;",
			"                for (uint32_t j = _W; j--;) digit = digit * _B + fromChar(__number[cursor++]);",
			"                res.m_data[i--] = digit;",
			"            }",
			"            return res;",
			"        }",
			"        static bint small(int __singleDigit) {",
			"            bint res = empty(1, __singleDigit < 0);",
			"            res.m_data[0] = std::abs(__singleDigit);",
			"            return res;",
			"        }",
			"        static bint rand(uint32_t __length) {",
			"            if (!__length) return bint();",
			"            auto [quot, rem] = std::div(int(__length), int(_W));",
			"            if (!rem) quot--, rem += _W;",
			"            bint res(empty(quot + 1, false));",
			"            for (uint32_t i = 0; i + 1 < res.m_length; i++) res.m_data[i] = s_rander() % _N;",
			"            res.m_data[res.m_length - 1] = s_rander() % (bases.val[rem] - bases.val[rem - 1]) + bases.val[rem - 1];",
			"            return res;",
			"        }",
			"        static bint empty(uint32_t __length, bool __negative) {",
			"            bint res;",
			"            if (__length) res.m_data = malloc(__length);",
			"            res.m_length = __length;",
			"            res.setSign(__negative);",
			"            return res;",
			"        }",
			"        static int absCompare(const bint &__a, const bint &__b) {",
			"            if (__a.m_length != __b.m_length) return __a.m_length > __b.m_length ? 1 : -1;",
			"            for (uint32_t i = __a.m_length - 1; ~i; i--)",
			"                if (__a.m_data[i] != __b.m_data[i]) return __a.m_data[i] > __b.m_data[i] ? 1 : -1;",
			"            return 0;",
			"        }",
			"        static bool absClose(const bint &__a, const bint &__b) {",
			"            if (__a.m_length == __b.m_length) {",
			"                uint32_t i = __a.m_length - 1;",
			"                while (~i && __a.m_data[i] == __b.m_data[i]) i--;",
			"                if (!~i) return true;",
			"                if (__a.m_data[i] == __b.m_data[i] + 1)",
			"                    while (~--i && !__a.m_data[i] && __b.m_data[i] == _N - 1) {}",
			"                else if (__b.m_data[i] == __a.m_data[i] + 1)",
			"                    while (~--i && __a.m_data[i] == _N - 1 && !__b.m_data[i]) {}",
			"                else",
			"                    return false;",
			"                return !~i;",
			"            } else if (__a.m_length == __b.m_length + 1) {",
			"                if (__a.m_data[__a.m_length - 1] != 1) return false;",
			"                for (uint32_t i = 0; i < __b.m_length; i++)",
			"                    if (__a.m_data[i] || __b.m_data[i] != _N - 1) return false;",
			"            } else if (__b.m_length == __a.m_length + 1) {",
			"                if (__b.m_data[__b.m_length - 1] != 1) return false;",
			"                for (uint32_t i = 0; i < __a.m_length; i++)",
			"                    if (__a.m_data[i] != _N - 1 || !__a.m_data[i]) return false;",
			"            } else",
			"                return false;",
			"            return true;",
			"        }",
			"        static int *malloc(uint32_t __length) { return new int[__length]; }",
			"        static void free(int *__data) { delete[] __data; }",
			"        static void prepareRoots(uint32_t __length) {",
			"            if (s_rootSize == 1) s_roots[s_rootSize++] = s_mg.raw_init(1);",
			"            while (s_rootSize < __length) {",
			"                const uint64_t wn = s_mg.pow(s_mg.raw_init(_R), (_P - 1) / (s_rootSize * 2));",
			"                for (uint32_t i = s_rootSize; i < s_rootSize * 2; i += 2) {",
			"                    s_roots[i] = s_roots[i / 2];",
			"                    s_roots[i + 1] = s_mg.multiply(s_roots[i / 2], wn);",
			"                }",
			"                s_rootSize *= 2;",
			"            }",
			"        }",
			"        static void dft(uint64_t *__buffer, uint32_t __length, const bint &__a) {",
			"            prepareRoots(__length);",
			"            for (uint32_t i = 0; i < __a.m_length; i++) __buffer[i] = s_mg.raw_init(__a.m_data[i]);",
			"            for (uint32_t i = __a.m_length; i < __length; i++) __buffer[i] = 0;",
			"            for (uint32_t l = __length / 2; l; l /= 2)",
			"                for (uint32_t i = 0; i < __length; i += l * 2)",
			"                    for (uint32_t j = 0; j < l; j++) {",
			"                        auto x = __buffer[i + j], y = __buffer[i + j + l];",
			"                        __buffer[i + j] = s_mg.plus(x, y);",
			"                        __buffer[i + j + l] = s_mg.multiply(s_roots[j + l], s_mg.minus(x, y));",
			"                    }",
			"        }",
			"        static void idft(uint64_t *__buffer, uint32_t __length) {",
			"            for (uint32_t l = 1; l < __length; l *= 2)",
			"                for (uint32_t i = 0; i < __length; i += l * 2)",
			"                    for (uint32_t j = 0; j < l; j++) {",
			"                        auto x = __buffer[i + j], y = s_mg.multiply(s_roots[j + l], __buffer[i + j + l]);",
			"                        __buffer[i + j] = s_mg.plus(x, y);",
			"                        __buffer[i + j + l] = s_mg.minus(x, y);",
			"                    }",
			"            const uint64_t inv = s_mg.pow(s_mg.raw_init(__length), _P - 2);",
			"            for (uint32_t i = 0; i < __length; i++) __buffer[i] = s_mg.multiply(__buffer[i], inv);",
			"            std::reverse(__buffer + 1, __buffer + __length);",
			"        }",
			"        template <int _Val, bool _Sign>",
			"        static bint &inc_dec(bint &__a) {",
			"            if (!__a.m_length) return __a = small(_Val);",
			"            if (__a.m_negative == _Sign) {",
			"                uint32_t i = 0;",
			"                while (i < __a.m_length && ++(__a.m_data[i]) == _N) __a.m_data[i++] = 0;",
			"                if (i < __a.m_length) return __a;",
			"                __a = empty(__a.m_length + 1, _Sign);",
			"                std::fill_n(__a.m_data, __a.m_length - 1, 0);",
			"                __a.m_data[__a.m_length - 1] = 1;",
			"                return __a;",
			"            } else {",
			"                uint32_t i = 0;",
			"                while (i < __a.m_length && !__a.m_data[i]--) __a.m_data[i++] = _N - 1;",
			"                return __a.shrink();",
			"            }",
			"        }",
			"        template <typename _Compare>",
			"        static bint &plus_minus_by(bint &__a, const bint &__b) {",
			"            if (!__b.m_length) return __a;",
			"            if (_Compare()(__a.m_negative, __b.m_negative)) {",
			"                if (__b.m_length <= __a.m_length && __a.m_data[__b.m_length - 1] + __b.m_data[__b.m_length - 1] < _N) {",
			"                    for (uint32_t i = 0, carry = 0; i < __b.m_length; i++)",
			"                        if (__a.m_data[i] += __b.m_data[i] + carry; (carry = __a.m_data[i] >= _N)) __a.m_data[i] -= _N;",
			"                    return __a;",
			"                }",
			"                bint res(empty(std::max(__a.m_length, __b.m_length) + 1, __a.m_negative));",
			"                for (uint32_t i = 0, carry = 0; i < res.m_length; i++)",
			"                    if (res.m_data[i] = (i < __a.m_length ? __a.m_data[i] : 0) + (i < __b.m_length ? __b.m_data[i] : 0) + carry; (carry = res.m_data[i] >= _N)) res.m_data[i] -= _N;",
			"                return (__a = res).shrink();",
			"            } else {",
			"                if (int comp = absCompare(__a, __b); comp > 0) {",
			"                    for (uint32_t i = 0, borrow = 0; i < __a.m_length; i++)",
			"                        if (__a.m_data[i] -= (i < __b.m_length ? __b.m_data[i] : 0) + borrow; (borrow = __a.m_data[i] < 0)) __a.m_data[i] += _N;",
			"                    return __a.shrink();",
			"                } else if (comp < 0) {",
			"                    bint res(empty(__b.m_length, std::is_same_v<_Compare, std::not_equal_to<bool>> ? !__b.m_negative : __b.m_negative));",
			"                    for (uint32_t i = 0, borrow = 0; i < res.m_length; i++)",
			"                        if (res.m_data[i] = __b.m_data[i] - (i < __a.m_length ? __a.m_data[i] : 0) - borrow; (borrow = res.m_data[i] < 0)) res.m_data[i] += _N;",
			"                    return (__a = res).shrink();",
			"                } else",
			"                    return __a = bint();",
			"            }",
			"        }",
			"        template <typename _Compare, typename _Sign>",
			"        static bint plus_minus(const bint &__a, const bint &__b, _Sign __sign) {",
			"            if (!__a.m_length) return __sign(__b);",
			"            if (!__b.m_length) return __a;",
			"            if (_Compare()(__a.m_negative, __b.m_negative)) {",
			"                bint res(empty(std::max(__a.m_length, __b.m_length) + 1, __a.m_negative));",
			"                for (uint32_t i = 0, carry = 0; i < res.m_length; i++)",
			"                    if (res.m_data[i] = (i < __a.m_length ? __a.m_data[i] : 0) + (i < __b.m_length ? __b.m_data[i] : 0) + carry; (carry = res.m_data[i] >= _N)) res.m_data[i] -= _N;",
			"                res.shrink();",
			"                return res;",
			"            } else if (int comp = absCompare(__a, __b); comp > 0) {",
			"                bint res(empty(__a.m_length, __a.m_negative));",
			"                for (uint32_t i = 0, borrow = 0; i < res.m_length; i++)",
			"                    if (res.m_data[i] = __a.m_data[i] - (i < __b.m_length ? __b.m_data[i] : 0) - borrow; (borrow = res.m_data[i] < 0)) res.m_data[i] += _N;",
			"                res.shrink();",
			"                return res;",
			"            } else if (comp < 0) {",
			"                bint res(empty(__b.m_length, std::is_same_v<_Sign, std::negate<bint>> ? !__b.m_negative : __b.m_negative));",
			"                for (uint32_t i = 0, borrow = 0; i < res.m_length; i++)",
			"                    if (res.m_data[i] = __b.m_data[i] - (i < __a.m_length ? __a.m_data[i] : 0) - borrow; (borrow = res.m_data[i] < 0)) res.m_data[i] += _N;",
			"                res.shrink();",
			"                return res;",
			"            } else",
			"                return bint();",
			"        }",
			"        template <bool _Mod, typename _Result = std::conditional_t<_Mod, std::pair<bint, bint>, bint>>",
			"        static _Result div_mod(const bint &__a, const bint &__b) {",
			"            if (int comp = absCompare(__a, __b); comp <= 0) {",
			"                if constexpr (_Mod)",
			"                    return comp < 0 ? std::make_pair(bint(), __a) : std::make_pair(small(__a.m_negative == __b.m_negative ? 1 : -1), bint());",
			"                else",
			"                    return comp < 0 ? bint() : small(__a.m_negative == __b.m_negative ? 1 : -1);",
			"            }",
			"            uint32_t shift = __a.m_length > __b.m_length * 2 ? __a.m_length - __b.m_length * 2 : 0, n = __a.m_length + shift, m = __b.m_length + shift;",
			"            bint a(__a << shift * _W), b(__b << shift * _W), c(0);",
			"            bint bi(b.setSign(false).inv()), prod(b * bi), res(0);",
			"            if (prod.m_length >= m * 2) prod -= b, --bi;",
			"            for (a.setSign(false); b <= a && (c = a * bi >> (m * 2 * _W)); a -= b * c, res += c) {}",
			"            while (b <= a) a -= b, ++res;",
			"            res.setSign(__a.m_negative != __b.m_negative), a.setSign(__a.m_negative);",
			"            if constexpr (_Mod)",
			"                return {res, shift ? a >> shift * _W : a};",
			"            else",
			"                return res;",
			"        }",
			"        static std::pair<bint, long long> div_mod(const bint &__a, long long __b) {",
			"            if (!__a.m_length) return {bint(), 0};",
			"            bint res(empty(__a.m_length, __b < 0 ? !__a.m_negative : __a.m_negative));",
			"            if (__b < 0) __b = -__b;",
			"            long long carry = 0;",
			"            for (uint32_t i = __a.m_length - 1; ~i; i--) {",
			"                auto [q, r] = std::div(__a.m_data[i] + carry * _N, __b);",
			"                res.m_data[i] = q, carry = r;",
			"            }",
			"            res.shrink();",
			"            return {res, __a.m_negative ? -carry : carry};",
			"        }",
			"        static bint self_multiply(const bint &__a) {",
			"            if (!__a.m_length) return bint();",
			"            uint32_t length = std::__bit_ceil(__a.m_length * 2 - 1);",
			"            dft(s_dftBuffer, length, __a);",
			"            std::transform(s_dftBuffer, s_dftBuffer + length, s_dftBuffer, [](uint64_t x) { return s_mg.multiply(x, x); });",
			"            idft(s_dftBuffer, length);",
			"            bint res(empty(__a.m_length * 2, false));",
			"            long long carry = 0;",
			"            for (uint32_t i = 0; i + 1 < res.m_length; i++) {",
			"                auto [quot, rem] = std::div((long long)(s_mg.reduce(s_dftBuffer[i]) + carry), (long long)_N);",
			"                carry = quot, res.m_data[i] = rem;",
			"            }",
			"            res.m_data[res.m_length - 1] = carry;",
			"            res.shrink();",
			"            return res;",
			"        }",
			"        static bint &inplace_multiply(bint &__a, long long __b) {",
			"            uint64_t carry = 0, i = 0;",
			"            if (__b < 0) {",
			"                __a.opposite();",
			"                __b = -__b;",
			"            }",
			"            while (i < __a.m_length) {",
			"                auto [quot, rem] = std::div((long long)(__a.m_data[i] * __b + carry), (long long)_N);",
			"                __a.m_data[i++] = rem;",
			"                carry = quot;",
			"            }",
			"            return __a;",
			"        }",
			"        static bint multiply(const bint &__a, long long __b) {",
			"            uint64_t carry = 0, i = 0;",
			"            while (i < __a.m_length) {",
			"                auto [quot, rem] = std::div((long long)(__a.m_data[i] * std::abs(__b) + carry), (long long)_N);",
			"                s_dftBuffer[i++] = rem;",
			"                carry = quot;",
			"            }",
			"            while (carry) {",
			"                auto [quot, rem] = std::div((long long)carry, (long long)_N);",
			"                s_dftBuffer[i++] = rem;",
			"                carry = quot;",
			"            }",
			"            bint res(empty(i, __b > 0 ? __a.m_negative : !__a.m_negative));",
			"            while (~--i) res.m_data[i] = s_dftBuffer[i];",
			"            return res;",
			"        }",
			"        bint &shrink() {",
			"            if (!m_length) return *this;",
			"            while (m_length && !m_data[m_length - 1]) m_length--;",
			"            if (m_length) return *this;",
			"            free(m_data);",
			"            return setSign(false);",
			"        }",
			"        bint &opposite() { return setSign(!m_negative); }",
			"        bint &setSign(bool __negative) {",
			"            m_negative = m_length ? __negative : false;",
			"            return *this;",
			"        }",
			"        bint &operator=(bint &&__other) {",
			"            std::swap(m_length, __other.m_length);",
			"            std::swap(m_data, __other.m_data);",
			"            std::swap(m_negative, __other.m_negative);",
			"            return *this;",
			"        }",
			"        bint &operator=(const bint &__other) {",
			"            if (m_length) free(m_data);",
			"            if ((m_length = __other.m_length)) std::copy_n(__other.m_data, m_length, m_data = malloc(m_length));",
			"            return setSign(__other.m_negative);",
			"        }",
			"        bint &operator++() { return inc_dec<1, false>(*this); }",
			"        bint &operator--() { return inc_dec<-1, true>(*this); }",
			"        uint32_t length() const { return m_length ? (m_length - 1) * _W + (std::upper_bound(bases.val, bases.val + _W, m_data[m_length - 1]) - bases.val) : 0; }",
			"        uint32_t ctz() const {",
			"            if (!m_length) return 0;",
			"            uint32_t i = 0, res = 0;",
			"            while (i < m_length && !m_data[i]) {}",
			"            for (uint32_t digit = m_data[i]; digit && digit % _B == 0; digit /= _B, res++) {}",
			"            return i * _W + res;",
			"        }",
			"        bint inv() const {",
			"            if (m_length == 1)",
			"                return bint(bases.val[_W * 2] / m_data[0]);",
			"            else if (m_length == 2)",
			"                return bint(__int128_t(bases.val[_W * 2]) * bases.val[_W * 2] / (__int128_t(m_data[1]) * _N + m_data[0]));",
			"            else {",
			"                bint res((*this >> (m_length - 1) / 2 * _W).inv());",
			"                return ((res + res) << (m_length - 1) / 2 * _W) - ((*this * (res * res)) >> (m_length / 2 + 1) * 2 * _W);",
			"            }",
			"        }",
			"        bint pow(uint64_t __n) const {",
			"            bint res(1), b(*this);",
			"            while (__n) {",
			"                if (__n & 1) res *= b;",
			"                if (__n >>= 1) b = self_multiply(b);",
			"            }",
			"            return res;",
			"        }",
			"        bint sqrt(uint32_t __n) const {",
			"            if (__n == 1) return *this;",
			"            uint32_t _length = length();",
			"            if (_length <= _W * 2) return bint(int64_t(std::pow((long double)(int64_t(*this)), (long double)1 / __n)));",
			"            uint32_t a = (_length - _W * 2) / __n, b = _length - a * __n;",
			"            long double log = (std::log10((long double)(uint64_t(*this >> (_length - _W * 2)))) / std::log10(_B) + (b - _W * 2)) / __n;",
			"            if (a + log <= _W) {",
			"                bint res(small(std::pow((long double)_B, a + log + (0.0000000001L))));",
			"                return res.pow(__n) <= *this ? res : --res;",
			"            }",
			"            if (uint32_t c = std::min<uint32_t>(a, _W * 2)) log += c, a -= c;",
			"            bint res(bint((__int128_t(std::pow((long double)_B, log)))) << a);",
			"            while (true) {",
			"                bint nxt(res * (__n - 1) / __n + (*this) / (res.pow(__n - 1) * __n));",
			"                if (absClose(res, nxt)) {",
			"                    if (nxt.m_data[0] < res.m_data[0]) res = nxt;",
			"                    break;",
			"                }",
			"                res = nxt;",
			"            }",
			"            while (res.pow(__n) <= *this) ++res;",
			"            return --res;",
			"        }",
			"        bint operator++(int) {",
			"            bint old(*this);",
			"            ++*this;",
			"            return old;",
			"        }",
			"        bint operator--(int) {",
			"            bint old(*this);",
			"            --*this;",
			"            return old;",
			"        }",
			"        bint &operator+=(const bint &__other) { return plus_minus_by<std::equal_to<bool>>(*this, __other); }",
			"        bint &operator-=(const bint &__other) { return plus_minus_by<std::not_equal_to<bool>>(*this, __other); }",
			"        bint &operator*=(const bint &__other) { return absCompare(__other, s_divThresh) <= 0 ? *this *= (long long)__other : (*this = *this * __other); }",
			"        bint &operator*=(long long __other) {",
			"            if (!m_length) return *this;",
			"            if (!__other) return *this = bint();",
			"            return (m_data[m_length - 1] + 1) * std::abs(__other) < _N ? inplace_multiply(*this, __other) : *this = multiply(*this, __other);",
			"        }",
			"        bint &operator/=(const bint &__other) { return absCompare(__other, s_divThresh) <= 0 ? *this /= (long long)__other : *this = div_mod<false>(*this, __other); }",
			"        bint &operator/=(long long __other) {",
			"            if (!m_length) return *this;",
			"            if (__other < 0) {",
			"                __other = -__other;",
			"                opposite();",
			"            }",
			"            long long carry = 0;",
			"            for (uint32_t i = m_length - 1; ~i; i--) {",
			"                auto [q, r] = std::div(m_data[i] + carry * _N, __other);",
			"                m_data[i] = q, carry = r;",
			"            }",
			"            return shrink();",
			"        }",
			"        bint &operator%=(const bint &__other) { return absCompare(__other, s_divThresh) <= 0 ? *this = bint(div_mod(*this, (long long)(__other)).second) : div_mod<true>(*this, __other).second; }",
			"        bint &operator%=(long long __other) { return *this = bint(divmod(*this, __other).second); }",
			"        bint &operator<<=(uint32_t __shift) { return *this = *this << __shift; }",
			"        bint &operator>>=(uint32_t __shift) {",
			"            auto [quot, rem] = std::div((int)__shift, (int)_W);",
			"            if (quot >= m_length || (quot == m_length - 1 && m_data[m_length - 1] < bases.val[rem])) return *this = bint();",
			"            std::copy_n(m_data + quot, m_length -= quot, m_data);",
			"            if (!rem) return *this;",
			"            uint64_t carry = 0;",
			"            for (uint32_t i = m_length - 1; ~i; i--) {",
			"                auto [q, r] = std::div(m_data[i], int(bases.val[rem]));",
			"                m_data[i] = carry * bases.val[_W - rem] + q;",
			"                carry = r;",
			"            }",
			"            return shrink();",
			"        }",
			"        bint operator+() const { return *this; }",
			"        bint operator-() const {",
			"            bint res(*this);",
			"            res.opposite();",
			"            return res;",
			"        }",
			"        bool operator==(const bint &__other) const { return m_negative == __other.m_negative && !absCompare(*this, __other); }",
			"        bool operator!=(const bint &__other) const { return m_negative != __other.m_negative || absCompare(*this, __other); }",
			"        bool operator<(const bint &__other) const { return m_negative == __other.m_negative ? (m_negative ? absCompare(*this, __other) > 0 : absCompare(*this, __other) < 0) : m_negative; }",
			"        bool operator>(const bint &__other) const { return m_negative == __other.m_negative ? (m_negative ? absCompare(*this, __other) < 0 : absCompare(*this, __other) > 0) : !m_negative; }",
			"        bool operator<=(const bint &__other) const { return m_negative == __other.m_negative ? (m_negative ? absCompare(*this, __other) >= 0 : absCompare(*this, __other) <= 0) : m_negative; }",
			"        bool operator>=(const bint &__other) const { return m_negative == __other.m_negative ? (m_negative ? absCompare(*this, __other) <= 0 : absCompare(*this, __other) >= 0) : !m_negative; }",
			"        explicit operator bool() const { return m_length; }",
			"        template <typename _Tp>",
			"        explicit operator _Tp() const {",
			"            _Tp res = 0;",
			"            for (uint32_t i = m_length - 1; ~i; i--) res = res * _N + m_data[i];",
			"            return m_negative ? -res : res;",
			"        }",
			"        operator std::string() const {",
			"            if (!m_length) return \"0\";",
			"            std::string res(m_length * _W, '0');",
			"            for (uint32_t i = 0; i < m_length; i++)",
			"                for (uint32_t j = i * _W, digit = m_data[i]; digit; j++, digit /= _B) res[j] = fromInt(digit % _B);",
			"            while (res.size() && res.back() == '0') res.pop_back();",
			"            if (m_negative) res.push_back('-');",
			"            std::reverse(res.begin(), res.end());",
			"            return res;",
			"        }",
			"        friend bint operator+(const bint &__a, const bint &__b) {",
			"            return plus_minus<std::equal_to<bool>>(__a, __b, [](const bint &x) { return x; });",
			"        }",
			"        friend bint operator-(const bint &__a, const bint &__b) { return plus_minus<std::not_equal_to<bool>>(__a, __b, std::negate<bint>()); }",
			"        friend bint operator*(const bint &__a, const bint &__b) {",
			"            if (&__a == &__b) return self_multiply(__a);",
			"            if (!__a.m_length || !__b.m_length) return bint();",
			"            if (absCompare(__a, s_divThresh) <= 0) return __b * (long long)__a;",
			"            if (absCompare(__b, s_divThresh) <= 0) return __a * (long long)__b;",
			"            uint32_t length = std::__bit_ceil(__a.m_length + __b.m_length - 1);",
			"            dft(s_dftBuffer, length, __a);",
			"            dft(s_dftBuffer + length, length, __b);",
			"            for (uint32_t i = 0; i < length; i++) s_dftBuffer[i] = s_mg.multiply(s_dftBuffer[i], s_dftBuffer[i + length]);",
			"            idft(s_dftBuffer, length);",
			"            bint res(empty(__a.m_length + __b.m_length, __a.m_negative != __b.m_negative));",
			"            long long carry = 0;",
			"            for (uint32_t i = 0; i + 1 < res.m_length; i++) {",
			"                auto [quot, rem] = std::div((long long)(s_mg.reduce(s_dftBuffer[i]) + carry), (long long)_N);",
			"                carry = quot, res.m_data[i] = rem;",
			"            }",
			"            res.m_data[res.m_length - 1] = carry;",
			"            res.shrink();",
			"            return res;",
			"        }",
			"        friend bint operator*(const bint &__a, long long __b) {",
			"            if (!__a.m_length || !__b) return bint();",
			"            if ((__a.m_data[__a.m_length - 1] + 1) * std::abs(__b) < _N) {",
			"                bint res(__a);",
			"                inplace_multiply(res, __b);",
			"                return res;",
			"            } else",
			"                return multiply(__a, __b);",
			"        }",
			"        friend bint operator/(const bint &__a, const bint &__b) { return absCompare(__b, s_divThresh) <= 0 ? div_mod(__a, (long long)(__b)).first : div_mod<false>(__a, __b); }",
			"        friend bint operator/(const bint &__a, long long __b) { return div_mod(__a, __b).first; }",
			"        friend bint operator%(const bint &__a, const bint &__b) { return absCompare(__b, s_divThresh) <= 0 ? bint(div_mod(__a, (long long)(__b)).second) : div_mod<true>(__a, __b).second; }",
			"        friend long long operator%(const bint &__a, long long __b) { return div_mod(__a, __b).second; }",
			"        friend bint operator<<(const bint &__a, uint32_t __shift) {",
			"            auto [quot, rem] = std::div((int)__shift, (int)_W);",
			"            bint res(empty(__a.m_length + quot + (rem > 0), __a.m_negative));",
			"            std::copy_n(__a.m_data, __a.m_length, std::fill_n(res.m_data, quot, 0));",
			"            if (!rem) return res;",
			"            uint64_t carry = 0;",
			"            for (uint32_t i = quot; i + 1 < res.m_length; i++) {",
			"                auto [q, r] = std::div((long long)(res.m_data[i]) * bases.val[rem] + carry, (long long)_N);",
			"                carry = q, res.m_data[i] = r;",
			"            }",
			"            res.m_data[res.m_length - 1] = carry;",
			"            res.shrink();",
			"            return res;",
			"        }",
			"        friend bint operator>>(const bint &__a, uint32_t __shift) {",
			"            auto [quot, rem] = std::div((int)__shift, (int)_W);",
			"            if (quot >= __a.m_length || (quot == __a.m_length - 1 && __a.m_data[__a.m_length - 1] < bases.val[rem])) return bint();",
			"            bint res(empty(__a.m_length - quot, __a.m_negative));",
			"            std::copy_n(__a.m_data + quot, __a.m_length - quot, res.m_data);",
			"            if (!rem) return res;",
			"            uint64_t carry = 0;",
			"            for (uint32_t i = res.m_length - 1; ~i; i--) {",
			"                auto [q, r] = std::div(res.m_data[i], int(bases.val[rem]));",
			"                res.m_data[i] = carry * bases.val[_W - rem] + q, carry = r;",
			"            }",
			"            res.shrink();",
			"            return res;",
			"        }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, bint &self) {",
			"            std::string number;",
			"            is >> number;",
			"            self = fromString(number.data(), number.size());",
			"            return is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const bint &self) { return os << std::string(self); }",
			"    };",
			"#pragma pack()",
			"}",
		],
		"description": "Big integer"
	},
	"Big float":{
		"prefix": "BIG",
		"body": [
			"namespace OY {",
			"    template <uint32_t _B = 10, uint32_t _W = 6, uint32_t _MAXN = 1 << 6, uint64_t _P = 9223372036737335297, uint64_t _R = 3>",
			"    struct BigFloat {",
			"        using bint = BigInt<_B, _W, _MAXN * 4, _P, _R>;",
			"        using bfloat = BigFloat<_B, _W, _MAXN, _P, _R>;",
			"        static inline int _K = (_MAXN + _W - 1) / _W;",
			"        int m_shift;",
			"        bint m_number;",
			"        BigFloat() : m_shift(0), m_number() {}",
			"        template <typename _Tp, std::enable_if_t<std::is_integral_v<_Tp> | std::is_same_v<_Tp, __int128_t>, bool> = true>",
			"        explicit BigFloat(_Tp __number) : m_shift(0), m_number(__number) { shrink(); }",
			"        template <typename _Tp, std::enable_if_t<std::is_floating_point_v<_Tp>, bool> = true>",
			"        explicit BigFloat(_Tp __number) : m_shift(std::ceil((std::log(__number) - std::log(_Tp(INT64_MAX))) / std::log(_Tp(_B)))), m_number(int64_t(__number / std::pow(_B, m_shift))) { shrink(); }",
			"        explicit BigFloat(const char *__number) : BigFloat(fromString(__number)) {}",
			"        explicit BigFloat(const std::string &__number) : BigFloat(fromString(__number.data(), __number.size())) {}",
			"        BigFloat(bint &&__number, int __shift = 0) : m_shift(__shift), m_number(std::move(__number)) { shrink(); }",
			"        BigFloat(const bint &__number, int __shift = 0) : m_shift(__shift), m_number(__number) { shrink(); }",
			"        static bfloat fromString(const char *__number) { return fromString(__number, strlen(__number)); }",
			"        static bfloat fromString(const char *__number, uint32_t __length) {",
			"            uint32_t dot = __length;",
			"            while (~--dot && __number[dot] != '.') {}",
			"            BigFloat res;",
			"            if (!~dot)",
			"                res.m_number = bint::fromString(__number, __length);",
			"            else {",
			"                char buffer[__length];",
			"                std::copy_n(__number + dot + 1, __length - dot - 1, std::copy_n(__number, dot, buffer));",
			"                res.m_number = bint::fromString(buffer, __length - 1);",
			"                res.m_shift = 1 + dot - __length;",
			"            }",
			"            res.shrink();",
			"            return res;",
			"        }",
			"        static bfloat rand(uint32_t __shift) {",
			"            uint32_t length = (bint::s_rander() % (_K - 1) + 1) * _W;",
			"            return bfloat(bint::rand(length), __shift - length);",
			"        }",
			"        static int absCompare(const bfloat &__a, const bfloat &__b) {",
			"            if (!__a.m_number.m_length) return __b.m_number.m_length ? -1 : 0;",
            "            if (!__b.m_number.m_length) return 1;",
			"            if (int alen = __a.length(), blen = __b.length(); alen != blen) return alen > blen ? 1 : -1;",
			"            for (uint32_t i = __a.m_number.m_length - 1, j = __b.m_number.m_length - 1; ~i || ~j; i--, j--) {",
			"                if (!~i) return -1;",
			"                if (!~j) return 1;",
			"                if (__a.m_number.m_data[i] != __b.m_number.m_data[j]) return __a.m_number.m_data[i] > __b.m_number.m_data[j] ? 1 : -1;",
			"            }",
			"            return 0;",
			"        }",
			"        template <typename _Operation>",
			"        static bfloat plus_minus(const bfloat &__a, const bfloat &__b) {",
			"            if (int(__a.m_number.m_length * _W + __a.m_shift) > int(__b.m_number.m_length * _W + __b.m_shift + _K * _W)) return __a;",
			"            // bint a=",
			"            return bfloat(_Operation()(__a.m_number << (__a.m_shift - __b.m_shift), __b.m_number), __b.m_shift);",
			"        }",
			"        bfloat &shrink() {",
			"            if (!m_number.m_length) {",
			"                m_shift = 0;",
			"                return *this;",
			"            }",
			"            int i = 0, j = std::upper_bound(bint::bases.val, bint::bases.val + _W, m_number.m_data[m_number.m_length - 1]) - bint::bases.val;",
			"            while (i < m_number.m_length && !m_number.m_data[i]) i++;",
			"            if (int k = !(m_number.m_data[i] % bint::bases.val[j]); m_number.m_length - i - k > _K)",
			"                i = (m_number.m_length - 1) * _W + j - _K * _W;",
			"            else",
			"                i = (i - 1 + k) * _W + j;",
			"            if (i > 0)",
			"                m_shift += i, m_number >>= i;",
			"            else if (i < 0)",
			"                m_shift += i, m_number <<= -i;",
			"            return *this;",
			"        }",
			"        bfloat &opposite() {",
			"            m_number.setSign(!m_number.m_negative);",
			"            return *this;",
			"        }",
			"        bfloat &setSign(bool __negative) {",
			"            m_number.m_negative = m_number.m_length ? __negative : false;",
			"            return *this;",
			"        }",
			"        int length() const { return m_number.m_length * _W + m_shift; }",
			"        bfloat pow(uint64_t __n) const {",
			"            bfloat res(1), b(*this);",
			"            while (__n) {",
			"                if (__n & 1) res *= b;",
			"                if (__n >>= 1) b *= b;",
			"            }",
			"            return res;",
			"        }",
			"        bfloat sqrt(uint32_t __n) const {",
			"            if (__n == 1) return *this;",
			"            bfloat res(std::pow((long double)(*this), (long double)1 / __n));",
			"            uint32_t oldK = _K;",
			"            for (_K = 2; _K < oldK; _K *= 2) res = res * (__n - 1) / __n + (*this) / (res.pow(__n - 1) * __n);",
			"            _K = oldK;",
			"            return res;",
			"        }",
			"        bfloat &operator+=(const bfloat &__other) { return *this = *this + __other; }",
			"        bfloat &operator-=(const bfloat &__other) { return *this = *this - __other; }",
			"        bfloat &operator*=(const bfloat &__other) {",
			"            m_number *= __other.m_number;",
			"            m_shift += __other.m_shift;",
			"            shrink();",
			"            return *this;",
			"        }",
			"        bfloat &operator*=(long long __other) {",
			"            m_number *= __other;",
			"            shrink();",
			"            return *this;",
			"        }",
			"        bfloat &operator/=(const bfloat &__other) { return *this = *this / __other; }",
			"        bfloat &operator/=(long long __other) { return *this = *this / __other; }",
			"        bfloat &operator<<=(uint32_t __shift) {",
			"            if (m_number.m_length) m_shift += __shift;",
			"            return *this;",
			"        }",
			"        bfloat &operator>>=(uint32_t __shift) {",
			"            if (m_number.m_length) m_shift -= __shift;",
			"            return *this;",
			"        }",
			"        bfloat operator+() const { return *this; }",
			"        bfloat operator-() const {",
			"            bfloat res(*this);",
			"            res.opposite();",
			"            return res;",
			"        }",
			"        bool operator==(const bfloat &__other) const = default;",
			"        bool operator!=(const bfloat &__other) const = default;",
			"        bool operator<(const bfloat &__other) const { return m_number.m_negative == __other.m_number.m_negative ? (m_number.m_negative ? absCompare(*this, __other) > 0 : absCompare(*this, __other) < 0) : m_number.m_negative; }",
			"        bool operator>(const bfloat &__other) const { return m_number.m_negative == __other.m_number.m_negative ? (m_number.m_negative ? absCompare(*this, __other) < 0 : absCompare(*this, __other) > 0) : !m_number.m_negative; }",
			"        bool operator<=(const bfloat &__other) const { return m_number.m_negative == __other.m_number.m_negative ? (m_number.m_negative ? absCompare(*this, __other) >= 0 : absCompare(*this, __other) <= 0) : m_number.m_negative; }",
			"        bool operator>=(const bfloat &__other) const { return m_number.m_negative == __other.m_number.m_negative ? (m_number.m_negative ? absCompare(*this, __other) <= 0 : absCompare(*this, __other) >= 0) : !m_number.m_negative; }",
			"        explicit operator bool() const { return m_number.m_length; }",
			"        template <typename _Tp, std::enable_if_t<std::is_integral_v<_Tp>, bool> = true>",
			"        explicit operator _Tp() const { return m_shift ? (_Tp(m_shift > 0 ? m_number << m_shift : m_number >> -m_shift)) : _Tp(m_number); }",
			"        template <typename _Tp, std::enable_if_t<std::is_floating_point_v<_Tp>, bool> = true>",
			"        explicit operator _Tp() const { return _Tp(m_number) * std::pow(_Tp(_B), _Tp(m_shift)); }",
			"        operator std::string() const {",
			"            if (!m_number.m_length) return \"0\";",
			"            std::string res(m_number);",
			"            if (m_shift >= 0) {",
			"                res += std::string(m_shift, '0');",
			"                return res;",
			"            }",
			"            std::reverse(res.begin(), res.end());",
			"            if (m_number.m_negative) res.pop_back();",
			"            if (res.size() <= -m_shift) res.resize(1 - m_shift, '0');",
			"            res.insert(res.begin() - m_shift, '.');",
			"            if (m_number.m_negative) res.push_back('-');",
			"            std::reverse(res.begin(), res.end());",
			"            while (res.back() == '0') res.pop_back();",
			"            if (res.back() == '.') res.pop_back();",
			"            return res;",
			"        }",
			"        friend bfloat operator+(const bfloat &__a, const bfloat &__b) {",
			"            if (!__a.m_number.m_length) return __b;",
			"            if (!__b.m_number.m_length) return __a;",
			"            if (__a.m_shift == __b.m_shift)",
			"                return bfloat(__a.m_number + __b.m_number, __a.m_shift);",
			"            else if (__a.m_shift > __b.m_shift)",
			"                return plus_minus<std::plus<bint>>(__a, __b);",
			"            else",
			"                return plus_minus<std::plus<bint>>(__b, __a);",
			"        }",
			"        friend bfloat operator-(const bfloat &__a, const bfloat &__b) {",
			"            if (!__a.m_number.m_length) return -__b;",
			"            if (!__b.m_number.m_length) return __a;",
			"            if (__a.m_shift == __b.m_shift)",
			"                return bfloat(__a.m_number - __b.m_number, __a.m_shift);",
			"            else if (__a.m_shift > __b.m_shift)",
			"                return plus_minus<std::minus<bint>>(__a, __b);",
			"            else {",
			"                bfloat res = plus_minus<std::minus<bint>>(__b, __a);",
			"                res.opposite();",
			"                return res;",
			"            }",
			"        }",
			"        friend bfloat operator*(const bfloat &__a, const bfloat &__b) { return bfloat(__a.m_number * __b.m_number, __a.m_shift + __b.m_shift); }",
			"        friend bfloat operator*(const bfloat &__a, long long __b) { return bfloat(__a.m_number * __b, __a.m_shift); }",
			"        friend bfloat operator/(const bfloat &__a, const bfloat &__b) {",
			"            if (!__a.m_number.m_length) return __a;",
			"            int a_shift = (_K * 2 - __a.m_number.m_length) * _W, b_shift = (_K - __b.m_number.m_length) * _W;",
			"            return bfloat((a_shift >= 0 ? __a.m_number << a_shift : __a.m_number >> -a_shift) / (b_shift >= 0 ? __b.m_number << b_shift : __b.m_number >> -b_shift), __a.m_shift - a_shift - __b.m_shift + b_shift);",
			"        }",
			"        friend bfloat operator/(const bfloat &__a, long long __b) {",
			"            if (!__a.m_number.m_length) return __a;",
			"            int a_up = (_K * 2 - __a.m_number.m_length) * _W;",
			"            return bfloat((__a.m_number << a_up) / __b, __a.m_shift - a_up);",
			"        }",
			"        friend bfloat operator<<(const bfloat &__a, uint32_t __shift) { return __a.m_number.m_length ? bfloat(__a.m_number, __a.m_shift + __shift) : __a; }",
			"        friend bfloat operator>>(const bfloat &__a, uint32_t __shift) { return __a.m_number.m_length ? bfloat(__a.m_number, __a.m_shift - __shift) : __a; }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, bfloat &self) {",
			"            std::string number;",
			"            is >> number;",
			"            self = fromString(number.data(), number.size());",
			"            return is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const bfloat &self) { return os << std::string(self); }",
			"    };",
			"}",
		],
		"description": "Big float"
	},
	"bitwise":{
		"prefix": "BITWISE",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Increment>",
			"    struct _BitLoop {",
			"        _Tp m_start;",
			"        _Tp m_end;",
			"        mutable _Increment m_inc;",
			"        constexpr _BitLoop(_Tp __start, _Tp __end, _Increment __inc) : m_start(__start), m_end(__end), m_inc(__inc) {}",
			"        struct _BitIterator {",
			"            mutable _Tp value;",
			"            const _BitLoop<_Tp, _Increment> &loop;",
			"            constexpr _BitIterator(_Tp start, const _BitLoop<_Tp, _Increment> &loop) : value(start), loop(loop) {}",
			"            constexpr _BitIterator &operator++() {",
			"                loop.m_inc(value);",
			"                return *this;",
			"            }",
			"            constexpr _Tp operator*() { return value; }",
			"            constexpr bool operator!=(const _BitIterator &other) const { return value != other.value; }",
			"        };",
			"        constexpr _BitIterator begin() const { return _BitIterator(m_start, *this); }",
			"        constexpr _BitIterator end() const { return _BitIterator(m_end, *this); }",
			"    };",
			"    template <typename _Tp, typename _Increment>",
			"    _BitLoop(_Tp, _Tp, _Increment) -> _BitLoop<_Tp, _Increment>;",
			"    template <typename _Tp>",
			"    struct BitwiseHelper {",
			"        static constexpr uint8_t length() { return sizeof(_Tp) * 8; }",
			"        static constexpr uint8_t countOne(_Tp mask) { return std::__popcount(mask); }",
			"        static constexpr bool isOne(_Tp mask, uint8_t i) { return i < length() ? mask >> i & _Tp(1) : false; }",
			"        static constexpr bool isZero(_Tp mask, uint8_t i) { return !isOne(mask, i); }",
			"        static constexpr bool intersect(_Tp mask1, _Tp mask2) { return mask1 & mask2; }",
			"        static constexpr bool contains(_Tp mask1, _Tp mask2) { return (mask1 & mask2) == mask2; }",
			"        static constexpr bool isContained(_Tp mask1, _Tp mask2) { return (mask1 & mask2) == mask1; }",
			"        static constexpr uint8_t countFrontZeros(_Tp mask) { return std::__countl_zero(mask); }",
			"        static constexpr uint8_t countFrontOnes(_Tp mask) { return countFrontZeros(~mask); }",
			"        static constexpr uint8_t countBackZeros(_Tp mask) { return std::__countr_zero(mask); }",
			"        static constexpr uint8_t countBackOnes(_Tp mask) { return countBackZeros(~mask); }",
			"        static constexpr _Tp makeMask() { return -1; }",
			"        static constexpr _Tp makeMask(uint8_t i) { return i < length() ? _Tp(1) << i : _Tp(0); }",
			"        static constexpr _Tp makeMask(uint8_t l, uint8_t r) { return makeBackOnes(r + 1) ^ makeBackOnes(l); }",
			"        static constexpr _Tp makeBackOnes(uint8_t k) { return k >= length() ? _Tp(-1) : (_Tp(1) << k) - 1; }",
			"        static constexpr _Tp getMask(_Tp mask, uint8_t i) { return mask & makeMask(i); }",
			"        static constexpr _Tp getMask(_Tp mask, uint8_t l, uint8_t r) { return mask & makeMask(l, r); }",
			"        static constexpr _Tp getLowestOne(_Tp mask) { return makeMask(countBackZeros(mask)); }",
			"        static constexpr _Tp getCeil(_Tp mask) { return mask ? makeMask(length() - countFrontZeros(mask - 1)) : _Tp(0); }",
			"        static constexpr _Tp getFloor(_Tp mask) { return makeMask(length() - 1 - countFrontZeros(mask)); }",
			"        static constexpr _Tp getBackOnes(_Tp mask) { return makeBackOnes(countBackOnes(mask)); }",
			"        static constexpr void setMask(_Tp &mask) { mask = makeMask(); }",
			"        static constexpr void setMask(_Tp &mask, uint8_t i) { mask |= makeMask(i); }",
			"        static constexpr void setMask(_Tp &mask, uint8_t l, uint8_t r) { mask |= makeMask(l, r); }",
			"        static constexpr void resetMask(_Tp &mask) { mask = 0; }",
			"        static constexpr void resetMask(_Tp &mask, uint8_t i) { mask &= ~makeMask(i); }",
			"        static constexpr void resetMask(_Tp &mask, uint8_t l, uint8_t r) { mask &= ~makeMask(l, r); }",
			"        static constexpr void flipMask(_Tp &mask) { mask = ~mask; }",
			"        static constexpr void flipMask(_Tp &mask, uint8_t i) { mask ^= makeMask(i); }",
			"        static constexpr void flipMask(_Tp &mask, uint8_t l, uint8_t r) { mask ^= makeMask(l, r); }",
			"        static constexpr void fillBackZerosWithOnes(_Tp &mask) { mask |= getBackOnes(~mask); }",
			"        static constexpr void fillBackOnesWithZeros(_Tp &mask) { mask ^= getBackOnes(mask); }",
			"        static constexpr auto enumOne(_Tp mask) {",
			"            return _BitLoop(countBackZeros(mask), countBackZeros(0), [=](uint8_t &k) mutable {",
			"                resetMask(mask, k);",
			"                k = countBackZeros(mask);",
			"            });",
			"        }",
			"        static constexpr auto enumOne_reversed(_Tp mask) {",
			"            return _BitLoop(uint8_t(length() - 1 - countFrontZeros(mask)), uint8_t(-1), [=](uint8_t &k) mutable {",
			"                resetMask(mask, k);",
			"                k = length() - 1 - countFrontZeros(mask);",
			"            });",
			"        }",
			"        static constexpr auto enumChoose(uint8_t n) {",
			"            assert(n < length());",
			"            return _BitLoop(_Tp(0), makeMask(n), [](_Tp &mask) { mask++; });",
			"        }",
			"        static constexpr auto enumChoose_reversed(uint8_t n) {",
			"            assert(n < length());",
			"            return _BitLoop(makeBackOnes(n), _Tp(-1), [](_Tp &mask) { mask--; });",
			"        }",
			"        static constexpr auto enumChoose(uint8_t n, uint8_t k) {",
			"            assert(n < length() && k <= n);",
			"            return _BitLoop(makeBackOnes(k), makeMask(n) | makeBackOnes(k - 1), [k](_Tp &mask) {",
			"                int a = countBackZeros(mask);",
			"                fillBackZerosWithOnes(mask);",
			"                mask += makeBackOnes(countBackOnes(mask) - a - 1) + 1;",
			"            });",
			"        }",
			"        static constexpr auto enumChoose_reversed(uint8_t n, uint8_t k) {",
			"            assert(n < length() && k <= n);",
			"            return _BitLoop(makeMask(n - k, n - 1), _Tp(-1), [k](_Tp &mask) {",
			"                if (uint8_t a = countBackOnes(mask); a < k) {",
			"                    fillBackOnesWithZeros(mask);",
			"                    int b = countBackZeros(mask);",
			"                    flipMask(mask, b - a - 1, b);",
			"                } else",
			"                    mask = _Tp(-1);",
			"            });",
			"        }",
			"        static constexpr auto enumSubOf(_Tp mask) {",
			"            assert(mask != _Tp(-1));",
			"            return _BitLoop(_Tp(0), _Tp(-1), [mask](_Tp &cur) {",
			"                if (cur ^ mask)",
			"                    cur ^= (_Tp(1) << countBackZeros(cur ^ mask) + 1) - 1 & mask;",
			"                else",
			"                    cur = -1;",
			"            });",
			"        }",
			"        static constexpr auto enumSubOf_reversed(_Tp mask) {",
			"            assert(mask != _Tp(-1));",
			"            return _BitLoop(mask, _Tp(-1), [mask](_Tp &cur) { cur = cur ? (cur - 1) & mask : _Tp(-1); });",
			"        }",
			"        static constexpr auto enumSubOf(_Tp mask, uint8_t k) {",
			"            assert(mask != _Tp(-1) && k <= countOne(mask));",
			"            _Tp res[length() + 1]{0};",
			"            for (int i = 0, j = 0; i < length(); i++)",
			"                if (mask & makeMask(i)) res[++j] = mask & makeBackOnes(i + 1);",
			"            return _BitLoop(res[k], _Tp(-1), [=](_Tp &cur) {",
			"                if (_Tp back = makeBackOnes(countBackZeros(cur)) & mask; back < (mask ^ cur)) {",
			"                    uint8_t a = countBackZeros(mask - cur - back);",
			"                    _Tp mid = makeBackOnes(a) & cur;",
			"                    cur += makeMask(a) + res[countOne(mid) - 1] - mid;",
			"                } else",
			"                    cur = -1;",
			"            });",
			"        }",
			"        static constexpr auto enumSubOf_reversed(_Tp mask, uint8_t k) {",
			"            assert(mask != _Tp(-1) && k <= countOne(mask));",
			"            _Tp res[length() + 1]{0};",
			"            for (int i = 0, j = 0; i < length(); i++)",
			"                if (mask & makeMask(i)) res[++j] = mask & makeBackOnes(i + 1);",
			"            return _BitLoop(mask - res[countOne(mask) - k], _Tp(-1), [=](_Tp &cur) {",
			"                if (_Tp back = makeBackOnes(countBackZeros(mask ^ cur)) & mask; back < cur) {",
			"                    cur ^= back ^ (makeBackOnes(countBackZeros(cur ^ back) + 1) & mask);",
			"                    cur ^= res[countOne(cur) - k];",
			"                } else",
			"                    cur = -1;",
			"            });",
			"        }",
			"        template <uint8_t k = length()>",
			"        static std::string to_string(_Tp mask) {",
			"            const uint8_t ki = k > 0 ? k : length();",
			"            std::string res;",
			"            res.reserve(ki);",
			"            for (auto i = ki - 1; i >= 0; i--) res.push_back(isOne(mask, i) ? '1' : '0');",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "bitwise helper"
	},
	"BSGS":{
		"prefix": "BSGS",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, uint32_t _HashP, uint32_t _HashN>",
			"    _ModType BSGS(_ModType __a, _ModType __r, _ModType __P, _ModType __coef) {",
			"        if (__P == 1) return 0;",
			"        Barrett<_ModType> brt(__P);",
			"        __a = brt.mod(__a);",
			"        __r = brt.mod(__r);",
			"        __coef = brt.mod(__coef);",
			"        if (__r == __coef) return 0;",
			"        if (!__coef) return -1;",
			"        if (!__a) return __r ? -1 : 1;",
			"#pragma pack(4)",
			"        static struct node {",
			"            _ModType key;",
			"            uint32_t value;",
			"            uint32_t next;",
			"        } hash_item[_HashN];",
			"#pragma pack()",
			"        static uint32_t hash_first[_HashP]{}, *hash_used[_HashP], hash_used_cnt{};",
			"        while (hash_used_cnt) *hash_used[--hash_used_cnt] = 0;",
			"        uint32_t hash_cnt = 0, sqrt = std::ceil(std::sqrt(__P));",
			"        for (uint32_t i = 0; i < sqrt; i++) {",
			"            uint32_t r = Modular32<_HashP>::mod(__r);",
			"            hash_used[hash_used_cnt++] = hash_first + r;",
			"            hash_item[++hash_cnt] = node{__r, i, hash_first[r]};",
			"            hash_first[r] = hash_cnt;",
			"            __r = brt.multiply_64(__r, __a);",
			"        }",
			"        __a = brt.pow_64(__a, sqrt);",
			"        __r = __coef;",
			"        for (uint32_t i = 1; i <= sqrt; i++) {",
			"            __r = brt.multiply_64(__r, __a);",
			"            uint32_t x = hash_first[Modular32<_HashP>::mod(__r)];",
			"            while (x && hash_item[x].key != __r) x = hash_item[x].next;",
			"            if (x) return i * sqrt - hash_item[x].value;",
			"        }",
			"        return -1;",
			"    }",
			"    template <typename _ModType, uint32_t _HashP, uint32_t _HashN>",
			"    constexpr _ModType BSGS_ex(_ModType __a, _ModType __r, _ModType __P) {",
			"        if (__P == 1) return 0;",
			"        Barrett<_ModType> brt(__P);",
			"        __a = brt.mod(__a);",
			"        __r = brt.mod(__r);",
			"        if (__r == 1) return 0;",
			"        if (!__a) return __r ? -1 : 1;",
			"        _ModType a = 1, r = __r, P = __P;",
			"        uint32_t k = 0;",
			"        while (true) {",
			"            _ModType g = std::gcd(__a, P);",
			"            if (g == 1) break;",
			"            _ModType q = r / g;",
			"            if (r > q * g) return -1;",
			"            k++;",
			"            r = q;",
			"            P /= g;",
			"            if (a = brt.multiply(a, __a / g) % P; a == r) return k;",
			"        }",
			"        _ModType res = BSGS<_ModType, _HashP, _HashN>(__a % P, r, P, a);",
			"        return ~res ? res + k : res;",
			"    }",
			"    template <uint32_t _HashP, uint32_t _HashN>",
			"    constexpr auto BSGS32 = BSGS<uint32_t, _HashP, _HashN>;",
			"    template <uint32_t _HashP, uint32_t _HashN>",
			"    constexpr auto BSGS64 = BSGS<uint64_t, _HashP, _HashN>;",
			"    template <uint32_t _HashP, uint32_t _HashN>",
			"    constexpr auto BSGS_ex32 = BSGS_ex<uint32_t, _HashP, _HashN>;",
			"    template <uint32_t _HashP, uint32_t _HashN>",
			"    constexpr auto BSGS_ex64 = BSGS_ex<uint64_t, _HashP, _HashN>;",
			"}",
		],
		"description": "BSGS"
	},
	"Cantor rank":{
		"prefix": "CANTOR",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct CantorRank {",
			"        template <typename _Iterator>",
			"        static _Tp rawQuery(_Iterator __first, _Iterator __last) {",
			"            const uint32_t n = __last - __first;",
			"            BIT<uint32_t> counter(*std::max_element(__first, __last) + 1);",
			"            _Tp permutation(1), res(0);",
			"            for (uint32_t index = n - 1; ~index; index--) {",
			"                uint32_t x(*(__first + index));",
			"                if (x) res += permutation * _Tp(counter.presum(x - 1));",
			"                permutation *= _Tp(n - index);",
			"                counter.add(x, 1);",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Iterator, typename _Fp = typename std::iterator_traits<_Iterator>::value_type>",
			"        static _Tp query(_Iterator __first, _Iterator __last) {",
			"            const uint32_t n = __last - __first;",
			"            _Fp sorted[n];",
			"            uint32_t id[n];",
			"            std::copy_n(__first, n, sorted);",
			"            std::sort(sorted, sorted + n);",
			"            for (uint32_t i = 0; i < n; i++) id[i] = std::lower_bound(sorted, sorted + n, *(__first + i)) - sorted;",
			"            return rawQuery(id, id + n);",
			"        }",
			"    };",
			"    template <typename _Tp>",
			"    struct CantorRank_ex {",
			"        std::vector<_Tp> m_invTable;",
			"        CantorRank_ex(uint32_t __maxNumber) : m_invTable(getInverseTable<_Tp>(__maxNumber)) {}",
			"        template <typename _Iterator>",
			"        _Tp rawQuery(_Iterator __first, _Iterator __last) const {",
			"            const uint32_t n = __last - __first;",
			"            BIT<uint32_t> counter(*std::max_element(__first, __last) + 1);",
			"            _Tp permutation(1), res(0);",
			"            for (uint32_t index = n - 1; ~index; index--) {",
			"                uint32_t x = *(__first + index), s1 = counter.presum(x), s2 = x ? counter.presum(x - 1) : 0;",
			"                permutation *= m_invTable[s1 - s2 + 1];",
			"                if (x) res += permutation * s2;",
			"                permutation *= _Tp(n - index);",
			"                counter.add(x, 1);",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Iterator, typename _Fp = typename std::iterator_traits<_Iterator>::value_type>",
			"        _Tp query(_Iterator __first, _Iterator __last) const {",
			"            const uint32_t n = __last - __first;",
			"            _Fp sorted[n];",
			"            uint32_t id[n];",
			"            std::copy_n(__first, n, sorted);",
			"            std::sort(sorted, sorted + n);",
			"            const uint32_t unique_n = std::unique(sorted, sorted + n) - sorted;",
			"            for (uint32_t i = 0; i < n; i++) id[i] = std::lower_bound(sorted, sorted + unique_n, *(__first + i)) - sorted;",
			"            return rawQuery(id, id + n);",
			"        }",
			"    };",
			"}",
		],
		"description": "Cantor rank"
	},
	"Cantor sequence":{
		"prefix": "CANTOR",
		"body": [
			"namespace OY {",
			"    std::vector<uint32_t> CantorSequence(uint32_t n, uint64_t k) {",
			"        uint64_t permutation = 1;",
			"        std::vector<uint32_t> res(n);",
			"        for (uint32_t index = n - 1; ~index; index--) {",
			"            res[index] = k / permutation % (n - index);",
			"            permutation *= n - index;",
			"        }",
			"        if (k >= permutation) return {};",
			"        bool counter[n];",
			"        std::fill(counter, counter + n, true);",
			"        for (uint32_t &id : res)",
			"            for (uint32_t i = 0, j = 0; i < n; i++)",
			"                if (counter[i] && !id--) {",
			"                    counter[id = i] = false;",
			"                    break;",
			"                }",
			"        return res;",
			"    }",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    std::vector<_Tp> CantorSequence_ex(_Iterator first, _Iterator last, uint64_t k) {",
			"        const uint32_t n = last - first;",
			"        _Tp sorted[n];",
			"        std::copy(first, last, sorted);",
			"        std::sort(sorted, sorted + n);",
			"        const uint32_t unique_n = std::unique(sorted, sorted + n) - sorted;",
			"        uint32_t counter[unique_n];",
			"        std::fill(counter, counter + unique_n, 0);",
			"        for (auto it = first; it != last; ++it) counter[std::lower_bound(sorted, sorted + unique_n, *it) - sorted]++;",
			"        uint64_t permutation = 1, number = 0;",
			"        for (uint32_t c : counter)",
			"            for (uint32_t j = 1; j <= c; j++) permutation = permutation * ++number / j;",
			"        if (permutation <= k) return {};",
			"        std::vector<_Tp> res(n);",
			"        for (uint32_t i = 0; i < n; i++) {",
			"            uint64_t cur = 0, presum = 0;",
			"            while (true) {",
			"                uint64_t s = permutation * counter[cur] / (n - i);",
			"                if (presum + s > k) {",
			"                    permutation = s;",
			"                    break;",
			"                }",
			"                presum += s;",
			"                cur++;",
			"            }",
			"            k -= presum;",
			"            counter[cur]--;",
			"            res[i] = sorted[cur];",
			"        }",
			"        return res;",
			"    }",
			"}",
		],
		"description": "Cantor sequence"
	},
	"Catalan table":{
		"prefix": "CATALAN",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    std::vector<_Tp> getCatalanTable(uint32_t n) {",
			"        std::vector<_Tp> invTable(getInverseTable<_Tp>(n + 1)), res;",
			"        res.reserve(n + 1);",
			"        res.emplace_back(1);",
			"        for (uint32_t i = 1; i <= n; i++) res.push_back(res.back() * invTable[i + 1] * _Tp(i * 4 - 2));",
			"        return res;",
			"    }",
			"}",
		],
		"description": "Catalan table"
	},
	"ChineseRemainderTheorem":{
		"prefix": "CRT",
		"body": [
			"namespace OY {",
			"    class ChineseRemainderTheorem {",
			"        struct node {",
			"            uint64_t r, d;",
			"        };",
			"        std::vector<node> m_sub;",
			"        uint64_t m_prod;",
			"",
			"    public:",
			"        ChineseRemainderTheorem(uint32_t __n = 0) : m_prod{1} { m_sub.reserve(__n); }",
			"        template <bool _Check = false>",
			"        std::conditional_t<_Check, bool, void> add(uint64_t __r, uint64_t __d) {",
			"            m_sub.push_back({__r, __d});",
			"            m_prod *= __d;",
			"            if constexpr (_Check) return std::gcd(m_prod, __d) == 1;",
			"        }",
			"        uint64_t query() const {",
			"            uint64_t res = 0;",
			"            Barrett64 brt(m_prod);",
			"            for (auto [r, d] : m_sub) {",
			"                uint64_t rest = m_prod / d, inv = DynamicModularInverse64(d).query_exgcd(rest);",
			"                res = brt.plus(res, brt.multiply_ld(brt.multiply_ld(r, rest), inv));",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"    class ChineseRemainderTheorem_ex {",
			"        uint64_t m_rem, m_div;",
			"",
			"    public:",
			"        ChineseRemainderTheorem_ex() : m_rem{0}, m_div{1} {}",
			"        bool add(uint64_t __r, uint64_t __d) {",
			"            auto [g, res, k1] = exGCD(m_div, __d, __r - m_rem);",
			"            if (res != __r - m_rem) return false;",
			"            m_rem += m_div * k1;",
			"            m_div = m_div / g * __d;",
			"            m_rem %= m_div;",
			"            return true;",
			"        }",
			"        uint64_t query() const { return m_rem; }",
			"    };",
			"}",
		],
		"description": "ChineseRemainderTheorem"
	},
	"ChirpZ":{
		"prefix": "CZ",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, template <typename, uint32_t> typename _Solver, uint32_t _MAXN>",
			"    std::vector<_Tp> ChirpZ(const ModPolynomial<_Tp, _Solver, _MAXN> &poly, _Tp x, uint32_t n) {",
			"        if (poly.m_terms.empty()) return std::vector<_Tp>(n, 0);",
			"        uint32_t length = std::__bit_ceil(poly.m_terms.size() + n - 1);",
			"        _Solver<_Tp, _MAXN> sol(length);",
			"        const _Tp inv = 1 / x;",
			"        _Tp cur = 1, pow = 1;",
			"        std::vector<_Tp> a(length), b(length);",
			"        for (uint32_t i = 0; i < poly.m_terms.size(); i++, cur *= pow, pow *= inv) a[i] = poly.m_terms[i] * cur;",
			"        std::reverse(a.begin(), a.begin() + poly.m_terms.size());",
			"        cur = 1, pow = 1;",
			"        for (uint32_t i = 0; i < length; i++, cur *= pow, pow *= x) b[i] = cur;",
			"        auto aa = sol.dft(a), bb = sol.dft(b);",
			"        sol.multiply(aa, bb);",
			"        std::vector<_Tp> res = sol.idft(aa, bb);",
			"        cur = 1, pow = 1;",
			"        for (uint32_t i = poly.m_terms.size() - 1, j = n; j--; i++, cur *= pow, pow *= inv) res[i] *= cur;",
			"        return std::vector<_Tp>(res.begin() + poly.m_terms.size() - 1, res.begin() + poly.m_terms.size() - 1 + n);",
			"    }",
			"}",
		],
		"description": "Chirp Z"
	},
	"Cipolla":{
		"prefix": "CIPOLLA",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    constexpr bool isQuadraticResidue(_ModType a, _ModType P) {",
			"        // assert(isPrime(P));",
			"        return Barrett<_ModType>(P).pow(a, (P - 1) >> 1) == 1;",
			"    }",
			"    template <typename _ModType>",
			"    constexpr _ModType Cipolla(_ModType a, _ModType P) {",
			"        if (P == 2) return a & 1 ? 1 : 0;",
			"        if constexpr (std::is_same_v<_ModType, uint32_t>) {",
			"            Barrett<_ModType> brt(P);",
			"            a = brt.mod(a);",
			"            if (brt.pow(a, (P - 1) / 2) != 1) return 0;",
			"            _ModType b = 1;",
			"            while (brt.pow(b * b + P - a, (P - 1) / 2) == 1) b++;",
			"            _ModType neg = brt.plus(b * b, P - a);",
			"            struct node {",
			"                _ModType a, b;",
			"            };",
			"            auto mul = [&](node &x, const node &y) {",
			"                _ModType _a = brt.plus(brt.multiply(x.a, y.a), brt.multiply(brt.multiply(x.b, y.b), neg)), _b = brt.plus(brt.multiply(x.b, y.a), brt.multiply(x.a, y.b));",
			"                x = {_a, _b};",
			"            };",
			"            auto pow = [&](node x, uint32_t _n) {",
			"                node res{1, 0};",
			"                while (_n) {",
			"                    if (_n & 1) mul(res, x);",
			"                    mul(x, x);",
			"                    _n >>= 1;",
			"                }",
			"                return res;",
			"            };",
			"            _ModType ans = pow({b, 1}, (P + 1) >> 1).a;",
			"            return ans > P >> 1 ? P - ans : ans;",
			"        } else {",
			"            Montgomery<_ModType> mg(P);",
			"            a = mg.init(a);",
			"            _ModType one = mg.raw_init(1);",
			"            if (mg.pow(a, (P - 1) / 2) != one) return 0;",
			"            _ModType b = one;",
			"            while (true) {",
			"                _ModType c = mg.plus(mg.multiply(b, b), P - a);",
			"                if (mg.pow(c, (P - 1) / 2) != one) break;",
			"                b = mg.plus(b, one);",
			"            }",
			"            _ModType neg = mg.plus(mg.multiply(b, b), P - a);",
			"            struct node {",
			"                _ModType a, b;",
			"            };",
			"            auto mul = [&](node &x, const node &y) {",
			"                _ModType _a = mg.plus(mg.multiply(x.a, y.a), mg.multiply(mg.multiply(x.b, y.b), neg)), _b = mg.plus(mg.multiply(x.b, y.a), mg.multiply(x.a, y.b));",
			"                x = {_a, _b};",
			"            };",
			"            auto pow = [&](node x, uint32_t _n) {",
			"                node res{one, 0};",
			"                while (_n) {",
			"                    if (_n & 1) mul(res, x);",
			"                    mul(x, x);",
			"                    _n >>= 1;",
			"                }",
			"                return res;",
			"            };",
			"            _ModType ans = mg.reduce(pow({b, one}, (P + 1) >> 1).a);",
			"            return ans > P >> 1 ? P - ans : ans;",
			"        }",
			"    }",
			"    constexpr auto Cipolla32 = Cipolla<uint32_t>;",
			"    constexpr auto Cipolla64 = Cipolla<uint64_t>;",
			"}",
		],
		"description": "Cipolla"
	},
	"combination table":{
		"prefix": "COMB",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct CombinationTable {",
			"        std::vector<_Tp> m_factorial, m_factorialInv;",
			"        CombinationTable(uint32_t __n) : m_factorial(__n + 1, _Tp(1)), m_factorialInv(__n + 1) {",
			"            for (uint32_t i = 1; i <= __n; i++) m_factorial[i] = m_factorial[i - 1] * _Tp(i);",
			"            m_factorialInv.back() = m_factorial.back().inv();",
			"            for (uint32_t i = __n - 1; ~i; i--) m_factorialInv[i] = m_factorialInv[i + 1] * _Tp(i + 1);",
			"        }",
			"        _Tp comb(uint32_t __n, uint32_t __m) const {",
			"            if (__n < __m) return 0;",
			"            if (__n == __m) return 1;",
			"            return m_factorial[__n] * m_factorialInv[__m] * m_factorialInv[__n - __m];",
			"        }",
			"        _Tp perm(uint32_t __n) const { return m_factorial[__n]; }",
			"        _Tp perm(uint32_t __n, uint32_t __m) const {",
			"            if (__n < __m) return 0;",
			"            if (__n == __m) return m_factorial[__n];",
			"            return m_factorial[__n] * m_factorialInv[__n - __m];",
			"        }",
			"        template <typename _Fp>",
			"        _Tp perm(const std::vector<_Fp> &__ns) const {",
			"            _Tp res(m_factorial[std::accumulate(__ns.begin(), __ns.end(), 0)]);",
			"            for (_Fp n : __ns) res *= m_factorialInv[n];",
			"            return res;",
			"        }",
			"        _Tp nonadjacentPerm(uint32_t __n, uint32_t __m) const {",
			"            if (__n < __m) return 0;",
			"            return comb(__n - __m + 1, __m);",
			"        }",
			"        _Tp staggeredPerm(uint32_t __n) const {",
			"            static std::vector<_Tp> s_res{1, 0};",
			"            while (s_res.size() < __n + 1) s_res.push_back((s_res[s_res.size() - 2] + s_res.back()) * _Tp(s_res.size() - 1));",
			"            return s_res[__n];",
			"        }",
			"        _Tp circularPerm(uint32_t __n) const { return m_factorial[__n - 1]; }",
			"        _Tp circularPerm(uint32_t __n, uint32_t __m) const {",
			"            if (!__m) return 1;",
			"            return comb(__n, __m) * m_factorial[__m - 1];",
			"        }",
			"    };",
			"}",
		],
		"description": "combination table"
	},
	"dynamic matrix":{
		"prefix": "MATRIX",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct DynamicMatrix {",
			"        std::vector<std::vector<_Tp>> m_val;",
			"        DynamicMatrix(const std::vector<std::vector<_Tp>> &__vals) : m_val(__vals) {}",
			"        DynamicMatrix(uint32_t __m, uint32_t __n, _Tp __val = _Tp()) : m_val(__m, std::vector<_Tp>(__n, __val)) {}",
			"        uint32_t row() const { return m_val.size(); }",
			"        uint32_t column() const { return m_val[0].size(); }",
			"        static DynamicMatrix<_Tp> unit(uint32_t __m) {",
			"            DynamicMatrix<_Tp> res(__m, __m, 0);",
			"            for (uint32_t i = 0; i < __m; i++) res[i][i] = 1;",
			"            return res;",
			"        }",
			"        _Tp *operator[](uint32_t __i) { return m_val[__i].data(); }",
			"        const _Tp *operator[](uint32_t __i) const { return m_val[__i].data(); }",
			"        DynamicMatrix<_Tp> &operator+=(_Tp __a) {",
			"            for (std::vector<_Tp> &row : m_val)",
			"                for (_Tp &a : row) a += __a;",
			"            return *this;",
			"        }",
			"        DynamicMatrix<_Tp> &operator-=(_Tp __a) {",
			"            for (std::vector<_Tp> &row : m_val)",
			"                for (_Tp &a : row) a -= __a;",
			"            return *this;",
			"        }",
			"        DynamicMatrix<_Tp> &operator*=(_Tp __a) {",
			"            for (std::vector<_Tp> &row : m_val)",
			"                for (_Tp &a : row) a *= __a;",
			"            return *this;",
			"        }",
			"        DynamicMatrix<_Tp> &operator+=(const DynamicMatrix<_Tp> &__other) {",
			"            assert(row() == __other.row() && column() == __other.column());",
			"            const uint32_t r = row(), c = column();",
			"            for (uint32_t i = 0; i < r; i++)",
			"                for (uint32_t j = 0; j < c; j++) m_val[i][j] += __other[i][j];",
			"            return *this;",
			"        }",
			"        DynamicMatrix<_Tp> &operator-=(const DynamicMatrix<_Tp> &__other) {",
			"            assert(row() == __other.row() && column() == __other.column());",
			"            const uint32_t r = row(), c = column();",
			"            for (uint32_t i = 0; i < r; i++)",
			"                for (uint32_t j = 0; j < c; j++) m_val[i][j] -= __other[i][j];",
			"            return *this;",
			"        }",
			"        DynamicMatrix<_Tp> pow(uint64_t __n) const {",
			"            assert(row() == column());",
			"            DynamicMatrix<_Tp> res = unit(row()), a = *this;",
			"            while (__n) {",
			"                if (__n & 1) res = res * a;",
			"                a = a * a;",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Fp>",
			"        friend DynamicMatrix<_Tp> operator+(const DynamicMatrix<_Tp> &__a, const _Fp &__b) { return DynamicMatrix<_Tp>(__a) += __b; }",
			"        template <typename _Fp>",
			"        friend DynamicMatrix<_Tp> operator-(const DynamicMatrix<_Tp> &__a, const _Fp &__b) { return DynamicMatrix<_Tp>(__a) -= __b; }",
			"        friend DynamicMatrix<_Tp> operator*(const DynamicMatrix<_Tp> &__a, const _Tp &__b) { return DynamicMatrix<_Tp>(__a) *= __b; }",
			"        friend DynamicMatrix<_Tp> operator*(const DynamicMatrix<_Tp> &__a, const DynamicMatrix<_Tp> &__b) {",
			"            assert(__a.column() == __b.row());",
			"            const uint32_t r = __a.row(), c = __a.column(), l = __b.column();",
			"            DynamicMatrix<_Tp> res(r, l, 0);",
			"            for (uint32_t i = 0; i < r; i++)",
			"                for (uint32_t j = 0; j < c; j++) {",
			"                    _Tp a = __a[i][j];",
			"                    for (uint32_t k = 0; k < l; k++) res[i][k] += a * __b[j][k];",
			"                }",
			"            return res;",
			"        }",
			"        friend bool operator==(const DynamicMatrix<_Tp> &__a, const DynamicMatrix<_Tp> &__b) { return __a.m_val == __b.m_val; }",
			"        friend bool operator!=(const DynamicMatrix<_Tp> &__a, const DynamicMatrix<_Tp> &__b) { return __a.m_val != __b.m_val; }",
			"    };",
			"};",
		],
		"description": "dynamic matrix"
	},
	"dynamic modint":{
		"prefix": "MOD",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _Id>",
			"    struct DynamicModInt {",
			"        using mint = DynamicModInt<_ModType, _Id>;",
			"        _ModType m_val;",
			"        static inline Barrett<_ModType> s_brt=Barrett<_ModType>(_Id);",
			"        static inline bool s_isPrime = true;",
			"        constexpr DynamicModInt() = default;",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp>> * = nullptr>",
			"        constexpr DynamicModInt(_Tp __val) : m_val(0) {",
			"            int64_t x = int64_t(__val) % int64_t(mod());",
			"            if (x < 0) x += mod();",
			"            m_val = x;",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp>> * = nullptr>",
			"        constexpr DynamicModInt(_Tp __val) : m_val(s_brt.mod(__val)) {}",
			"        static constexpr mint raw(_ModType __val) {",
			"            mint res;",
			"            res.m_val = __val;",
			"            return res;",
			"        }",
			"        static constexpr void setMod(_ModType __P, bool __isPrime = false) {",
			"            assert(__P > 1 && __P < 1ull << 63);",
			"            s_brt = Barrett<_ModType>(__P);",
			"            s_isPrime = __isPrime;",
			"        }",
			"        static constexpr _ModType mod() { return s_brt.mod(); }",
			"        constexpr _ModType val() const { return m_val; }",
			"        constexpr mint pow(uint64_t __n) const { return s_brt.pow(m_val, __n); }",
			"        constexpr mint inv() const { return s_isPrime ? inv_Fermat() : inv_exgcd(); }",
			"        constexpr mint inv_exgcd() const {",
			"            _ModType x = mod(), y = m_val, m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                std::swap(x, y);",
			"                std::swap(m0, m1);",
			"            }",
			"            if (m0 >= mod()) m0 += mod() / x;",
			"            return raw(m0);",
			"        }",
			"        constexpr mint inv_Fermat() const { return pow(mod() - 2); }",
			"        constexpr mint &operator++() {",
			"            if (++m_val == mod()) m_val = 0;",
			"            return *this;",
			"        }",
			"        constexpr mint &operator--() {",
			"            if (m_val-- == 0) m_val = mod() - 1;",
			"            return *this;",
			"        }",
			"        constexpr mint operator++(int) {",
			"            mint old(*this);",
			"            ++*this;",
			"            return old;",
			"        }",
			"        constexpr mint operator--(int) {",
			"            mint old(*this);",
			"            --*this;",
			"            return old;",
			"        }",
			"        constexpr mint &operator+=(const mint &__other) {",
			"            m_val = s_brt.plus(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator-=(const mint &__other) {",
			"            m_val = s_brt.minus(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator*=(const mint &__other) {",
			"            m_val = s_brt.multiply(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator/=(const mint &__other) { return *this *= __other.inv(); }",
			"        constexpr mint operator+() const { return *this; }",
			"        constexpr mint operator-() const { return raw(m_val ? mod() - m_val : 0); }",
			"        constexpr bool operator==(const mint &__other) const { return m_val == __other.m_val; }",
			"        constexpr bool operator!=(const mint &__other) const { return m_val != __other.m_val; }",
			"        constexpr bool operator<(const mint &__other) const { return m_val < __other.m_val; }",
			"        constexpr bool operator>(const mint &__other) const { return m_val > __other.m_val; }",
			"        constexpr bool operator<=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        constexpr bool operator>=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        template <typename _Tp>",
			"        constexpr explicit operator _Tp() const { return _Tp(m_val); }",
			"        constexpr friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }",
			"        constexpr friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }",
			"        constexpr friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }",
			"        constexpr friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, mint &self) { return is >> self.m_val; }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const mint &self) { return os << self.m_val; }",
			"    };",
			"    template <uint32_t _Id>",
			"    using DynamicModInt32 = DynamicModInt<uint32_t, _Id>;",
			"    template <uint64_t _Id>",
			"    using DynamicModInt64 = DynamicModInt<uint64_t, _Id>;",
			"}",
		],
		"description": "dynamic modint"
	},
	"dynamic montgomery modint":{
		"prefix": "MG",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _Id>",
			"    struct DynamicMontgomeryModInt {",
			"        using mint = DynamicMontgomeryModInt<_ModType, _Id>;",
			"        using _FastType = typename Montgomery<_ModType>::_FastType;",
			"        static inline Montgomery<_ModType> s_mg = Montgomery<_ModType>(_Id);",
			"        static inline bool s_isPrime = true;",
			"        _FastType m_val;",
			"        constexpr DynamicMontgomeryModInt() = default;",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp>, bool> = true>",
			"        constexpr DynamicMontgomeryModInt(_Tp __val) : m_val(0) {",
			"            int64_t x = int64_t(__val) % int64_t(mod());",
			"            if (x < 0) x += mod();",
			"            m_val = s_mg.init(x);",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp>, bool> = true>",
			"        constexpr DynamicMontgomeryModInt(_Tp __val) : m_val(s_mg.init(__val)) {}",
			"        static constexpr mint raw(_FastType __val) {",
			"            mint res;",
			"            res.m_val = __val;",
			"            return res;",
			"        }",
			"        static constexpr void setMod(_ModType __P, bool __isPrime = false) {",
			"            assert(__P % 2 == 1 && __P > 1 && __P <= _MontgomeryTag<_ModType>::limit);",
			"            s_mg = Montgomery<_ModType>(__P);",
			"            s_isPrime = __isPrime;",
			"        }",
			"        static constexpr _ModType mod() { return s_mg.mod(); }",
			"        constexpr _ModType val() const { return s_mg.reduce(m_val); }",
			"        constexpr mint pow(uint64_t __n) const { return raw(s_mg.pow(m_val, __n)); }",
			"        constexpr mint inv() const { return s_isPrime ? inv_Fermat() : inv_exgcd(); }",
			"        constexpr mint inv_exgcd() const {",
			"            _ModType x = mod(), y = val(), m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                std::swap(x, y);",
			"                std::swap(m0, m1);",
			"            }",
			"            if (m0 >= mod()) m0 += mod() / x;",
			"            return m0;",
			"        }",
			"        constexpr mint inv_Fermat() const { return pow(mod() - 2); }",
			"        constexpr mint &operator++() {",
			"            (*this) += raw(s_mg.raw_init(1));",
			"            return *this;",
			"        }",
			"        constexpr mint &operator--() {",
			"            (*this) += raw(s_mg.raw_init(mod() - 1));",
			"            return *this;",
			"        }",
			"        constexpr mint operator++(int) {",
			"            mint old(*this);",
			"            ++*this;",
			"            return old;",
			"        }",
			"        constexpr mint operator--(int) {",
			"            mint old(*this);",
			"            --*this;",
			"            return old;",
			"        }",
			"        constexpr mint &operator+=(const mint &__other) {",
			"            m_val = s_mg.plus(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator-=(const mint &__other) {",
			"            m_val = s_mg.minus(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator*=(const mint &__other) {",
			"            m_val = s_mg.multiply(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator/=(const mint &__other) { return *this *= __other.inv(); }",
			"        constexpr mint operator+() const { return *this; }",
			"        constexpr mint operator-() const { return raw(m_val ? mod() - m_val : 0); }",
			"        constexpr bool operator==(const mint &__other) const { return m_val == __other.m_val; }",
			"        constexpr bool operator!=(const mint &__other) const { return m_val != __other.m_val; }",
			"        constexpr bool operator<(const mint &__other) const { return m_val < __other.m_val; }",
			"        constexpr bool operator>(const mint &__other) const { return m_val > __other.m_val; }",
			"        constexpr bool operator<=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        constexpr bool operator>=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        template <typename _Tp>",
			"        constexpr explicit operator _Tp() const { return _Tp(s_mg.reduce(m_val)); }",
			"        constexpr friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }",
			"        constexpr friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }",
			"        constexpr friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }",
			"        constexpr friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, mint &self) {",
			"            _ModType x;",
			"            is >> x;",
			"            self = mint(x);",
			"            return is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const mint &self) { return os << self.val(); }",
			"    };",
			"    template <uint32_t _Id>",
			"    using DynamicMontgomeryModInt32 = DynamicMontgomeryModInt<uint32_t, _Id>;",
			"    template <uint64_t _Id>",
			"    using DynamicMontgomeryModInt64 = DynamicMontgomeryModInt<uint64_t, _Id>;",
			"}",
		],
		"description": "dynamic montgomery modint"
	},
	"Eratosthenes Sieve":{
		"prefix": "SIEVE",
		"body": [
			"namespace OY {",
			"    template <uint32_t _N, bool _B>",
			"    struct _EratosthenesSieveArray {",
			"        uint32_t data[_N + 1];",
			"        void set(int __i, uint32_t __val) { data[__i] = __val; }",
			"        uint32_t operator[](int __i) const { return data[__i]; }",
			"    };",
			"    template <uint32_t _N>",
			"    struct _EratosthenesSieveArray<_N, false> {",
			"        void set(int __i, uint32_t __val) {}",
			"        uint32_t operator[](int __i) const { return 1; }",
			"    };",
			"    template <uint32_t _N, bool _Prime = true, bool _Phi = false, bool _Small = false, bool _Big = false>",
			"    class EratosthenesSieve {",
			"        static constexpr uint32_t sqrt = [] {",
			"            uint32_t i = 1;",
			"            while (i * i + i * 2 + 1 <= _N) i++;",
			"            return i;",
			"        }();",
			"        _EratosthenesSieveArray<_N, _Small> m_smallestFactor;",
			"        _EratosthenesSieveArray<_N, _Big> m_biggestFactor;",
			"        _EratosthenesSieveArray<_N, _Phi> m_phi;",
			"        _EratosthenesSieveArray<_N >= 1000000 ? _N / 12 : 100000, _Prime> m_primeList;",
			"        std::bitset<_N + 1> m_isp;",
			"        uint32_t m_primeCnt;",
			"",
			"    public:",
			"        EratosthenesSieve() : m_primeCnt{0} {",
			"            m_isp.set();",
			"            m_isp.reset(1);",
			"            m_smallestFactor.set(1, 1);",
			"            m_biggestFactor.set(1, 1);",
			"            m_phi.set(1, 1);",
			"            m_smallestFactor.set(2, 2);",
			"            m_biggestFactor.set(2, 2);",
			"            m_phi.set(2, 1);",
			"            m_primeList.set(m_primeCnt++, 2);",
			"            for (int i = 3; i <= sqrt; i += 2)",
			"                if (m_isp[i]) {",
			"                    m_smallestFactor.set(i, i);",
			"                    m_phi.set(i, i - 1);",
			"                    m_primeList.set(m_primeCnt++, i);",
			"                    for (int j = i; j <= _N; j += i) m_biggestFactor.set(j, i);",
			"                    for (int j = i * i, k = i; j <= _N; j += i * 2, k += 2) {",
			"                        if (m_isp[j]) {",
			"                            m_isp.reset(j);",
			"                            m_smallestFactor.set(j, i);",
			"                            m_phi.set(j, i);",
			"                            m_phi.set(j + 1, k);",
			"                        }",
			"                    }",
			"                } else",
			"                    m_phi.set(i, m_phi[i + 1] % m_phi[i] ? (m_phi[i] - 1) * m_phi[m_phi[i + 1]] : m_phi[i] * m_phi[m_phi[i + 1]]);",
			"            for (int i = sqrt + sqrt % 2 + 1; i <= _N; i += 2)",
			"                if (m_isp[i]) {",
			"                    m_smallestFactor.set(i, i);",
			"                    m_phi.set(i, i - 1);",
			"                    m_primeList.set(m_primeCnt++, i);",
			"                    for (int j = i; j <= _N; j += i) m_biggestFactor.set(j, i);",
			"                } else",
			"                    m_phi.set(i, m_phi[i + 1] % m_phi[i] ? (m_phi[i] - 1) * m_phi[m_phi[i + 1]] : m_phi[i] * m_phi[m_phi[i + 1]]);",
			"        }",
			"        bool isPrime(uint32_t __i) const { return (__i & 1) || __i == 2 ? m_isp[__i] : false; }",
			"        uint32_t EulerPhi(uint32_t __i) const {",
			"            static_assert(_Phi);",
			"            return __i & 1 ? m_phi[__i] : m_phi[__i >> std::__countr_zero(__i)] << std::__countr_zero(__i) - 1;",
			"        }",
			"        uint32_t querySmallestFactor(uint32_t __i) const {",
			"            static_assert(_Small);",
			"            return __i & 1 ? m_smallestFactor[__i] : 2;",
			"        }",
			"        uint32_t queryBiggestFactor(uint32_t __i) const {",
			"            static_assert(_Big);",
			"            if (__i & 1) return m_biggestFactor[__i];",
			"            __i >>= std::__countr_zero(__i);",
			"            return __i == 1 ? 2 : m_biggestFactor[__i];",
			"        }",
			"        uint32_t queryKthPrime(int __k) const {",
			"            static_assert(_Prime);",
			"            return m_primeList[__k];",
			"        }",
			"        uint32_t count() const { return m_primeCnt; }",
			"        auto decomposite(uint32_t __n) const {",
			"            static_assert(_Small);",
			"            struct node {",
			"                uint32_t prime, count;",
			"            };",
			"            std::vector<node> res;",
			"            if (__n % 2 == 0) {",
			"                res.push_back({2, uint32_t(std::__countr_zero(__n))});",
			"                __n >>= std::__countr_zero(__n);",
			"            }",
			"            while (__n > 1) {",
			"                uint32_t cur = querySmallestFactor(__n);",
			"                uint32_t num = 0;",
			"                do {",
			"                    __n /= cur;",
			"                    num++;",
			"                } while (querySmallestFactor(__n) == cur);",
			"                res.push_back({cur, num});",
			"            }",
			"            return res;",
			"        }",
			"        std::vector<uint32_t> getFactors(uint32_t __n) const {",
			"            static_assert(_Small);",
			"            auto pf = decomposite(__n);",
			"            std::vector<uint32_t> res;",
			"            uint32_t count = 1;",
			"            for (auto [p, c] : pf) count *= c + 1;",
			"            res.reserve(count);",
			"            auto dfs = [&](auto self, int i, uint32_t prod) -> void {",
			"                if (i == pf.size())",
			"                    res.push_back(prod);",
			"                else {",
			"                    auto [p, c] = pf[i];",
			"                    self(self, i + 1, prod);",
			"                    while (c--) self(self, i + 1, prod *= p);",
			"                }",
			"            };",
			"            dfs(dfs, 0, 1);",
			"            std::sort(res.begin(), res.end());",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Eratosthenes Sieve"
	},
	"Euclidean":{
		"prefix": "EUC",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Euclidean {",
			"        struct _Euclidean_ans {",
			"            _Tp f, g, h;",
			"        };",
			"        const _Tp m_inv2, m_inv6;",
			"        Euclidean() : m_inv2(_Tp(2).inv()), m_inv6(_Tp(6).inv()) {}",
			"        _Euclidean_ans calc(uint32_t __a, uint32_t __b, uint32_t __c, uint32_t __n) const {",
			"            auto [aq, ar] = std::div(int(__a), int(__c));",
			"            auto [bq, br] = std::div(int(__b), int(__c));",
			"            const uint32_t m = (uint64_t(ar) * __n + br) / __c;",
			"            const _Tp k1(aq), k2(bq), s1(__n + 1), s2(_Tp(__n) * _Tp(__n + 1) * m_inv2), s3(_Tp(__n) * _Tp(__n + 1) * _Tp(__n * 2 + 1) * m_inv6);",
			"            _Tp F(s2 * k1 + s1 * k2), G(s3 * k1 + s2 * k2), H(s3 * k1 * k1 + s1 * k2 * k2 + s2 * k1 * k2 * _Tp(2));",
			"            if (ar && m) {",
			"                auto [f, g, h] = calc(__c, __c - br - 1, ar, m - 1);",
			"                _Tp df = _Tp(__n) * _Tp(m) - f;",
			"                F += df;",
			"                _Tp dg = s2 * _Tp(m) - (f + h) * m_inv2;",
			"                G += dg;",
			"                _Tp dh = _Tp(__n) * _Tp(m) * _Tp(m) + (k1 * dg + k2 * df - g) * _Tp(2) - f;",
			"                H += dh;",
			"            }",
			"            return {F, G, H};",
			"        }",
			"    };",
			"}",
		],
		"description": "Euclidean"
	},
	"Euler Sieve":{
		"prefix": "SIEVE",
		"body": [
			"namespace OY {",
			"    template <uint32_t _N, bool _B>",
			"    struct _EulerSieveArray {",
			"        uint32_t data[_N + 1];",
			"        void set(int __i, uint32_t __val) { data[__i] = __val; }",
			"        uint32_t operator[](int __i) const { return data[__i]; }",
			"    };",
			"    template <uint32_t _N>",
			"    struct _EulerSieveArray<_N, false> {",
			"        void set(int __i, uint32_t __val) {}",
			"        uint32_t operator[](int __i) const { return 1; }",
			"    };",
			"    template <uint32_t _N, bool _Phi = false, bool _Small = false, bool _Big = false>",
			"    class EulerSieve {",
			"        _EulerSieveArray<_N + 1, _Phi> m_phi;",
			"        _EulerSieveArray<_N + 1, _Small> m_smallestFactor;",
			"        _EulerSieveArray<_N + 1, _Big> m_biggestFactor;",
			"        std::bitset<_N + 1> m_isp;",
			"        uint32_t m_primeList[_N >= 1000000 ? _N / 12 : 100000];",
			"        uint32_t m_primeCnt;",
			"",
			"    public:",
			"        EulerSieve() : m_primeCnt{0} {",
			"            m_isp.set();",
			"            m_isp.reset(1);",
			"            m_phi.set(1, 1);",
			"            m_smallestFactor.set(1, 1);",
			"            m_biggestFactor.set(1, 1);",
			"            for (int i = 2; i <= _N; i++) {",
			"                if (m_isp[i]) {",
			"                    m_phi.set(i, i - 1);",
			"                    m_smallestFactor.set(i, i);",
			"                    m_biggestFactor.set(i, i);",
			"                    m_primeList[m_primeCnt++] = i;",
			"                }",
			"                for (uint32_t *it = m_primeList, *end = m_primeList + m_primeCnt; it < end; ++it) {",
			"                    auto p = *it, q = i * p;",
			"                    if (q > _N) break;",
			"                    m_isp.reset(q);",
			"                    m_smallestFactor.set(q, p);",
			"                    m_biggestFactor.set(q, m_biggestFactor[i]);",
			"                    if (i % p)",
			"                        m_phi.set(q, m_phi[i] * (p - 1));",
			"                    else {",
			"                        m_phi.set(q, m_phi[i] * p);",
			"                        break;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        bool isPrime(uint32_t __i) const { return (__i & 1) || __i == 2 ? m_isp[__i] : false; }",
			"        uint32_t EulerPhi(uint32_t __i) const {",
			"            static_assert(_Phi);",
			"            return __i & 1 ? m_phi[__i] : m_phi[__i >> std::__countr_zero(__i)] << std::__countr_zero(__i) - 1;",
			"        }",
			"        uint32_t querySmallestFactor(uint32_t __i) const {",
			"            static_assert(_Small);",
			"            return __i & 1 ? m_smallestFactor[__i] : 2;",
			"        }",
			"        uint32_t queryBiggestFactor(uint32_t __i) const {",
			"            static_assert(_Big);",
			"            return m_biggestFactor[__i];",
			"        }",
			"        uint32_t queryKthPrime(int __k) const { return m_primeList[__k]; }",
			"        uint32_t count() const { return m_primeCnt; }",
			"        auto decomposite(uint32_t __n) {",
			"            struct node {",
			"                uint32_t prime, count;",
			"            };",
			"            std::vector<node> res;",
			"            if (__n % 2 == 0) {",
			"                res.push_back({2, uint32_t(std::__countr_zero(__n))});",
			"                __n >>= std::__countr_zero(__n);",
			"            }",
			"            while (__n > 1) {",
			"                uint32_t cur = querySmallestFactor(__n);",
			"                uint32_t num = 0;",
			"                do {",
			"                    __n /= cur;",
			"                    num++;",
			"                } while (querySmallestFactor(__n) == cur);",
			"                res.push_back({cur, num});",
			"            }",
			"            return res;",
			"        }",
			"        std::vector<uint32_t> getFactors(uint32_t __n) {",
			"            auto pf = decomposite(__n);",
			"            std::vector<uint32_t> res;",
			"            uint32_t count = 1;",
			"            for (auto [p, c] : pf) count *= c + 1;",
			"            res.reserve(count);",
			"            auto dfs = [&](auto self, int i, uint32_t prod) -> void {",
			"                if (i == pf.size())",
			"                    res.push_back(prod);",
			"                else {",
			"                    auto [p, c] = pf[i];",
			"                    self(self, i + 1, prod);",
			"                    while (c--) self(self, i + 1, prod *= p);",
			"                }",
			"            };",
			"            dfs(dfs, 0, 1);",
			"            std::sort(res.begin(), res.end());",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Euler Sieve"
	},
	"exgcd":{
		"prefix": "EXGCD",
		"body": [
			"namespace OY {",
			"    constexpr auto exGCD(int64_t a, int64_t b) {",
			"        struct _exGCD_ans {",
			"            int64_t g, k1, k2;",
			"        };",
			"        if (!a && !b) return _exGCD_ans{0, 0, 0};",
			"        int64_t s = b, t = a, m0 = 0, m1 = 1, m2 = 1, m3 = 0;",
			"        while (t) {",
			"            int64_t u = s / t;",
			"            std::tie(s, m0, m2) = std::make_tuple(s - t * u, m0 - m1 * u, m2 - m3 * u);",
			"            std::swap(s, t);",
			"            std::swap(m0, m1);",
			"            std::swap(m2, m3);",
			"        }",
			"        if (s < 0) std::tie(s, m0, m2) = std::make_tuple(-s, -m0, -m2);",
			"        return _exGCD_ans{s, m0, m2};",
			"    }",
			"    constexpr auto exGCD(int64_t a, int64_t b, int64_t c) {",
			"        struct _exGCD_ans {",
			"            int64_t g, res, k1;",
			"        };",
			"        if (!a) return b && c % b == 0 ? _exGCD_ans{b, c, 0} : _exGCD_ans{b, 0, 0};",
			"        if (!b) return a && c % a == 0 ? _exGCD_ans{a, c, c / a} : _exGCD_ans{a, 0, 0};",
			"        int64_t s = b, t = a, m0 = 0, m1 = 1;",
			"        while (t) {",
			"            int64_t u = s / t;",
			"            std::tie(s, m0) = std::make_tuple(s - t * u, m0 - m1 * u);",
			"            std::swap(s, t);",
			"            std::swap(m0, m1);",
			"        }",
			"        if (c % s) return _exGCD_ans{std::abs(s), 0, 0};",
			"        std::tie(a, b) = std::make_tuple(a / s, b / s);",
			"        if (b < 0) std::tie(a, b) = std::make_tuple(-a, -b);",
			"        if (b <= UINT32_MAX) {",
			"            Barrett32 brt(b);",
			"            if (m0 >= 0)",
			"                m0 = brt.mod(m0);",
			"            else {",
			"                m0 = brt.mod(-m0);",
			"                if (m0) m0 = b - m0;",
			"            }",
			"            int64_t x = c / s;",
			"            if (x >= 0)",
			"                x = brt.mod(x);",
			"            else {",
			"                x = brt.mod(-x);",
			"                if (x) x = b - x;",
			"            }",
			"            m0 = brt.multiply_64(m0, x);",
			"        } else {",
			"            Barrett64 brt(b);",
			"            if (m0 >= 0)",
			"                m0 = brt.mod(m0);",
			"            else {",
			"                m0 = brt.mod(-m0);",
			"                if (m0) m0 = b - m0;",
			"            }",
			"            int64_t x = c / s;",
			"            if (x >= 0)",
			"                x = brt.mod(x);",
			"            else {",
			"                x = brt.mod(-x);",
			"                if (x) x = b - x;",
			"            }",
			"            m0 = brt.multiply_ld(m0, x);",
			"        }",
			"        return _exGCD_ans{std::abs(s), c, m0};",
			"    }",
			"}",
		],
		"description": "exgcd"
	},
	"Falling Factorial Polynomial":{
		"prefix": "FFP",
		"body": [
			"namespace OY {",
			"    template <typename _Poly>",
			"    struct FallingFactorialPolynomial {",
			"        using ffpoly = FallingFactorialPolynomial<_Poly>;",
			"        using _Tp = typename _Poly::value_type;",
			"        static inline _Tp s_factorial[sizeof(_Poly::s_dftRoots) / sizeof(*_Poly::s_dftRoots)], s_factorialInv[sizeof(_Poly::s_dftRoots) / sizeof(*_Poly::s_dftRoots)];",
			"        static inline uint32_t s_factorialSize = 0;",
			"        _Poly m_poly;",
			"        static void prepareFactorial(uint32_t __length) {",
			"            if (s_factorialSize >= __length) return;",
			"            if (!s_factorialSize) {",
			"                s_factorial[0] = s_factorialInv[0] = s_factorial[1] = s_factorialInv[1] = _Tp(1);",
			"                s_factorialSize = 2;",
			"            }",
			"            const auto P(_Tp::mod());",
			"            for (uint32_t i = s_factorialSize; i < __length; i++) {",
			"                auto q = P / i, r = P - q * i;",
			"                s_factorial[i] = s_factorial[i - 1] * _Tp(i), s_factorialInv[i] = s_factorialInv[i - 1] * s_factorialInv[r] * s_factorial[r - 1] * _Tp(P - q);",
			"            }",
			"            s_factorialSize = std::max<uint32_t>(__length, 2);",
			"        }",
			"        static _Poly ex(uint32_t __length) { return prepareFactorial(__length), _Poly(s_factorialInv, s_factorialInv + __length); }",
			"        static _Poly exInv(uint32_t __length) {",
			"            _Poly res(ex(__length));",
			"            for (uint32_t i = 1; i < res.size(); i += 2) res[i] = -res[i];",
			"            return res;",
			"        }",
			"        static ffpoly fromPoints(_Poly __ys) {",
			"            prepareFactorial(__ys.size());",
			"            const uint32_t length = __ys.size();",
			"            for (uint32_t i = 0; i < __ys.size(); i++) __ys[i] *= s_factorialInv[i];",
			"            ffpoly res;",
			"            (res.m_poly = __ys * exInv(__ys.size())).sizeTo(length);",
			"            return res;",
			"        }",
			"        static _Poly toPoints(const ffpoly &__a) { return __a.calcRange(__a.m_poly.size()); }",
			"        static ffpoly fromNormal(const _Poly &__a) {",
			"            _Poly xs(__a.size());",
			"            for (uint32_t i = 0; i < xs.size(); i++) xs[i] = _Tp(i);",
			"            return fromPoints(__a.calc(xs));",
			"        }",
			"        static _Poly toNormal(const ffpoly &__a) {",
			"            auto dfs = [&](auto self, uint32_t start, uint32_t length) -> std::pair<_Poly, _Poly> {",
			"                std::pair<_Poly, _Poly> res;",
			"                if (length == 1) {",
			"                    res.first.push_back(__a.m_poly.at(start));",
			"                    res.second.push_back(-_Tp(start));",
			"                    res.second.emplace_back(1);",
			"                } else {",
			"                    auto [lf, lg] = self(self, start, length / 2);",
			"                    auto [rf, rg] = self(self, start + length / 2, length / 2);",
			"                    (res.first = rf * lg) += lf;",
			"                    res.second = _Poly::product(lg, rg, length);",
			"                    res.second[0]--;",
			"                    res.second.emplace_back(1);",
			"                }",
			"                return res;",
			"            };",
			"            return dfs(dfs, 0, std::__bit_ceil(__a.m_poly.size())).first;",
			"        }",
			"        ffpoly &operator*=(const ffpoly &__other) {",
			"            if (m_poly.empty()) return *this;",
			"            if (__other.m_poly.empty()) {",
			"                m_poly.clear();",
			"                return *this;",
			"            }",
			"            const uint32_t length = m_poly.size() + __other.m_poly.size() - 1;",
			"            _Poly ys(calcRange(length)), ys2(__other.calcRange(length));",
			"            for (uint32_t i = 0; i < length; i++) ys[i] *= ys2[i];",
			"            *this = fromPoints(ys);",
			"            return *this;",
			"        }",
			"        friend ffpoly operator*(const ffpoly &__a, const ffpoly &__b) {",
			"            ffpoly res(__a);",
			"            res *= __b;",
			"            return res;",
			"        }",
			"        _Poly calcRange(uint32_t __range) const {",
			"            prepareFactorial(__range);",
			"            _Poly res(m_poly * ex(__range));",
			"            res.sizeTo(__range);",
			"            for (uint32_t i = 0; i < __range; i++) res[i] *= s_factorial[i];",
			"            return res;",
			"        }",
			"        _Tp calc(_Tp __x) const {",
			"            _Tp cur(1), res(0);",
			"            for (uint32_t i = 0; i < m_poly.size(); i++) res += cur * m_poly[i], cur *= __x - _Tp(i);",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Falling Factorial Polynomial"
	},
	"Fast factorial":{
		"prefix": "FACT",
		"body": [
			"namespace OY {",
			"    template <typename _Poly>",
			"    struct FastFactorial {",
			"        using _Tp = typename _Poly::value_type;",
			"        using _ModType = decltype(_Tp::mod());",
			"        const _ModType m_block;",
			"        _Poly m_presum;",
			"        FastFactorial(_Tp __limit = _Tp::mod() - 1) : m_block(1 << (std::__countr_zero(std::__bit_ceil(__limit.val())) + 1) / 2) {",
			"            _Tp blockInv(_Tp(m_block).inv());",
			"            m_presum.reserve(m_block * 2);",
			"            m_presum = {_Tp(1), _Tp(m_block + 1)};",
			"            for (uint32_t cur = 1; cur < m_block; cur *= 2) {",
			"                auto solver = LagrangeInterpolation_ex<_Poly>(cur * 2).prepare(m_presum);",
			"                std::transform(m_presum.begin(), m_presum.end(), solver.calc(blockInv * cur).begin(), m_presum.begin(), std::multiplies<_Tp>());",
			"                if (cur * 2 < m_block || __limit.val() > m_block * (cur * 2 + 50)) {",
			"                    _Poly res1(solver.calc(_Tp(cur * 2))), res2(solver.calc((blockInv + 2) * cur));",
			"                    std::copy(res1.begin(), std::transform(res1.begin(), res1.end(), res2.begin(), res1.begin(), std::multiplies<_Tp>()), m_presum.sizeTo(cur * 4).begin() + cur * 2);",
			"                }",
			"            }",
			"            std::partial_sum(m_presum.begin(), m_presum.end(), m_presum.begin(), std::multiplies<_Tp>());",
			"        }",
			"        _Tp query(_Tp __n) const {",
			"            _ModType m = std::min<_ModType>(__n.val() / m_block, m_presum.size()), r = __n.val() - m * m_block;",
			"            if (r * 2 > m_block) return __n.val() % 2 ? query(-__n - 1).inv() : -query(-__n - 1).inv();",
			"            _Tp res(1);",
			"            if (m) res = m_presum[m - 1];",
			"            for (_ModType i = m * m_block + 1, iend = __n.val(); i <= iend; i++) res *= i;",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Fast factorial"
	},
	"FFT":{
		"prefix": "FFT",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = uint32_t, uint32_t _MAXN = 1 << 22, typename _Fp = double>",
			"    struct FFTPolynomial : std::vector<_Tp> {",
			"        using poly = FFTPolynomial<_Tp, _MAXN, _Fp>;",
			"        using std::vector<_Tp>::vector, std::vector<_Tp>::begin, std::vector<_Tp>::end, std::vector<_Tp>::size, std::vector<_Tp>::back, std::vector<_Tp>::empty, std::vector<_Tp>::clear, std::vector<_Tp>::pop_back, std::vector<_Tp>::resize, std::vector<_Tp>::push_back;",
			"        static inline struct complex {",
			"            _Fp x, y;",
			"            complex() = default;",
			"            complex(_Fp _val) : x(_val), y(0) {}",
			"            complex(_Fp _x, _Fp _y) : x(_x), y(_y) {}",
			"            complex operator+(const complex &_other) const { return complex(x + _other.x, y + _other.y); }",
			"            complex operator-(const complex &_other) const { return complex(x - _other.x, y - _other.y); }",
			"            complex operator*(const complex &_other) const { return complex(x * _other.x - y * _other.y, x * _other.y + y * _other.x); }",
			"            complex operator/(const complex &_other) const { return complex(x * _other.x + y * _other.y, y * _other.x - x * _other.y); }",
			"            complex &operator+=(const complex &_other) { return *this = complex(x + _other.x, y + _other.y); }",
			"            complex &operator-=(const complex &_other) { return *this = complex(x - _other.x, y - _other.y); }",
			"            complex &operator*=(const complex &_other) { return *this = complex(x * _other.x - y * _other.y, x * _other.y + y * _other.x); }",
			"            operator _Tp() const { return x; }",
			"        } s_dftRoots[_MAXN], s_dftBuffer[_MAXN * 2];",
			"        static inline uint32_t s_dftBin[_MAXN], s_dftSize = 1;",
			"        static void prepareDFT(uint32_t __length) {",
			"            if (__length > s_dftSize) {",
			"                if (s_dftSize == 1) s_dftRoots[s_dftSize++] = complex(1);",
			"                for (; s_dftSize < __length; s_dftSize *= 2) {",
			"                    const _Fp x(3.14159265358979323846L / s_dftSize);",
			"                    const complex wn(std::cos(x), std::sin(x));",
			"                    for (uint32_t i = s_dftSize; i < s_dftSize * 2; i += 2) {",
			"                        s_dftRoots[i] = s_dftRoots[i / 2];",
			"                        s_dftRoots[i + 1] = s_dftRoots[i / 2] * wn;",
			"                    }",
			"                }",
			"            }",
			"            if (__length > 1 && !s_dftBin[__length + 1])",
			"                for (uint32_t i = 0; i < __length; i += 2) {",
			"                    s_dftBin[__length + i] = s_dftBin[__length + i / 2] / 2;",
			"                    s_dftBin[__length + i + 1] = s_dftBin[__length + i / 2] / 2 + __length / 2;",
			"                }",
			"        }",
			"        template <typename _Iterator>",
			"        static _Iterator _dft(_Iterator __iter, uint32_t __length) {",
			"            for (uint32_t i = 0; i < __length; i++)",
			"                if (uint32_t j = s_dftBin[__length + i]; i < j) std::swap(*(__iter + i), *(__iter + j));",
			"            for (uint32_t h = 2; h <= __length; h *= 2)",
			"                for (uint32_t j = 0; j < __length; j += h)",
			"                    for (uint32_t k = j; k < j + h / 2; k++) {",
			"                        complex x(*(__iter + k)), y(*(__iter + (k + h / 2)) * s_dftRoots[h / 2 + k - j]);",
			"                        *(__iter + k) += y;",
			"                        *(__iter + (k + h / 2)) = x - y;",
			"                    }",
			"            return __iter;",
			"        }",
			"        template <typename _Iterator>",
			"        static _Iterator dft(_Iterator __iter, uint32_t __length) { return prepareDFT(__length), _dft(__iter, __length); }",
			"        template <typename _Iterator, typename _Iterator2>",
			"        static _Iterator dft(_Iterator __iter, uint32_t __dftLength, _Iterator2 __source, uint32_t __sourceLength) { return dft(std::fill_n(std::copy_n(__source, __sourceLength, __iter), __dftLength - __sourceLength, _Fp(0)) - __dftLength, __dftLength); }",
			"        template <typename _Iterator>",
			"        static _Iterator idft(_Iterator __iter, uint32_t __length) {",
			"            _dft(__iter, __length);",
			"            std::reverse(__iter + 1, __iter + __length);",
			"            for (uint32_t i = 0; i < __length; i++) *(__iter + i) = complex(std::round((*(__iter + i)).x / __length), 0);",
			"            return __iter;",
			"        }",
			"        template <typename _Iterator, typename _Iterator2, typename _Operation = std::multiplies<complex>>",
			"        static _Iterator _transform(_Iterator __iter1, _Iterator2 __iter2, uint32_t __length, _Operation __op = _Operation()) { return std::transform(__iter1, __iter1 + __length, __iter2, __iter1, __op) - __length; }",
			"        static poly product(const poly &__a, const poly &__b, uint32_t __length) {",
			"            if (__a.empty() || __b.empty()) return poly();",
			"            idft(_transform(dft(s_dftBuffer, __length, __a.begin(), std::min<uint32_t>(__length, __a.size())), dft(s_dftBuffer + __length, __length, __b.begin(), std::min<uint32_t>(__length, __b.size())), __length, std::multiplies<complex>()), __length);",
			"            return poly(s_dftBuffer, s_dftBuffer + __length);",
			"        }",
			"        poly &shrink() {",
			"            while (size() && !back()) pop_back();",
			"            return *this;",
			"        }",
			"        poly &reverse() {",
			"            std::reverse(begin(), end());",
			"            return *this;",
			"        }",
			"        poly &sizeTo(uint32_t __size) {",
			"            resize(__size);",
			"            return *this;",
			"        }",
			"        _Tp at(uint32_t __i) const { return __i < size() ? (*this)[__i] : 0; }",
			"        poly &operator+=(const poly &__other) {",
			"            _transform(sizeTo(std::max<uint32_t>(size(), __other.size())).begin(), __other.begin(), __other.size(), std::plus<_Tp>());",
			"            return shrink();",
			"        }",
			"        poly &operator-=(const poly &__other) {",
			"            _transform(sizeTo(std::max<uint32_t>(size(), __other.size())).begin(), __other.begin(), __other.size(), std::minus<_Tp>());",
			"            return shrink();",
			"        }",
			"        poly &operator*=(_Tp __other) {",
			"            if (!__other)",
			"                clear();",
			"            else",
			"                for (auto &a : *this) a *= __other;",
			"            return *this;",
			"        }",
			"        poly &operator*=(const poly &__other) { return (*this = product(*this, __other, std::__bit_ceil(size() + __other.size() - 1))).shrink(); }",
			"        poly &operator/=(_Tp __other) {",
			"            for (auto &a : *this) a /= __other;",
			"            return *this;",
			"        }",
			"        poly operator+() const { return *this; }",
			"        poly operator-() const {",
			"            poly res(*this);",
			"            std::transform(res.begin(), res.end(), res.begin(), std::negate<_Tp>());",
			"            return res;",
			"        }",
			"        friend poly operator+(const poly &__a, const poly &__b) {",
			"            poly res(__a);",
			"            res += __b;",
			"            return res;",
			"        }",
			"        friend poly operator-(const poly &__a, const poly &__b) {",
			"            poly res(__a);",
			"            res -= __b;",
			"            return res;",
			"        }",
			"        friend poly operator*(const poly &__a, _Tp __b) {",
			"            poly res(__a);",
			"            res *= __b;",
			"            return res;",
			"        }",
			"        friend poly operator*(const poly &__a, const poly &__b) {",
			"            poly res(product(__a, __b, std::__bit_ceil(__a.size() + __b.size() - 1)));",
			"            res.shrink();",
			"            return res;",
			"        }",
			"        friend poly operator/(const poly &__a, _Tp __b) {",
			"            poly res(__a);",
			"            res /= __b;",
			"            return res;",
			"        }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &__is, poly &__self) {",
			"            for (auto &a : __self) __is >> a;",
			"            return __is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &__os, const poly &__self) {",
			"            for (auto &a : __self) __os << a << ' ';",
			"            return __os;",
			"        }",
			"        _Tp calc(_Tp __x) const {",
			"            _Tp res(0);",
			"            for (uint32_t i = size() - 1; ~i; i--) res = res * __x + (*this)[i];",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "FFT polynomial"
	},
	"inverse table":{
		"prefix": "INV",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    std::vector<_Tp> getInverseTable(uint32_t n) {",
			"        std::vector<_Tp> res;",
			"        res.reserve(n + 1);",
			"        res.emplace_back(0);",
			"        res.emplace_back(1);",
			"        const long long P = _Tp::mod();",
			"        for (uint32_t i = 2; i <= n; i++) {",
			"            auto [q, r] = std::div(P, (long long)i);",
			"            res.push_back(res[r] * _Tp(P - q));",
			"        }",
			"        return res;",
			"    }",
			"}",
		],
		"description": "inverse table"
	},
	"LagrangeInter polation":{
		"prefix": "LAG",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct LagrangeInterpolation {",
			"        struct _Point {",
			"            _Tp x, y;",
			"        };",
			"        std::vector<_Point> m_points;",
			"        std::vector<_Tp> m_coef;",
			"        LagrangeInterpolation(uint32_t __pointNum = 0) { m_points.reserve(__pointNum); }",
			"        void addPoint(_Tp __x, _Tp __y) { m_points.push_back({__x, __y}); }",
			"        void prepare() {",
			"            m_coef.reserve(m_points.size());",
			"            for (auto &[xi, yi] : m_points) {",
			"                _Tp denominator = 1;",
			"                for (auto &[xj, yj] : m_points)",
			"                    if (xi != xj) denominator *= xi - xj;",
			"                m_coef.push_back(yi / denominator);",
			"            }",
			"        }",
			"        void prepareIfSpecialX(){",
			"            _Tp fac[m_points.size()],facInv[m_points.size()+1];",
			"            fac[0]=1;",
			"            for(uint32_t i=1;i<m_points.size();i++)fac[i]=fac[i-1]*i;",
			"            facInv[m_points.size()]=1;",
			"            for(uint32_t i=m_points.size()-1;~i;i--)facInv[i]=facInv[i+1]*fac[i];",
			"            _Tp prod = facInv[0], inv = 1 / prod;",
			"            for (uint32_t i = 0; i < m_points.size(); i++) {",
			"                facInv[i]=inv*facInv[i+1];",
			"                inv*=fac[i];",
			"            }",
			"            m_coef.reserve(m_points.size());",
			"            for (uint32_t i = 0; i < m_points.size(); i++) {",
			"                m_coef.push_back(m_points[i].y*facInv[i]*facInv[m_points.size()-1-i]);",
			"                if((m_points.size()-i-1)%2)m_coef.back()=-m_coef.back();",
			"            }",
			"        }",
			"        _Tp calc(_Tp __x) const {",
			"            for (auto &[xi, yi] : m_points)",
			"                if (__x == xi) return yi;",
			"            _Tp dif[m_points.size() + 1];",
			"            dif[m_points.size()] = 1;",
			"            for (uint32_t i = m_points.size() - 1; ~i; i--) dif[i] = dif[i + 1] * (__x - m_points[i].x);",
			"            _Tp res = 0, prod = dif[0], inv = 1 / prod;",
			"            for (uint32_t i = 0; i < m_points.size(); i++) {",
			"                res += m_coef[i] * prod * inv * dif[i + 1];",
			"                inv *= __x - m_points[i].x;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Lagrange Interpolation"
	},
	"Lagrange Interpolation_ex":{
		"prefix": "LAG",
		"body": [
			"namespace OY {",
			"    template <typename _Poly>",
			"    struct LagrangeInterpolation_ex {",
			"        using _Tp = typename _Poly::value_type;",
			"        struct _Solver {",
			"            uint32_t length;",
			"            const _Poly ys;",
			"            _Poly base, bi, bv;",
			"            _Solver(const _Poly &_ys) : length(_ys.size()), ys(_ys), base(_ys.size()), bi(_ys.size() * 2 - 1), bv(_ys.size() * 2 - 1) {}",
			"            _Poly rawCalc(_Tp __shift) {",
			"                for (uint32_t i = 0; i < length * 2 - 1; i++) bi[i] = __shift - _Tp(length) + _Tp(1 + i);",
			"                for (uint32_t i = 0; i < length * 2 - 1; i++) bv[i] = i ? bv[i - 1] * bi[i - 1] : _Tp(1);",
			"                _Tp inv((bv.back() * bi.back()).inv());",
			"                for (uint32_t i = length * 2 - 2; ~i; i--) bv[i] *= inv, inv *= bi[i];",
			"                _Poly res(_Poly::product(base, bv, std::__bit_ceil(length * 2)));",
			"                res.sizeTo(length * 2 - 1).erase(res.begin(), res.begin() + length - 1);",
			"                _Tp v(1);",
			"                for (uint32_t i = length - 1; ~i; i--) v *= __shift - _Tp(i);",
			"                for (uint32_t i = 0; i < length; i++) res[i] *= v, v *= bv[i] * (__shift + _Tp(i + 1));",
			"                return res;",
			"            }",
			"            _Poly calc(_Tp __shift) {",
			"                if (__shift.val() < length) {",
			"                    _Poly res(rawCalc(length));",
			"                    std::rotate(res.begin(), res.begin() + __shift.val(), std::copy_n(ys.begin() + __shift.val(), length - __shift.val(), res.begin() + __shift.val()));",
			"                    return res;",
			"                } else if (__shift.val() > _Tp::mod() - length) {",
			"                    _Poly res(rawCalc(-_Tp(length)));",
			"                    std::rotate(res.begin(), std::copy_n(ys.begin(), length - (_Tp::mod() - __shift.val()), res.begin()), res.end());",
			"                    return res;",
			"                } else",
			"                    return rawCalc(__shift);",
			"            }",
			"        };",
			"        static inline _Tp s_factorial[sizeof(_Poly::s_dftRoots) / sizeof(*_Poly::s_dftRoots)], s_factorialInv[sizeof(_Poly::s_dftRoots) / sizeof(*_Poly::s_dftRoots)];",
			"        static inline uint32_t s_factorialSize = 0;",
			"        uint32_t m_length;",
			"        _Poly m_av;",
			"        LagrangeInterpolation_ex(uint32_t __length) : m_length(__length), m_av(__length) {",
			"            prepareFactorial(m_length);",
			"            for (uint32_t i = 0; i < m_length; i++) m_av[i] = s_factorialInv[i] * s_factorialInv[m_length - 1 - i];",
			"        }",
			"        static void prepareFactorial(uint32_t __length) {",
			"            if (s_factorialSize >= __length) return;",
			"            if (!s_factorialSize) {",
			"                s_factorial[0] = s_factorialInv[0] = s_factorial[1] = s_factorialInv[1] = _Tp(1);",
			"                s_factorialSize = 2;",
			"            }",
			"            const auto P(_Tp::mod());",
			"            for (uint32_t i = s_factorialSize; i < __length; i++) {",
			"                auto q = P / i, r = P - q * i;",
			"                s_factorial[i] = s_factorial[i - 1] * _Tp(i), s_factorialInv[i] = s_factorialInv[i - 1] * s_factorialInv[r] * s_factorial[r - 1] * _Tp(P - q);",
			"            }",
			"            s_factorialSize = std::max<uint32_t>(__length, 2);",
			"        }",
			"        _Solver prepare(const _Poly &__ys) {",
			"            _Solver res(__ys);",
			"            for (uint32_t i = 0; i < m_length; i++) res.base[i] = (m_length - 1 - i) % 2 ? -__ys[i] * m_av[i] : __ys[i] * m_av[i];",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Lagrange Interpolation_ex"
	},
	"limited gcd":{
		"prefix": "GCD",
		"body": [
			"namespace OY {",
			"    template <uint32_t _N>",
			"    class LimitedGCD {",
			"        static constexpr uint32_t sqrt = [] {",
			"            uint32_t i = 1;",
			"            while (i * i + i * 2 + 1 <= _N) i++;",
			"            return i;",
			"        }();",
			"        uint32_t m_decomposition[_N + 1][3];",
			"        uint32_t m_smallestFactor[_N + 1]{0};",
			"        uint32_t m_gcd[sqrt][sqrt];",
			"        uint32_t m_primeList[_N >= 1000000 ? _N / 12 : 100000];",
			"        uint32_t m_primeCnt = 0;",
			"",
			"    public:",
			"        LimitedGCD() {",
			"            m_decomposition[0][0] = m_decomposition[0][1] = 1;",
			"            m_decomposition[0][2] = 0;",
			"            m_decomposition[1][0] = m_decomposition[1][1] = m_decomposition[1][2] = 1;",
			"            for (int i = 2; i <= _N; i++) {",
			"                if (!m_smallestFactor[i]) {",
			"                    m_smallestFactor[i] = i;",
			"                    m_primeList[m_primeCnt++] = i;",
			"                    m_decomposition[i][0] = m_decomposition[i][1] = 1;",
			"                    m_decomposition[i][2] = i;",
			"                } else {",
			"                    uint32_t a = i / m_smallestFactor[i];",
			"                    std::copy(m_decomposition[a], m_decomposition[a + 1], m_decomposition[i]);",
			"                    m_decomposition[i][0] *= m_smallestFactor[i];",
			"                    std::sort(m_decomposition[i], m_decomposition[i + 1]);",
			"                }",
			"                for (uint32_t *it = m_primeList, *end = m_primeList + m_primeCnt; it < end; ++it) {",
			"                    auto p = *it, q = p * i;",
			"                    if (q > _N) break;",
			"                    if (i % p)",
			"                        m_smallestFactor[q] = p;",
			"                    else {",
			"                        m_smallestFactor[q] = m_smallestFactor[p];",
			"                        break;",
			"                    }",
			"                }",
			"            }",
			"            for (int j = 0; j < sqrt; j++) m_gcd[0][j] = j;",
			"            for (int i = 1; i < sqrt; i++) {",
			"                m_gcd[i][0] = i;",
			"                for (int j = 1; j < i; j++) m_gcd[i][j] = m_gcd[i - j][j];",
			"                m_gcd[i][i] = i;",
			"                for (int j = i + 1; j < sqrt; j++) m_gcd[i][j] = m_gcd[i][j - i];",
			"            }",
			"        }",
			"        uint32_t gcd(uint32_t __a, uint32_t __b) const {",
			"            if (__a < sqrt)",
			"                return __b < sqrt ? m_gcd[__a][__b] : m_gcd[__a][__b % __a];",
			"            else if (__b < sqrt)",
			"                return m_gcd[__b][__a % __b];",
			"            if (m_decomposition[__a][1] == 1) return __b % __a ? 1 : __a;",
			"            if (m_decomposition[__b][1] == 1) return __a % __b ? 1 : __b;",
			"            uint32_t res = 1;",
			"            auto transfer = [&](uint32_t x) {",
			"                res *= x;",
			"                __b /= x;",
			"            };",
			"            if (uint32_t f1 = m_decomposition[__a][0]; f1 > 1) {",
			"                if (int x = __b % f1; !x) {",
			"                    res *= f1;",
			"                    __b /= f1;",
			"                } else if (m_decomposition[f1][1] > 1)",
			"                    transfer(m_gcd[f1][x]);",
			"            }",
			"            uint32_t f2 = m_decomposition[__a][1];",
			"            if (int x = __b % f2; !x) {",
			"                res *= f2;",
			"                __b /= f2;",
			"            } else if (m_decomposition[f2][1] > 1)",
			"                transfer(m_gcd[f2][x]);",
			"            uint32_t f3 = m_decomposition[__a][2];",
			"            if (int x = __b % f3; !x)",
			"                res *= f3;",
			"            else if (f3 < sqrt && m_decomposition[f3][1] > 1)",
			"                transfer(m_gcd[f3][x]);",
			"            return res;",
			"        }",
			"        uint64_t lcm(uint32_t __a, uint32_t __b) const { return __a && __b ? uint64_t(__a / gcd(__a, __b)) * __b : 0; }",
			"        auto getSolver(uint32_t __a) const {",
			"            class _solver {",
			"                Barrett32 brt, brt1, brt2, brt3;",
			"                uint32_t f1, f2, f3;",
			"                const uint32_t *gcd1, *gcd2, *gcd3;",
			"                bool isPrime1, isPrime2, isPrime3;",
			"                const LimitedGCD &helper;",
			"                void transfer(uint32_t &res, uint32_t &b, uint32_t t) const {",
			"                    res *= t;",
			"                    b /= t;",
			"                }",
			"",
			"            public:",
			"                _solver(uint32_t a, const LimitedGCD &_helper) : helper(_helper) {",
			"                    f1 = _helper.m_decomposition[a][0];",
			"                    f2 = _helper.m_decomposition[a][1];",
			"                    f3 = _helper.m_decomposition[a][2];",
			"                    brt.m_P = a;",
			"                    if (f3 <= 1) return;",
			"                    brt = Barrett32(a);",
			"                    brt3 = Barrett32(f3);",
			"                    gcd3 = _helper.m_gcd[f3];",
			"                    isPrime3 = f3 >= sqrt || helper.m_decomposition[f3][1] == 1;",
			"                    if (f3 > sqrt) {",
			"                        f2 *= f1;",
			"                        f1 = 1;",
			"                    }",
			"                    if (f2 == 1) return;",
			"                    brt2 = Barrett32(f2);",
			"                    gcd2 = _helper.m_gcd[f2];",
			"                    isPrime2 = helper.m_decomposition[f2][1] == 1;",
			"                    if (f1 == 1) return;",
			"                    brt1 = Barrett32(f1);",
			"                    gcd1 = _helper.m_gcd[f1];",
			"                    isPrime1 = helper.m_decomposition[f1][1] == 1;",
			"                }",
			"                uint32_t queryGCD(uint32_t b) const {",
			"                    if (!b) return brt.mod();",
			"                    if (f3 == 0) return b;",
			"                    if (f3 == 1) return 1;",
			"                    if (f2 == 1) return brt.mod(b) ? 1 : brt.mod();",
			"                    if (helper.m_decomposition[b][1] == 1) return brt.mod() % b ? 1 : b;",
			"                    uint32_t res = 1;",
			"                    if (f1 > 1) {",
			"                        if (auto [quo, rem] = brt1.divmod(b); !rem) {",
			"                            res *= f1;",
			"                            b = quo;",
			"                        } else if (!isPrime1)",
			"                            transfer(res, b, *(gcd1 + rem));",
			"                    }",
			"                    if (auto [quo, rem] = brt2.divmod(b); !rem) {",
			"                        res *= f2;",
			"                        b = quo;",
			"                    } else if (!isPrime2)",
			"                        transfer(res, b, *(gcd2 + rem));",
			"                    if (auto [quo, rem] = brt3.divmod(b); !rem)",
			"                        res *= f3;",
			"                    else if (!isPrime3)",
			"                        transfer(res, b, *(gcd3 + rem));",
			"                    return res;",
			"                }",
			"                uint64_t queryLCM(uint32_t b) const {",
			"                    if (!b || !f3) return 0;",
			"                    if (f3 == 1) return b;",
			"                    if (f2 == 1) return brt.mod(b) ? uint64_t(f3) * b : b;",
			"                    if (helper.m_decomposition[b][1] == 1) return brt.mod() % b ? uint64_t(brt.mod()) * b : brt.mod();",
			"                    if (f1 > 1) {",
			"                        if (auto [quo, rem] = brt1.divmod(b); !rem)",
			"                            b = quo;",
			"                        else if (!isPrime1)",
			"                            b /= *(gcd1 + rem);",
			"                    }",
			"                    if (auto [quo, rem] = brt2.divmod(b); !rem)",
			"                        b = quo;",
			"                    else if (!isPrime2)",
			"                        b /= *(gcd2 + rem);",
			"                    if (auto [quo, rem] = brt3.divmod(b); !rem)",
			"                        b = quo;",
			"                    else if (!isPrime3)",
			"                        b /= *(gcd3 + rem);",
			"                    return uint64_t(brt.mod()) * b;",
			"                    ;",
			"                }",
			"            };",
			"            return _solver(__a, *this);",
			"        }",
			"    };",
			"}",
		],
		"description": "limited gcd"
	},
	"Lucas":{
		"prefix": "LUCAS",
		"body": [
			"namespace OY {",
			"    struct Lucas {",
			"        Barrett32 m_brt;",
			"        Lucas(uint32_t __P) : m_brt(__P) {",
			"            // assert(isPrime(__P));",
			"        }",
			"        uint32_t rawQuery(uint32_t __n, uint32_t __m) const {",
			"            // assert(__n<m_brt.mod() && __m<m_brt.mod());",
			"            if (!__m || __n == __m) return 1;",
			"            if (__n < __m) return 0;",
			"            if (__m > __n - __m) __m = __n - __m;",
			"            uint32_t a = 1, b = 1;",
			"            for (uint32_t i = 1, j = __n - __m + 1; i <= __m; i++, j++) {",
			"                a = m_brt.multiply_64(a, i);",
			"                b = m_brt.multiply_64(b, j);",
			"            }",
			"            return m_brt.multiply_64(m_brt.pow(a, m_brt.mod() - 2), b);",
			"        }",
			"        uint32_t query(uint64_t __n, uint64_t __m) const {",
			"            if (__n < __m) return 0;",
			"            uint32_t res = 1;",
			"            while (__m && __n != __m) {",
			"                uint64_t n = __n / m_brt.mod(), m = __m / m_brt.mod();",
			"                res = m_brt.multiply_64(res, rawQuery(__n - n * m_brt.mod(), __m - m * m_brt.mod()));",
			"                __n = n;",
			"                __m = m;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "lucas"
	},
	"Lucas table":{
		"prefix": "LUCAS",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct LucasTable {",
			"        const uint32_t m_P;",
			"        std::vector<_Tp> m_factorial, m_factorialInv;",
			"        LucasTable() : m_P(_Tp::mod()), m_factorial(_Tp::mod(), _Tp(1)), m_factorialInv(_Tp::mod()) {",
			"            for (uint32_t i = 1; i < m_factorial.size(); i++) m_factorial[i] = m_factorial[i - 1] * _Tp(i);",
			"            m_factorialInv.back() = m_factorial.back().inv();",
			"            for (uint32_t i = m_factorialInv.size() - 2; ~i; i--) m_factorialInv[i] = m_factorialInv[i + 1] * _Tp(i + 1);",
			"        }",
			"        _Tp rawQuery(uint32_t __n, uint32_t __m) const {",
			"            if (!__m || __n == __m) return 1;",
			"            if (__n < __m) return 0;",
			"            return m_factorial[__n] * m_factorialInv[__m] * m_factorialInv[__n - __m];",
			"        }",
			"        _Tp query(long long __n, long long __m) const {",
			"            if (__n < __m) return 0;",
			"            _Tp res(1);",
			"            while (__m && __n != __m) {",
			"                auto [nq, nr] = std::div(__n, (long long)m_P);",
			"                auto [mq, mr] = std::div(__m, (long long)m_P);",
			"                res *= rawQuery(nr, mr);",
			"                __n = nq, __m = mq;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Lucas table"
	},
	"modular":{
		"prefix": "MOD",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P>",
			"    struct Modular {",
			"        static constexpr _ModType mod() { return _P; }",
			"        static constexpr _ModType mod(uint64_t __a) { return __a % _P; }",
			"        static constexpr _ModType plus(_ModType __a, _ModType __b) {",
			"            if (__a += __b; __a >= _P) __a -= _P;",
			"            return __a;",
			"        }",
			"        static constexpr _ModType minus(_ModType __a, _ModType __b) {",
			"            if (__a += _P - __b; __a >= _P) __a -= _P;",
			"            return __a;",
			"        }",
			"        static constexpr _ModType multiply(uint64_t __a, uint64_t __b) {",
			"            if constexpr (std::is_same_v<_ModType, uint64_t>)",
			"                return multiply_ld(__a, __b);",
			"            else",
			"                return multiply_64(__a, __b);",
			"        }",
			"        static constexpr _ModType multiply_64(uint64_t __a, uint64_t __b) {",
			"            // assert(__a * __b < 1ull << 64);",
			"            return mod(__a * __b);",
			"        }",
			"        static constexpr _ModType multiply_128(uint64_t __a, uint64_t __b) { return __uint128_t(__a) * __b % _P; }",
			"        static constexpr _ModType multiply_ld(uint64_t __a, uint64_t __b) {",
			"            // assert(m_P < 1ull << 63 && __a < m_P && __b < m_P);",
			"            int64_t res = __a * __b - uint64_t(1.L / _P * __a * __b) * _P;",
			"            if (res < 0)",
			"                res += _P;",
			"            else if (res >= _P)",
			"                res -= _P;",
			"            return res;",
			"        }",
			"        static constexpr _ModType pow(uint64_t __a, uint64_t __n) {",
			"            if constexpr (std::is_same_v<_ModType, uint64_t>)",
			"                return pow_ld(__a, __n);",
			"            else",
			"                return pow_64(__a, __n);",
			"        }",
			"        static constexpr _ModType pow_64(uint64_t __a, uint64_t __n) {",
			"            // assert(m_P < 1ull << 32);",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_64(res, b);",
			"                b = multiply_64(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        static constexpr _ModType pow_128(uint64_t __a, uint64_t __n) {",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_128(res, b);",
			"                b = multiply_128(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        static constexpr _ModType pow_ld(uint64_t __a, uint64_t __n) {",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_ld(res, b);",
			"                b = multiply_ld(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Tp>",
			"        static constexpr _Tp divide(_Tp __a) { return __a / _P; }",
			"        template <typename _Tp>",
			"        static constexpr std::pair<_Tp, _Tp> divmod(_Tp __a) {",
			"            _Tp quo = __a / _P, rem = __a - quo * _P;",
			"            return {quo, rem};",
			"        }",
			"    };",
			"    template <uint32_t _P>",
			"    using Modular32 = Modular<uint32_t, _P>;",
			"    template <uint64_t _P>",
			"    using Modular64 = Modular<uint64_t, _P>;",
			"}",
		],
		"description": "modular"
	},
	"modular inverse":{
		"prefix": "INV",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, bool _IsPrime = false>",
			"    struct ModularInverse {",
			"        static _Tp query_Fermat(_Tp __a) {",
			"            static_assert(_IsPrime);",
			"            return __a.inv_Fermat();",
			"        }",
			"        static _Tp query_exgcd(_Tp __a) { return __a.inv_exgcd(); }",
			"        static _Tp query(_Tp __a) {",
			"            if constexpr (_IsPrime)",
			"                return query_Fermat(__a);",
			"            else",
			"                return query_exgcd(__a);",
			"        }",
			"        template <typename _Iterator>",
			"        static std::vector<_Tp> query(_Iterator __first, _Iterator __last) {",
			"            const uint32_t n = __last - __first;",
			"            std::vector<_Tp> res(__first, __last);",
			"            std::partial_sum(res.begin(), res.end(), res.begin(), std::multiplies<_Tp>());",
			"            _Tp inv(query(res.back()));",
			"            for (uint32_t i = n - 1; i; i--) {",
			"                res[i] = inv * res[i - 1];",
			"                inv *= *(__first + i);",
			"            }",
			"            res[0] = inv;",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "modular inverse"
	},
	"montgomery":{
		"prefix": "MG",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    struct _MontgomeryTag;",
			"    template <>",
			"    struct _MontgomeryTag<uint32_t> {",
			"        using long_type = uint64_t;",
			"        static constexpr uint32_t limit = (1u << 31) - 1;",
			"        static constexpr uint32_t inv_loop = 4;",
			"        static constexpr uint32_t length = 32;",
			"    };",
			"    template <>",
			"    struct _MontgomeryTag<uint64_t> {",
			"        using long_type = __uint128_t;",
			"        static constexpr uint64_t limit = (1ull << 63) - 1;",
			"        static constexpr uint32_t inv_loop = 5;",
			"        static constexpr uint32_t length = 64;",
			"    };",
			"    template <typename _ModType>",
			"    struct Montgomery {",
			"        using _FastType = _ModType;",
			"        using _LongType = typename _MontgomeryTag<_ModType>::long_type;",
			"        _ModType m_P;",
			"        _ModType m_Pinv;",
			"        _ModType m_Ninv;",
			"        Barrett<_ModType> m_brt;",
			"        constexpr Montgomery() = default;",
			"        constexpr explicit Montgomery(_ModType __P) : m_P(__P), m_Pinv(__P), m_Ninv(-_LongType(__P) % __P), m_brt(__P) {",
			"            for (int i = 0; i < _MontgomeryTag<_ModType>::inv_loop; i++) m_Pinv *= _ModType(2) - __P * m_Pinv;",
			"        }",
			"        constexpr _ModType mod() const { return m_brt.mod(); }",
			"        constexpr _ModType mod(uint64_t __a) const { return m_brt.mod(__a); }",
			"        constexpr _FastType init(uint64_t __a) const { return reduce(_LongType(mod(__a)) * m_Ninv); }",
			"        constexpr _FastType raw_init(uint64_t __a) const { return reduce(_LongType(__a) * m_Ninv); }",
			"        constexpr _FastType reduce(_LongType __a) const {",
			"            _FastType res = (__a >> _MontgomeryTag<_ModType>::length) - _ModType(_LongType(_ModType(__a) * m_Pinv) * m_P >> _MontgomeryTag<_ModType>::length);",
			"            if (res >= mod()) res += mod();",
			"            return res;",
			"        }",
			"        constexpr _ModType reduce(_FastType __a) const {",
			"            _ModType res = -_ModType(_LongType(__a * m_Pinv) * m_P >> _MontgomeryTag<_ModType>::length);",
			"            if (res >= mod()) res += mod();",
			"            return res;",
			"        }",
			"        constexpr _FastType plus(_FastType __a, _FastType __b) const {",
			"            if (__a += __b; __a >= m_P) __a -= m_P;",
			"            return __a;",
			"        }",
			"        constexpr _FastType minus(_FastType __a, _FastType __b) const {",
			"            if (__a += m_P - __b; __a >= m_P) __a -= m_P;",
			"            return __a;",
			"        }",
			"        constexpr _FastType multiply(_FastType __a, _FastType __b) const { return reduce(_LongType(__a) * __b); }",
			"        constexpr _FastType pow(_FastType __a, uint64_t __n) const {",
			"            _FastType res = reduce(_LongType(1) * m_Ninv);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply(res, __a);",
			"                __a = multiply(__a, __a);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Tp>",
			"        constexpr _Tp divide(_Tp __a) const { return m_brt.divide(__a); }",
			"        template <typename _Tp>",
			"        constexpr std::pair<_Tp, _Tp> divmod(_Tp __a) const { return m_brt.divmod(__a); }",
			"    };",
			"    using Montgomery32 = Montgomery<uint32_t>;",
			"    using Montgomery64 = Montgomery<uint64_t>;",
			"}",
		],
		"description": "montgomery"
	},
	"multi dimension map":{
		"prefix": "MDM",
		"body": [
			"namespace OY {",
			"    struct MultiDimensionMap {",
			"        uint32_t m_length;",
			"        std::vector<uint32_t> m_caps, m_units;",
			"        template <typename _Iterator>",
			"        MultiDimensionMap(_Iterator __first, _Iterator __last) : m_length(__last - __first), m_caps(__last - __first), m_units(__last - __first + 1) {",
			"            for (uint32_t i = 0; i < m_length; i++) m_caps[i] = *(__first + i);",
			"            m_units[0] = 1;",
			"            for (uint32_t i = 0; i < m_length; i++) m_units[i + 1] = m_units[i] * (m_caps[i] + 1);",
			"        }",
			"        uint32_t queryTotal() const { return m_units[m_length]; }",
			"        template <typename _Sequence = std::initializer_list<uint32_t>>",
			"        uint32_t queryMask(const _Sequence &__sizes) const {",
			"            uint32_t res(0);",
			"            auto it = std::begin(__sizes) + m_length;",
			"            for (uint32_t i = m_length - 1; ~i; i--) res = res * (m_caps[i] + 1) + *--it;",
			"            return res;",
			"        }",
			"        std::vector<uint32_t> querySizes(uint32_t __mask) const {",
			"            std::vector<uint32_t> res(m_length);",
			"            for (uint32_t i = 0; i < m_length; i++) {",
			"                auto [q, r] = std::div((long long)__mask, (long long)m_caps[i] + 1);",
			"                res[i] = r, __mask = q;",
			"            }",
			"            return res;",
			"        }",
			"        std::vector<uint32_t> querySubs(uint32_t __mask) const {",
			"            std::vector<uint32_t> cnt(m_length);",
			"            uint32_t total = 1;",
			"            for (uint32_t i = 0; i < m_length; i++) {",
			"                auto [q, r] = std::div((long long)__mask, (long long)(m_caps[i] + 1));",
			"                cnt[i] = r, __mask = q, total *= r + 1;",
			"            }",
			"            std::vector<uint32_t> res;",
			"            res.reserve(total);",
			"            auto dfs = [&](auto self, uint32_t cur, uint32_t i) -> void {",
			"                if (!~i)",
			"                    res.push_back(cur);",
			"                else",
			"                    for (uint32_t j = 0; j <= cnt[i]; j++) self(self, cur * (m_caps[i] + 1) + j, i - 1);",
			"            };",
			"            dfs(dfs, 0, m_length - 1);",
			"            return res;",
			"        }",
			"        std::vector<uint32_t> queryIncludes(uint32_t __mask) const {",
			"            std::vector<uint32_t> res(querySubs(queryTotal() - 1 - __mask));",
			"            for (auto &a : res) a += __mask;",
			"            return res;",
			"        }",
			"        uint32_t queryDimesionCapacity(uint32_t __i) const { return m_caps[__i]; }",
			"        uint32_t queryDimesionSize(uint32_t __mask, uint32_t __i) const { return __mask % m_units[__i + 1] / m_units[__i]; }",
			"    };",
			"}",
		],
		"description": "multi dimension map"
	},
	"MTT":{
		"prefix": "MTT",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, uint32_t _MAXN = 1 << 22, typename _Fp = double, uint32_t _Split = 1 << 15>",
			"    struct MTTPolynomial : std::vector<_Tp> {",
			"        using poly = MTTPolynomial<_Tp, _MAXN, _Fp, _Split>;",
			"        using std::vector<_Tp>::vector, std::vector<_Tp>::begin, std::vector<_Tp>::end, std::vector<_Tp>::rbegin, std::vector<_Tp>::rend, std::vector<_Tp>::size, std::vector<_Tp>::back, std::vector<_Tp>::empty, std::vector<_Tp>::clear, std::vector<_Tp>::pop_back, std::vector<_Tp>::resize, std::vector<_Tp>::push_back;",
			"        static inline struct complex {",
			"            _Fp x, y;",
			"            complex() = default;",
			"            complex(_Fp _val) : x(_val), y(0) {}",
			"            complex(_Tp _val) : x(_val.val() / _Split), y(_val.val() % _Split) {}",
			"            complex(_Fp _x, _Fp _y) : x(_x), y(_y) {}",
			"            complex conj() const { return complex(x, -y); }",
			"            complex operator-() const { return complex(-x, -y); }",
			"            complex operator+(const complex &_other) const { return complex(x + _other.x, y + _other.y); }",
			"            complex operator-(const complex &_other) const { return complex(x - _other.x, y - _other.y); }",
			"            complex operator*(const complex &_other) const { return complex(x * _other.x - y * _other.y, x * _other.y + y * _other.x); }",
			"            complex operator/(const complex &_other) const { return complex(x * _other.x + y * _other.y, y * _other.x - x * _other.y); }",
			"            complex &operator+=(const complex &_other) { return *this = complex(x + _other.x, y + _other.y); }",
			"            complex &operator-=(const complex &_other) { return *this = complex(x - _other.x, y - _other.y); }",
			"            complex &operator*=(const complex &_other) { return *this = complex(x * _other.x - y * _other.y, x * _other.y + y * _other.x); }",
			"            operator _Tp() const { return std::round(x) * _Tp(_Split) + std::round(y); }",
			"        } s_dftRoots[_MAXN], s_dftBuffer[_MAXN * 2], s_treeBuffer[_MAXN * 2 * (std::__countr_zero(_MAXN))];",
			"        static inline struct complex_pair {",
			"            complex p, q;",
			"            complex_pair() = default;",
			"            complex_pair(_Fp _val) : p(_val), q(_val) {}",
			"            complex_pair(const complex &_p, const complex &_q) : p(_p), q(_q) {}",
			"            complex_pair(const complex &_a, const complex &_b, const complex &_c) : p(_c * _a), q(_c / _b) {}",
			"            complex_pair operator+(const complex_pair &_other) const { return {p + _other.p, q + _other.q}; }",
			"            complex_pair operator-(const complex_pair &_other) const { return {p - _other.p, q - _other.q}; }",
			"            complex_pair operator*(const complex &_other) const { return {p * _other, q * _other}; }",
			"            complex_pair &operator+=(const complex_pair &_other) { return *this = {p + _other.p, q + _other.q}; }",
			"            complex_pair &operator-=(const complex_pair &_other) { return *this = {p - _other.p, q - _other.q}; }",
			"            complex_pair &operator*=(_Fp _other) { return *this = {p * _other, q * _other}; }",
			"            operator _Tp() const {",
			"                complex x(p + q), y(p - q);",
			"                _Tp u(_Split);",
			"                return _Tp(std::round(x.x / 2) * u + std::round((x.y + y.y) / 2)) * u + std::round(-y.x / 2);",
			"            }",
			"            operator complex() const { return _Tp(*this); }",
			"        } s_dftResultBuffer[_MAXN];",
			"        static inline _Tp s_inverse[_MAXN + 1];",
			"        static inline uint32_t s_dftBin[_MAXN * 2], s_dftSize = 1, s_inverseSize = 0;",
			"        static inline poly s_treeSum;",
			"        static void prepareDFT(uint32_t __length) {",
			"            if (__length > s_dftSize) {",
			"                if (s_dftSize == 1) s_dftRoots[s_dftSize++] = complex(1);",
			"                for (; s_dftSize < __length; s_dftSize *= 2) {",
			"                    const _Fp x(3.14159265358979323846L / s_dftSize);",
			"                    const complex wn(std::cos(x), std::sin(x));",
			"                    for (uint32_t i = s_dftSize; i < s_dftSize * 2; i += 2) {",
			"                        s_dftRoots[i] = s_dftRoots[i / 2];",
			"                        s_dftRoots[i + 1] = s_dftRoots[i / 2] * wn;",
			"                    }",
			"                }",
			"            }",
			"            if (__length > 1 && !s_dftBin[__length + 1])",
			"                for (uint32_t i = 0; i < __length; i += 2) {",
			"                    s_dftBin[__length + i] = s_dftBin[__length + i / 2] / 2;",
			"                    s_dftBin[__length + i + 1] = s_dftBin[__length + i / 2] / 2 + __length / 2;",
			"                }",
			"        }",
			"        template <typename _Iterator>",
			"        static _Iterator _dft(_Iterator __iter, uint32_t __length) {",
			"            for (uint32_t i = 0; i < __length; i++)",
			"                if (uint32_t j = s_dftBin[__length + i]; i < j) std::swap(*(__iter + i), *(__iter + j));",
			"            for (uint32_t h = 2; h <= __length; h *= 2)",
			"                for (uint32_t j = 0; j < __length; j += h)",
			"                    for (uint32_t k = j; k < j + h / 2; k++) {",
			"                        auto x(*(__iter + k)), y(*(__iter + (k + h / 2)) * s_dftRoots[h / 2 + k - j]);",
			"                        *(__iter + k) += y;",
			"                        *(__iter + (k + h / 2)) = x - y;",
			"                    }",
			"            return __iter;",
			"        }",
			"        template <typename _Iterator>",
			"        static _Iterator dft(_Iterator __iter, uint32_t __length) { return prepareDFT(__length), _dft(__iter, __length); }",
			"        template <typename _Iterator, typename _Iterator2>",
			"        static _Iterator dft(_Iterator __iter, uint32_t __dftLength, _Iterator2 __source, uint32_t __sourceLength) { return dft(std::fill_n(std::copy_n(__source, __sourceLength, __iter), __dftLength - __sourceLength, 0) - __dftLength, __dftLength); }",
			"        template <typename _Iterator>",
			"        static _Iterator idft(_Iterator __iter, uint32_t __length) {",
			"            _dft(__iter, __length);",
			"            std::reverse(__iter + 1, __iter + __length);",
			"            const _Fp inv(1 / _Fp(__length));",
			"            for (uint32_t i = 0; i < __length; i++) *(__iter + i) *= inv;",
			"            return __iter;",
			"        }",
			"        template <typename _Iterator, typename _Iterator2, typename _Iterator3>",
			"        static _Iterator _transform(_Iterator __iter1, _Iterator2 __iter2, _Iterator3 __iter3, uint32_t __length) {",
			"            for (uint32_t i = 0, j = 0; i < __length; i++, j = j ? j - 1 : __length - 1) {",
			"                (*(__iter1 + i)).p = *(__iter3 + i) * *(__iter2 + i);",
			"                (*(__iter1 + i)).q = *(__iter3 + i) / *(__iter2 + (i ? __length - i : 0));",
			"            }",
			"            return __iter1;",
			"        }",
			"        static void prepareInverse(uint32_t __length) {",
			"            if (s_inverseSize >= __length) return;",
			"            if (!s_inverseSize) s_inverse[0] = s_inverse[++s_inverseSize] = _Tp(1);",
			"            const long long P(_Tp::mod());",
			"            for (uint32_t i = s_inverseSize + 1; i <= __length; i++) {",
			"                auto [q, r] = std::div(P, (long long)i);",
			"                s_inverse[i] = s_inverse[r] * _Tp(P - q);",
			"            }",
			"            s_inverseSize = __length;",
			"        }",
			"        template <typename _Iterator>",
			"        static void derivate(_Iterator __iter, uint32_t __length) {",
			"            for (uint32_t i = 0; i + 1 < __length; i++) __iter[i] = __iter[i + 1] * (i + 1);",
			"            __iter[__length - 1] = 0;",
			"        }",
			"        template <typename _Iterator>",
			"        static void integrate(_Iterator __iter, uint32_t __length) {",
			"            if (!__length) return;",
			"            prepareInverse(__length);",
			"            for (uint32_t i = __length; i; i--) *(__iter + i) = *(__iter + (i - 1)) * s_inverse[i];",
			"            __iter[0] = 0;",
			"        }",
			"        static poly product(const poly &__a, const poly &__b, uint32_t __length) {",
			"            if (__a.empty() || __b.empty()) return poly();",
			"            idft(_transform(s_dftResultBuffer, dft(s_dftBuffer, __length, __a.begin(), std::min<uint32_t>(__length, __a.size())), dft(s_dftBuffer + __length, __length, __b.begin(), std::min<uint32_t>(__length, __b.size())), __length), __length);",
			"            return poly(s_dftResultBuffer, s_dftResultBuffer + __length);",
			"        }",
			"        poly &shrink() {",
			"            while (size() && !back()) pop_back();",
			"            return *this;",
			"        }",
			"        poly &reverse() {",
			"            std::reverse(begin(), end());",
			"            return *this;",
			"        }",
			"        poly &sizeTo(uint32_t __size) {",
			"            resize(__size);",
			"            return *this;",
			"        }",
			"        poly &derivate() {",
			"            derivate(begin(), size());",
			"            shrink();",
			"            return *this;",
			"        }",
			"        poly &integrate() {",
			"            push_back(0);",
			"            integrate(begin(), size() - 1);",
			"            shrink();",
			"            return *this;",
			"        }",
			"        _Tp at(uint32_t __i) const { return __i < size() ? (*this)[__i] : 0; }",
			"        poly &operator+=(const poly &__other) {",
			"            if (size() < __other.size()) resize(__other.size());",
			"            std::transform(begin(), begin() + __other.size(), __other.begin(), begin(), std::plus<_Tp>());",
			"            return shrink();",
			"        }",
			"        poly &operator-=(const poly &__other) {",
			"            if (size() < __other.size()) resize(__other.size());",
			"            std::transform(begin(), begin() + __other.size(), __other.begin(), begin(), std::minus<_Tp>());",
			"            return shrink();",
			"        }",
			"        poly &operator*=(_Tp __other) {",
			"            if (!__other)",
			"                clear();",
			"            else",
			"                for (auto &a : *this) a *= __other;",
			"            return *this;",
			"        }",
			"        poly &operator*=(const poly &__other) { return (*this = product(*this, __other, std::__bit_ceil(size() + __other.size() - 1))).shrink(); }",
			"        poly &operator/=(_Tp __other) {",
			"            for (auto &a : *this) a /= __other;",
			"            return *this;",
			"        }",
			"        poly operator+() const { return *this; }",
			"        poly operator-() const {",
			"            poly res(*this);",
			"            std::transform(res.begin(), res.end(), res.begin(), std::negate<_Tp>());",
			"            return res;",
			"        }",
			"        friend poly operator+(const poly &__a, const poly &__b) {",
			"            poly res(__a);",
			"            res += __b;",
			"            return res;",
			"        }",
			"        friend poly operator-(const poly &__a, const poly &__b) {",
			"            poly res(__a);",
			"            res -= __b;",
			"            return res;",
			"        }",
			"        friend poly operator*(const poly &__a, _Tp __b) {",
			"            poly res(__a);",
			"            res *= __b;",
			"            return res;",
			"        }",
			"        friend poly operator*(const poly &__a, const poly &__b) {",
			"            poly res(product(__a, __b, std::__bit_ceil(__a.size() + __b.size() - 1)));",
			"            res.shrink();",
			"            return res;",
			"        }",
			"        friend poly operator/(const poly &__a, _Tp __b) {",
			"            poly res(__a);",
			"            res /= __b;",
			"            return res;",
			"        }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &__is, poly &__self) {",
			"            for (auto &a : __self) __is >> a;",
			"            return __is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &__os, const poly &__self) {",
			"            for (auto &a : __self) __os << a << ' ';",
			"            return __os;",
			"        }",
			"        _Tp calc(_Tp __x) const {",
			"            _Tp res = 0;",
			"            for (uint32_t i = size() - 1; ~i; i--) res = res * __x + (*this)[i];",
			"            return res;",
			"        }",
			"        poly ChirpZ(_Tp __x, uint32_t __n) const {",
			"            if (empty()) return poly(__n, 0);",
			"            const uint32_t length = std::__bit_ceil(size() + __n - 1);",
			"            const _Tp inv(__x.inv());",
			"            _Tp cur(1), pow(1);",
			"            for (uint32_t i = 0; i < size() + __n - 1; i++, cur *= pow, pow *= __x) s_dftBuffer[i] = cur;",
			"            cur = _Tp(1), pow = _Tp(1);",
			"            for (uint32_t i = size() - 1; ~i; i--, cur *= pow, pow *= inv) s_dftBuffer[length + i] = (*this)[size() - 1 - i] * cur;",
			"            idft(_transform(s_dftResultBuffer, dft(std::fill_n(s_dftBuffer + size() + __n - 1, length - size() - __n + 1, _Fp(0)) - length, length), dft(std::fill_n(s_dftBuffer + length + size(), length - size(), _Fp(0)) - length, length), length), length);",
			"            poly res(s_dftResultBuffer + size() - 1, s_dftResultBuffer + size() - 1 + __n);",
			"            cur = _Tp(1).inv(), pow = 1;",
			"            for (auto &a : res) a *= cur, cur *= pow, pow *= inv;",
			"            return res;",
			"        }",
			"        poly inv() const {",
			"            static constexpr uint32_t R = 16;",
			"            const uint32_t Block = std::__bit_ceil((size() - 1) / R + 1);",
			"            _Tp res[Block * R];",
			"            complex f[Block * R * 2], g[Block * R * 2], h[Block * 2];",
			"            res[0] = (*this)[0].inv();",
			"            auto dfs = [&](auto self, uint32_t n) -> void {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(f, block * 2, begin(), block);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(f + block * k * 2, block * 2, begin() + block * k, block * k < size() ? std::min<uint32_t>(size() - block * k, block) : 0);",
			"                    dft(g + block * (k - 1) * 2, block * 2, res + block * (k - 1), block);",
			"                    std::fill_n(s_dftResultBuffer, block * 2, 0);",
			"                    for (uint32_t j = 0; j < k; j++) {",
			"                        complex *it1 = g + block * j * 2, *it2 = f + block * (k - j) * 2, *it3 = f + block * (k - j - 1) * 2;",
			"                        for (uint32_t i = 0; i < block * 2; i += 2) s_dftResultBuffer[i] -= {*(it1 + i), *(it1 + (i ? block * 2 - i : 0)), *(it2 + i) + *(it3 + i)}, s_dftResultBuffer[i + 1] -= {*(it1 + (i + 1)), *(it1 + (block * 2 - i - 1)), *(it2 + (i + 1)) - *(it3 + (i + 1))};",
			"                    }",
			"                    std::copy_n(idft(_transform(s_dftResultBuffer, dft(h, block * 2, idft(s_dftResultBuffer, block * 2), block), g, block * 2), block * 2), block, res + block * k);",
			"                }",
			"            };",
			"            dfs(dfs, size());",
			"            return poly(res, res + size());",
			"        }",
			"        poly sqrt(_Tp __a0 = 1) const {",
			"            if (empty()) return poly();",
			"            static constexpr uint32_t R = 16;",
			"            const _Tp inv(_Tp(2).inv());",
			"            const uint32_t Block = std::__bit_ceil((size() - 1) / R + 1);",
			"            _Tp res[Block * R];",
			"            complex f[Block * 2], g[Block * R * 2], h[Block * 2];",
			"            res[0] = __a0;",
			"            auto dfs = [&](auto self, uint32_t n) {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(f, block * 2, poly(res, res + block).inv().begin(), block);",
			"                std::fill_n(g, block * R * 2, 0);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(g + block * (k - 1) * 2, block * 2, res + block * (k - 1), block);",
			"                    std::fill_n(s_dftResultBuffer, block * 2, 0);",
			"                    for (uint32_t j = 0; j < k; j++) {",
			"                        complex *it1 = g + block * j * 2, *it2 = g + block * (k - j) * 2, *it3 = g + block * (k - j - 1) * 2;",
			"                        for (uint32_t i = 0; i < block * 2; i += 2) s_dftResultBuffer[i] += {*(it1 + i), *(it1 + (i ? block * 2 - i : 0)), *(it2 + i) + *(it3 + i)}, s_dftResultBuffer[i + 1] += {*(it1 + (i + 1)), *(it1 + (block * 2 - i - 1)), *(it2 + (i + 1)) - *(it3 + (i + 1))};",
			"                    }",
			"                    idft(s_dftResultBuffer, block * 2);",
			"                    for (uint32_t i = 0; i < block; i++) h[i] = at(block * k + i) - _Tp(s_dftResultBuffer[i]);",
			"                    idft(_transform(s_dftResultBuffer, dft(std::fill_n(h + block, block, _Fp(0)) - block * 2, block * 2), f, block * 2), block * 2);",
			"                    for (uint32_t i = 0; i < block; i++) res[block * k + i] = _Tp(s_dftResultBuffer[i]) * inv;",
			"                }",
			"            };",
			"            dfs(dfs, size());",
			"            return poly(res, res + size());",
			"        }",
			"        std::pair<poly, poly> divmod(const poly &__other) const {",
			"            if (size() < __other.size()) return {poly(), *this};",
			"            std::pair<poly, poly> res;",
			"            res.first = div(__other, size() - __other.size() + 1);",
			"            res.second = *this - res.first * __other;",
			"            return res;",
			"        }",
			"        poly div(const poly &__other, uint32_t __length = -1) const {",
			"            __length = std::min<uint32_t>(__length, size());",
			"            static constexpr uint32_t R = 16;",
			"            const uint32_t Block = std::__bit_ceil((__length - 1) / R + 1);",
			"            _Tp res[Block * R], a[Block * R], b[Block * R];",
			"            complex f[Block * R * 2], g[Block * R * 2], h[Block * 2], bi[Block * 2];",
			"            poly binv(poly(__other).reverse().sizeTo(Block).inv());",
			"            std::fill(std::copy_n(rbegin(), __length, a), a + Block * R, 0);",
			"            std::fill(std::copy_n(__other.rbegin(), std::min<uint32_t>(__length, __other.size()), b), b + Block * R, 0);",
			"            res[0] = a[0] * b[0].inv();",
			"            auto dfs = [&](auto self, uint32_t n) -> void {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(bi, block * 2, binv.begin(), block);",
			"                dft(f, block * 2, b, block);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(f + block * k * 2, block * 2, b + block * k, block);",
			"                    dft(g + block * (k - 1) * 2, block * 2, res + block * (k - 1), block);",
			"                    std::fill_n(s_dftResultBuffer, block * 2, 0);",
			"                    for (uint32_t j = 0; j < k; j++) {",
			"                        complex *it1 = g + block * j * 2, *it2 = f + block * (k - j) * 2, *it3 = f + block * (k - j - 1) * 2;",
			"                        for (uint32_t i = 0; i < block * 2; i += 2) s_dftResultBuffer[i] += {*(it1 + i), *(it1 + (i ? block * 2 - i : 0)), *(it2 + i) + *(it3 + i)}, s_dftResultBuffer[i + 1] += {*(it1 + (i + 1)), *(it1 + (block * 2 - i - 1)), *(it2 + (i + 1)) - *(it3 + (i + 1))};",
			"                    }",
			"                    idft(s_dftResultBuffer, block * 2);",
			"                    for (uint32_t i = 0; i < block; i++) h[i] = _Tp(a[block * k + i]) - _Tp(s_dftResultBuffer[i]);",
			"                    std::copy_n(idft(_transform(s_dftResultBuffer, dft(std::fill_n(h + block, block, 0) - block * 2, block * 2), bi, block * 2), block * 2), block, res + block * k);",
			"                }",
			"            };",
			"            dfs(dfs, __length);",
			"            return poly(res, res + __length).reverse();",
			"        }",
			"        poly mod(const poly &__other) const { return divmod(__other).second; }",
			"        poly logarithm() const {",
			"            prepareInverse(size());",
			"            poly f(*this);",
			"            for (uint32_t i = 0; i < size(); i++) f[i] *= i;",
			"            (f = f.reverse().div(poly(*this).reverse())).reverse();",
			"            for (uint32_t i = 1; i < size(); i++) f[i] *= s_inverse[i];",
			"            return f;",
			"        }",
			"        poly exponent() const {",
			"            if (empty()) return poly{_Tp(1)};",
			"            static constexpr uint32_t R = 16;",
			"            const uint32_t Block = std::__bit_ceil((size() - 1) / R + 1);",
			"            _Tp res[Block * R], a[Block * R];",
			"            complex f[Block * R * 2], g[Block * R * 2], h[Block * 2], bi[Block * 2];",
			"            std::fill(std::copy_n(begin(), size(), a), a + Block * R, 0);",
			"            for (uint32_t i = 0; i < size(); i++) a[i] *= i;",
			"            res[0] = 1;",
			"            prepareInverse(Block * (R + 1));",
			"            auto dfs = [&](auto self, uint32_t n) -> void {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(bi, block * 2, poly(res, res + block).inv().begin(), block);",
			"                dft(f, block * 2, a, block);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(f + block * k * 2, block * 2, a + block * k, block);",
			"                    dft(g + block * (k - 1) * 2, block * 2, res + block * (k - 1), block);",
			"                    std::fill_n(s_dftResultBuffer, block * 2, 0);",
			"                    for (uint32_t j = 0; j < k; j++) {",
			"                        complex *it1 = g + block * j * 2, *it2 = f + block * (k - j) * 2, *it3 = f + block * (k - j - 1) * 2;",
			"                        for (uint32_t i = 0; i < block * 2; i += 2) s_dftResultBuffer[i] += {*(it1 + i), *(it1 + (i ? block * 2 - i : 0)), *(it2 + i) + *(it3 + i)}, s_dftResultBuffer[i + 1] += {*(it1 + (i + 1)), *(it1 + (block * 2 - i - 1)), *(it2 + (i + 1)) - *(it3 + (i + 1))};",
			"                    }",
			"                    idft(_transform(s_dftResultBuffer, dft(h, block * 2, idft(s_dftResultBuffer, block * 2), block), bi, block * 2), block * 2);",
			"                    for (uint32_t i = 0; i < block; i++) h[i] = _Tp(s_dftResultBuffer[i]) * s_inverse[block * k + i];",
			"                    std::copy_n(idft(_transform(s_dftResultBuffer, dft(std::fill_n(h + block, block, _Fp(0)) - block * 2, block * 2), g, block * 2), block * 2), block, res + block * k);",
			"                }",
			"            };",
			"            dfs(dfs, size());",
			"            return poly(res, res + size());",
			"        }",
			"        static poly _simplePow(const poly &__a, _Tp __n) { return (__a.logarithm() * __n).exponent(); }",
			"        template <typename _Tp2>",
			"        poly pow(_Tp __n1, _Tp2 __n2, uint64_t __nAbs = UINT_MAX) const {",
			"            const uint64_t zero = std::find_if(begin(), end(), [](const _Tp &x) { return x.val() != 0; }) - begin();",
			"            if (zero && __nAbs >= (size() + zero - 1) / zero) return poly();",
			"            if (!__n1) return poly{(*this)[zero].pow(__n2.val())};",
			"            uint32_t rest = size() - zero * __nAbs;",
			"            poly a(begin() + zero, begin() + zero + std::min<uint32_t>(rest, size() - zero)), res(size(), _Tp(0));",
			"            const _Tp a0(a[0]);",
			"            (a = _simplePow(a *= a0.inv(), __n1)) *= a0.pow(__n2.val());",
			"            std::copy_n(a.begin(), a.size(), res.begin() + (size() - rest));",
			"            return res;",
			"        }",
			"        static void _initTree(const poly &__xs, uint32_t __length) {",
			"            complex *it = s_treeBuffer + __length * 2 * std::__countr_zero(__length / 2);",
			"            for (uint32_t i = 0; i < __length; i++) {",
			"                *it++ = _Tp(1), *it++ = -__xs.at(i);",
			"                dft(it - 2, 2);",
			"            }",
			"            for (uint32_t h = 2; h < __length; h *= 2) {",
			"                complex *it = s_treeBuffer + __length * 2 * std::__countr_zero(__length / 2 / h);",
			"                for (uint32_t i = 0; i < __length; i += h, it += h * 2) {",
			"                    std::fill_n(std::copy_n(idft(_transform(s_dftResultBuffer, it + __length * 2, it + __length * 2 + h, h), h), h, it), h, _Fp(0));",
			"                    *(it + h) = _Tp(*it) - 1, *it = _Tp(1);",
			"                    dft(it, h * 2);",
			"                }",
			"            }",
			"            std::copy_n(idft(_transform(s_dftResultBuffer, s_treeBuffer, s_treeBuffer + __length, __length), __length), __length, s_treeSum.sizeTo(0).sizeTo(__length * 2).begin());",
			"            s_treeSum[__length] = _Tp(s_treeSum[0]) - _Tp(1);",
			"            s_treeSum[0] = _Tp(1);",
			"        }",
			"        static poly _calcTree(const poly &__f, uint32_t __resLength) {",
			"            const uint32_t length = s_treeSum.size() / 2;",
			"            _Tp res[length];",
			"            std::copy_n(__f.div(s_treeSum.reverse()).reverse().begin(), __f.size(), std::fill_n(res, length - __f.size(), 0));",
			"            for (uint32_t h = length / 2; h; h >>= 1) {",
			"                complex *it2 = s_treeBuffer + length * 2 * std::__countr_zero(length / 2 / h);",
			"                for (_Tp *it = res, *end = res + __resLength; it < end; it += h * 2, it2 += h * 4) std::copy_n(s_dftResultBuffer + h, h, std::copy_n(idft(_transform(idft(_transform(s_dftResultBuffer, s_dftBuffer, dft(std::copy_n(it2 + h * 2, h * 2, std::copy_n(it2, h * 2, s_dftBuffer)), h * 2, it, h * 2), h * 2), h * 2) + h * 2, s_dftBuffer + h * 2, s_dftBuffer + h * 4, h * 2), h * 2) + h, h, it));",
			"            }",
			"            return poly(res, res + __resLength);",
			"        }",
			"        static poly fromPoints(const poly &__xs, const poly &__ys) {",
			"            if (__xs.size() <= 1) return __ys;",
			"            const uint32_t length = std::__bit_ceil(__xs.size());",
			"            _initTree(__xs, length);",
			"            _Tp res[length];",
			"            std::fill(std::copy_n(_calcTree(poly(s_treeSum).sizeTo(__xs.size() + 1).reverse().derivate(), __xs.size()).begin(), __xs.size(), res), res + length, 0);",
			"            for (uint32_t i = 0; i < __ys.size(); i++) res[i] = __ys[i] / res[i];",
			"            for (uint32_t h = 1; h < length; h *= 2) {",
			"                _Tp *it = res, *end = res + __xs.size();",
			"                complex *it2 = s_treeBuffer + length * 2 * std::__countr_zero(length / 2 / h);",
			"                for (; it < end; it += h * 2, it2 += h * 4) {",
			"                    dft(dft(s_dftBuffer, h * 2, it, h) + h * 2, h * 2, it + h, h);",
			"                    for (uint32_t i = 0; i < h * 2; i += 2) {",
			"                        s_dftResultBuffer[i] = {s_dftBuffer[i], s_dftBuffer[i ? h * 2 - i : 0], *(it2 + (h * 2 + i))};",
			"                        s_dftResultBuffer[i] += {s_dftBuffer[h * 2 + i], s_dftBuffer[i ? h * 4 - i : h * 2], *(it2 + i)};",
			"                        s_dftResultBuffer[i + 1] = {s_dftBuffer[i + 1], s_dftBuffer[h * 2 - i - 1], *(it2 + (h * 2 + i + 1))};",
			"                        s_dftResultBuffer[i + 1] += {s_dftBuffer[h * 2 + i + 1], s_dftBuffer[h * 4 - i - 1], *(it2 + (i + 1))};",
			"                    }",
			"                    std::copy_n(idft(s_dftResultBuffer, h * 2), h * 2, it);",
			"                }",
			"            }",
			"            poly _res(res, res + __xs.size());",
			"            _res.reverse();",
			"            return _res;",
			"        }",
			"        poly calc(const poly &__xs) const {",
			"            _initTree(__xs, std::__bit_ceil(std::max<uint32_t>(__xs.size(), size())));",
			"            return _calcTree(*this, __xs.size());",
			"        }",
			"    };",
			"}",
		],
		"description": "MTT polynomial"
	},
	"NTT":{
		"prefix": "NTT",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, uint32_t _MAXN = 1 << 22>",
			"    struct NTTPolynomial : std::vector<_Tp> {",
			"        using poly = NTTPolynomial<_Tp, _MAXN>;",
			"        using std::vector<_Tp>::vector, std::vector<_Tp>::begin, std::vector<_Tp>::end, std::vector<_Tp>::rbegin, std::vector<_Tp>::rend, std::vector<_Tp>::size, std::vector<_Tp>::back, std::vector<_Tp>::empty, std::vector<_Tp>::clear, std::vector<_Tp>::pop_back, std::vector<_Tp>::resize, std::vector<_Tp>::push_back;",
			"        static inline _Tp s_dftRoots[_MAXN], s_dftBuffer[_MAXN * 2], s_inverse[_MAXN + 1], s_treeBuffer[_MAXN * 2 * (std::__countr_zero(_MAXN))], s_primitiveRoot;",
			"        static inline uint32_t s_dftBin[_MAXN * 2], s_dftSize = 1, s_inverseSize = 0;",
			"        static inline poly s_treeSum;",
			"        static void prepareDFT(uint32_t __length) {",
			"            if (__length > s_dftSize) {",
			"                if (s_dftSize == 1) s_dftRoots[s_dftSize++] = _Tp(1);",
			"                for (; s_dftSize < __length; s_dftSize *= 2) {",
			"                    const _Tp wn(s_primitiveRoot.pow((_Tp::mod() - 1) / (s_dftSize * 2)));",
			"                    for (uint32_t i = s_dftSize; i < s_dftSize * 2; i += 2) {",
			"                        s_dftRoots[i] = s_dftRoots[i / 2];",
			"                        s_dftRoots[i + 1] = s_dftRoots[i / 2] * wn;",
			"                    }",
			"                }",
			"            }",
			"            if (__length > 1 && !s_dftBin[__length + 1])",
			"                for (uint32_t i = 0; i < __length; i += 2) {",
			"                    s_dftBin[__length + i] = s_dftBin[__length + i / 2] / 2;",
			"                    s_dftBin[__length + i + 1] = s_dftBin[__length + i / 2] / 2 + __length / 2;",
			"                }",
			"        }",
			"        template <typename _Iterator>",
			"        static _Iterator _dft(_Iterator __iter, uint32_t __length) {",
			"            for (uint32_t i = 0; i < __length; i++)",
			"                if (uint32_t j = s_dftBin[__length + i]; i < j) std::swap(*(__iter + i), *(__iter + j));",
			"            for (uint32_t h = 2; h <= __length; h *= 2)",
			"                for (uint32_t j = 0; j < __length; j += h)",
			"                    for (uint32_t k = j; k < j + h / 2; k++) {",
			"                        _Tp x(*(__iter + k)), y(*(__iter + (k + h / 2)) * s_dftRoots[h / 2 + k - j]);",
			"                        *(__iter + k) += y;",
			"                        *(__iter + (k + h / 2)) = x - y;",
			"                    }",
			"            return __iter;",
			"        }",
			"        template <typename _Iterator>",
			"        static _Iterator _setHighZero(_Iterator __iter, uint32_t __length) { return std::fill_n(__iter + __length / 2, __length / 2, 0) - __length; }",
			"        template <typename _Iterator>",
			"        static _Iterator dft(_Iterator __iter, uint32_t __length) { return prepareDFT(__length), _dft(__iter, __length); }",
			"        template <typename _Iterator, typename _Iterator2>",
			"        static _Iterator dft(_Iterator __iter, uint32_t __dftLength, _Iterator2 __source, uint32_t __sourceLength) { return dft(std::fill_n(std::copy_n(__source, __sourceLength, __iter), __dftLength - __sourceLength, 0) - __dftLength, __dftLength); }",
			"        template <typename _Iterator>",
			"        static _Iterator idft(_Iterator __iter, uint32_t __length) {",
			"            _dft(__iter, __length);",
			"            std::reverse(__iter + 1, __iter + __length);",
			"            const _Tp inv(_Tp(__length).inv());",
			"            for (uint32_t i = 0; i < __length; i++) *(__iter + i) *= inv;",
			"            return __iter;",
			"        }",
			"        template <typename _Iterator, typename _Iterator2, typename _Operation>",
			"        static _Iterator _transform(_Iterator __iter1, _Iterator2 __iter2, uint32_t __length, _Operation __op = _Operation()) { return std::transform(__iter1, __iter1 + __length, __iter2, __iter1, __op) - __length; }",
			"        static void prepareInverse(uint32_t __length) {",
			"            if (s_inverseSize >= __length) return;",
			"            if (!s_inverseSize) s_inverse[0] = s_inverse[++s_inverseSize] = _Tp(1);",
			"            const long long P(_Tp::mod());",
			"            for (uint32_t i = s_inverseSize + 1; i <= __length; i++) {",
			"                auto [q, r] = std::div(P, (long long)i);",
			"                s_inverse[i] = s_inverse[r] * _Tp(P - q);",
			"            }",
			"            s_inverseSize = __length;",
			"        }",
			"        template <typename _Iterator>",
			"        static void derivate(_Iterator __iter, uint32_t __length) {",
			"            if (!__length) return;",
			"            for (uint32_t i = 0; i + 1 < __length; i++) *(__iter + i) = *(__iter + (i + 1)) * (i + 1);",
			"            *(__iter + (__length - 1)) = _Tp(0);",
			"        }",
			"        template <typename _Iterator>",
			"        static void integrate(_Iterator __iter, uint32_t __length) {",
			"            if (!__length) return;",
			"            prepareInverse(__length);",
			"            for (uint32_t i = __length; i; i--) *(__iter + i) = *(__iter + (i - 1)) * s_inverse[i];",
			"            __iter[0] = 0;",
			"        }",
			"        static poly product(const poly &__a, const poly &__b, uint32_t __length) {",
			"            if (__a.empty() || __b.empty()) return poly();",
			"            idft(_transform(dft(s_dftBuffer, __length, __a.begin(), std::min<uint32_t>(__length, __a.size())), dft(s_dftBuffer + __length, __length, __b.begin(), std::min<uint32_t>(__length, __b.size())), __length, std::multiplies<_Tp>()), __length);",
			"            return poly(s_dftBuffer, s_dftBuffer + __length);",
			"        }",
			"        poly &shrink() {",
			"            while (size() && !back()) pop_back();",
			"            return *this;",
			"        }",
			"        poly &reverse() {",
			"            std::reverse(begin(), end());",
			"            return *this;",
			"        }",
			"        poly &sizeTo(uint32_t __size) {",
			"            resize(__size);",
			"            return *this;",
			"        }",
			"        poly &derivate() {",
			"            derivate(begin(), size());",
			"            shrink();",
			"            return *this;",
			"        }",
			"        poly &integrate() {",
			"            push_back(0);",
			"            integrate(begin(), size() - 1);",
			"            shrink();",
			"            return *this;",
			"        }",
			"        _Tp at(uint32_t __i) const { return __i < size() ? (*this)[__i] : 0; }",
			"        poly &operator+=(const poly &__other) {",
			"            _transform(sizeTo(std::max<uint32_t>(size(), __other.size())).begin(), __other.begin(), __other.size(), std::plus<_Tp>());",
			"            return shrink();",
			"        }",
			"        poly &operator-=(const poly &__other) {",
			"            _transform(sizeTo(std::max<uint32_t>(size(), __other.size())).begin(), __other.begin(), __other.size(), std::minus<_Tp>());",
			"            return shrink();",
			"        }",
			"        poly &operator*=(_Tp __other) {",
			"            if (!__other)",
			"                clear();",
			"            else",
			"                for (auto &a : *this) a *= __other;",
			"            return *this;",
			"        }",
			"        poly &operator*=(const poly &__other) { return (*this = product(*this, __other, std::__bit_ceil(size() + __other.size() - 1))).shrink(); }",
			"        poly &operator/=(_Tp __other) {",
			"            for (auto &a : *this) a /= __other;",
			"            return *this;",
			"        }",
			"        poly operator+() const { return *this; }",
			"        poly operator-() const {",
			"            poly res(*this);",
			"            std::transform(res.begin(), res.end(), res.begin(), std::negate<_Tp>());",
			"            return res;",
			"        }",
			"        friend poly operator+(const poly &__a, const poly &__b) {",
			"            poly res(__a);",
			"            res += __b;",
			"            return res;",
			"        }",
			"        friend poly operator-(const poly &__a, const poly &__b) {",
			"            poly res(__a);",
			"            res -= __b;",
			"            return res;",
			"        }",
			"        friend poly operator*(const poly &__a, _Tp __b) {",
			"            poly res(__a);",
			"            res *= __b;",
			"            return res;",
			"        }",
			"        friend poly operator*(const poly &__a, const poly &__b) {",
			"            poly res(product(__a, __b, std::__bit_ceil(__a.size() + __b.size() - 1)));",
			"            res.shrink();",
			"            return res;",
			"        }",
			"        friend poly operator/(const poly &__a, _Tp __b) {",
			"            poly res(__a);",
			"            res /= __b;",
			"            return res;",
			"        }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &__is, poly &__self) {",
			"            for (auto &a : __self) __is >> a;",
			"            return __is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &__os, const poly &__self) {",
			"            for (auto &a : __self) __os << a << ' ';",
			"            return __os;",
			"        }",
			"        _Tp calc(_Tp __x) const {",
			"            _Tp res = 0;",
			"            for (uint32_t i = size() - 1; ~i; i--) res = res * __x + (*this)[i];",
			"            return res;",
			"        }",
			"        poly ChirpZ(_Tp __x, uint32_t __n) const {",
			"            if (empty()) return poly(__n, 0);",
			"            const uint32_t length = std::__bit_ceil(size() + __n - 1);",
			"            const _Tp inv(__x.inv());",
			"            _Tp cur(1), pow(1);",
			"            for (uint32_t i = 0; i < size() + __n - 1; i++, cur *= pow, pow *= __x) s_dftBuffer[i] = cur;",
			"            cur = _Tp(1), pow = _Tp(1);",
			"            for (uint32_t i = size() - 1; ~i; i--, cur *= pow, pow *= inv) s_dftBuffer[length + i] = (*this)[size() - 1 - i] * cur;",
			"            idft(_transform(dft(std::fill_n(s_dftBuffer + size() + __n - 1, length - size() - __n + 1, 0) - length, length), dft(std::fill_n(s_dftBuffer + length + size(), length - size(), 0) - length, length), length, std::multiplies<_Tp>()), length);",
			"            cur = _Tp(1).inv(), pow = _Tp(1);",
			"            for (uint32_t i = size() - 1, j = 0; j < __n; i++, j++, cur *= pow, pow *= inv) s_dftBuffer[i] *= cur;",
			"            return poly(s_dftBuffer + size() - 1, s_dftBuffer + size() - 1 + __n);",
			"        }",
			"        poly inv() const {",
			"            static constexpr uint32_t R = 16;",
			"            const uint32_t Block = std::__bit_ceil((size() - 1) / R + 1);",
			"            _Tp f[Block * R * 2], g[Block * R * 2], res[Block * (R + 1)];",
			"            res[0] = (*this)[0].inv();",
			"            auto dfs = [&](auto self, uint32_t n) -> void {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(f, block * 2, begin(), block);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(f + block * k * 2, block * 2, begin() + block * k, block * k < size() ? std::min<uint32_t>(size() - block * k, block) : 0);",
			"                    dft(std::copy_n(std::fill_n(res + block * k, block * 2, 0) - block * 3, block * 2, g + block * (k - 1) * 2) - block * 2, block * 2);",
			"                    for (uint32_t j = 0; j < k; j++)",
			"                        for (_Tp *it = res + block * k, *it1 = g + block * j * 2, *it2 = f + block * (k - j) * 2, *it3 = f + block * (k - j - 1) * 2, *end = res + block * (k + 2); it != end;) *it++ -= *it1++ * (*it2++ + *it3++), *it++ -= *it1++ * (*it2++ - *it3++);",
			"                    idft(_transform(dft(_setHighZero(idft(res + block * k, block * 2), block * 2), block * 2), g, block * 2, std::multiplies<_Tp>()), block * 2);",
			"                }",
			"            };",
			"            dfs(dfs, size());",
			"            return poly(res, res + size());",
			"        }",
			"        poly sqrt(_Tp __a0 = 1) const {",
			"            if (empty()) return poly();",
			"            static constexpr uint32_t R = 16;",
			"            const _Tp inv2(_Tp::mod() / 2 + 1);",
			"            const uint32_t Block = std::__bit_ceil((size() - 1) / R + 1);",
			"            _Tp g[Block * R * 2], h[Block * 2], res[Block * (R + 1)];",
			"            res[0] = __a0;",
			"            auto dfs = [&](auto self, uint32_t n) {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(h, block * 2, poly(res, res + block).inv().begin(), block);",
			"                std::fill_n(g, block * R * 2, 0);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(std::copy_n(std::fill_n(res + block * k, block * 2, 0) - block * 3, block * 2, g + block * (k - 1) * 2) - block * 2, block * 2);",
			"                    for (uint32_t j = 0; j < k; j++)",
			"                        for (_Tp *it = res + block * k, *it1 = g + block * j * 2, *it2 = g + block * (k - j) * 2, *it3 = g + block * (k - j - 1) * 2, *end = res + block * (k + 2); it != end;) *it++ -= *it1++ * (*it2++ + *it3++), *it++ -= *it1++ * (*it2++ - *it3++);",
			"                    _setHighZero(idft(res + block * k, block * 2), block * 2);",
			"                    for (uint32_t i = block * k, iend = block * (k + 1); i < iend; i++) res[i] += at(i);",
			"                    idft(_transform(dft(res + block * k, block * 2), h, block * 2, std::multiplies<_Tp>()), block * 2);",
			"                    for (uint32_t i = block * k, iend = block * (k + 1); i < iend; i++) res[i] *= inv2;",
			"                }",
			"            };",
			"            dfs(dfs, size());",
			"            return poly(res, res + size());",
			"        }",
			"        std::pair<poly, poly> divmod(const poly &__other) const {",
			"            if (size() < __other.size()) return {poly(), *this};",
			"            std::pair<poly, poly> res;",
			"            res.first = div(__other, size() - __other.size() + 1);",
			"            res.second = *this - res.first * __other;",
			"            return res;",
			"        }",
			"        poly div(const poly &__other, uint32_t __length = -1) const {",
			"            __length = std::min<uint32_t>(__length, size());",
			"            static constexpr uint32_t R = 16;",
			"            const uint32_t Block = std::__bit_ceil((__length - 1) / R + 1);",
			"            _Tp f[Block * R * 2], g[Block * R * 2], h[Block * 2], a[Block * R], b[Block * R], res[Block * (R + 1)];",
			"            poly binv(poly(__other).reverse().sizeTo(Block).inv());",
			"            std::fill(std::copy_n(rbegin(), __length, a), a + Block * R, 0);",
			"            std::fill(std::copy_n(__other.rbegin(), std::min<uint32_t>(__length, __other.size()), b), b + Block * R, 0);",
			"            res[0] = a[0] * b[0].inv();",
			"            auto dfs = [&](auto self, uint32_t n) -> void {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(h, block * 2, binv.begin(), block);",
			"                dft(f, block * 2, b, block);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(f + block * k * 2, block * 2, b + block * k, block);",
			"                    dft(std::copy_n(std::fill_n(res + block * k, block * 2, 0) - block * 3, block * 2, g + block * (k - 1) * 2) - block * 2, block * 2);",
			"                    for (uint32_t j = 0; j < k; j++)",
			"                        for (_Tp *it = res + block * k, *it1 = g + block * j * 2, *it2 = f + block * (k - j) * 2, *it3 = f + block * (k - j - 1) * 2, *end = res + block * (k + 2); it != end;) *it++ -= *it1++ * (*it2++ + *it3++), *it++ -= *it1++ * (*it2++ - *it3++);",
			"                    idft(_transform(dft(_transform(_setHighZero(idft(res + block * k, block * 2), block * 2), a + block * k, block, std::plus<_Tp>()), block * 2), h, block * 2, std::multiplies<_Tp>()), block * 2);",
			"                }",
			"            };",
			"            dfs(dfs, __length);",
			"            return poly(res, res + __length).reverse();",
			"        }",
			"        poly mod(const poly &__other) const { return divmod(__other).second; }",
			"        poly logarithm() const {",
			"            prepareInverse(size());",
			"            poly f(*this);",
			"            for (uint32_t i = 0; i < size(); i++) f[i] *= i;",
			"            (f = f.reverse().div(poly(*this).reverse())).reverse();",
			"            for (uint32_t i = 1; i < size(); i++) f[i] *= s_inverse[i];",
			"            return f;",
			"        }",
			"        poly exponent() const {",
			"            if (empty()) return poly{_Tp(1)};",
			"            static constexpr uint32_t R = 16;",
			"            const uint32_t Block = std::__bit_ceil((size() - 1) / R + 1);",
			"            _Tp f[Block * R * 2], g[Block * R * 2], h[Block * 2], a[Block * R], res[Block * (R + 1)];",
			"            std::fill(std::copy_n(begin(), size(), a), a + Block * R, 0);",
			"            for (uint32_t i = 0; i < size(); i++) a[i] *= i;",
			"            res[0] = 1;",
			"            prepareInverse(Block * (R + 1));",
			"            auto dfs = [&](auto self, uint32_t n) -> void {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(h, block * 2, poly(res, res + block).inv().begin(), block);",
			"                dft(f, block * 2, a, block);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(f + block * k * 2, block * 2, a + block * k, block);",
			"                    dft(std::copy_n(std::fill_n(res + block * k, block * 2, 0) - block * 3, block * 2, g + block * (k - 1) * 2) - block * 2, block * 2);",
			"                    for (uint32_t j = 0; j < k; j++)",
			"                        for (_Tp *it = res + block * k, *it1 = g + block * j * 2, *it2 = f + block * (k - j) * 2, *it3 = f + block * (k - j - 1) * 2, *end = res + block * (k + 2); it != end;) *it++ += *it1++ * (*it2++ + *it3++), *it++ += *it1++ * (*it2++ - *it3++);",
			"                    idft(_transform(dft(_transform(_setHighZero(idft(_transform(dft(_setHighZero(idft(res + block * k, block * 2), block * 2), block * 2), h, block * 2, std::multiplies<_Tp>()), block * 2), block * 2), s_inverse + block * k, block, std::multiplies<_Tp>()), block * 2), g, block * 2, std::multiplies<_Tp>()), block * 2);",
			"                }",
			"            };",
			"            dfs(dfs, size());",
			"            return poly(res, res + size());",
			"        }",
			"        static poly _simplePow(const poly &__a, _Tp __n) { return (__a.logarithm() * __n).exponent(); }",
			"        template <typename _Fp>",
			"        poly pow(_Tp __n1, _Fp __n2, uint64_t __nAbs = UINT64_MAX) const {",
			"            const uint64_t zero = std::find_if(begin(), end(), [](const _Tp &x) { return x.val() != 0; }) - begin();",
			"            if (zero && __nAbs >= (size() + zero - 1) / zero) return poly();",
			"            if (!__n1) return poly{(*this)[zero].pow(__n2.val())};",
			"            uint32_t rest = size() - zero * __nAbs;",
			"            poly a(begin() + zero, begin() + zero + std::min<uint32_t>(rest, size() - zero)), res(size(), _Tp(0));",
			"            const _Tp a0(a[0]);",
			"            (a = _simplePow(a *= a0.inv(), __n1)) *= a0.pow(__n2.val());",
			"            std::copy_n(a.begin(), a.size(), res.begin() + (size() - rest));",
			"            return res;",
			"        }",
			"        static void _initTree(const poly &__xs, uint32_t __length) {",
			"            _Tp *it = s_treeBuffer + __length * 2 * std::__countr_zero(__length / 2);",
			"            for (uint32_t i = 0; i < __length; i++) *it++ = _Tp(1), *it++ = -__xs.at(i);",
			"            for (uint32_t h = 2; h < __length; h *= 2) {",
			"                _Tp *it = s_treeBuffer + __length * 2 * std::__countr_zero(__length / 2 / h);",
			"                for (uint32_t i = 0; i < __length; i += h, it += h * 2) {",
			"                    idft(std::fill_n(std::transform(dft(it + __length * 2, h), it + __length * 2 + h, dft(it + __length * 2 + h, h), it, std::multiplies<_Tp>()), h, 0) - h * 2, h);",
			"                    *(it + h) = *it - 1, *it = 1;",
			"                }",
			"            }",
			"            idft(std::transform(dft(s_treeBuffer, __length), s_treeBuffer + __length, dft(s_treeBuffer + __length, __length), s_treeSum.sizeTo(__length * 2).begin(), std::multiplies<_Tp>()) - __length, __length);",
			"            s_treeSum[__length] = s_treeSum[0] - _Tp(1);",
			"            s_treeSum[0] = _Tp(1);",
			"        }",
			"        static poly _calcTree(const poly &__f, uint32_t __resLength) {",
			"            const uint32_t length = std::__bit_ceil(std::max<uint32_t>(__f.size(), s_treeSum.size() / 2));",
			"            poly res(length);",
			"            std::copy_n(__f.div(s_treeSum.reverse()).reverse().begin(), __f.size(), res.begin() + length - __f.size());",
			"            for (uint32_t h = length / 2; h; h /= 2)",
			"                for (_Tp *it = res.data(), *end = res.data() + __resLength, *it2 = s_treeBuffer + length * 2 * std::__countr_zero(length / 2 / h); it < end; it += h * 2, it2 += h * 4) std::copy_n(s_dftBuffer + h, h, std::copy_n(idft(_transform(idft(_transform(std::copy_n(it2 + h * 2, h * 2, std::copy_n(it2, h * 2, s_dftBuffer)) - h * 4, dft(it, h * 2), h * 2, std::multiplies<_Tp>()), h * 2) + h * 2, it, h * 2, std::multiplies<_Tp>()), h * 2) + h, h, it));",
			"            res.sizeTo(__resLength);",
			"            return res;",
			"        }",
			"        static poly fromPoints(const poly &__xs, const poly &__ys) {",
			"            if (__xs.size() <= 1) return __ys;",
			"            const uint32_t length = std::__bit_ceil(__xs.size());",
			"            _initTree(__xs, length);",
			"            poly res(_calcTree(poly(s_treeSum).sizeTo(__xs.size() + 1).reverse().derivate(), __xs.size()).sizeTo(length));",
			"            for (uint32_t i = 0; i < __ys.size(); i++) res[i] = __ys[i] / res[i];",
			"            for (uint32_t h = 1; h < length; h *= 2)",
			"                for (_Tp *it = res.data(), *end = res.data() + __xs.size(), *it2 = s_treeBuffer + length * 2 * std::__countr_zero(length / 2 / h); it < end; it += h * 2, it2 += h * 4) {",
			"                    dft(dft(s_dftBuffer, h * 2, it, h) + h * 2, h * 2, it + h, h);",
			"                    for (uint32_t i = 0; i < h * 2; i++) *(it + i) = s_dftBuffer[i] * *(it2 + (h * 2 + i)) + s_dftBuffer[h * 2 + i] * *(it2 + i);",
			"                    idft(it, h * 2);",
			"                }",
			"            res.sizeTo(__xs.size()).reverse();",
			"            return res;",
			"        }",
			"        poly calc(const poly &__xs) const {",
			"            _initTree(__xs, std::__bit_ceil(std::max<uint32_t>(__xs.size(), size())));",
			"            return _calcTree(*this, __xs.size());",
			"        }",
			"    };",
			"}",
		],
		"description": "NTT polynomial"
	},
	"NTT_ex":{
		"prefix": "NTT",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, uint32_t _MAXN = 1 << 22, uint32_t _P1 = 1107296257, uint32_t _R1 = 10, uint32_t _P2 = 1711276033, uint32_t _R2 = 29, uint32_t _P3 = 1811939329, uint32_t _R3 = 13>",
			"    struct NTTPolynomial_ex : std::vector<_Tp> {",
			"        using poly = NTTPolynomial_ex<_Tp, _MAXN, _P1, _R1, _P2, _R2, _P3, _R3>;",
			"        using std::vector<_Tp>::vector, std::vector<_Tp>::begin, std::vector<_Tp>::end, std::vector<_Tp>::rbegin, std::vector<_Tp>::rend, std::vector<_Tp>::size, std::vector<_Tp>::back, std::vector<_Tp>::empty, std::vector<_Tp>::clear, std::vector<_Tp>::pop_back, std::vector<_Tp>::resize, std::vector<_Tp>::push_back;",
			"        static inline struct triple {",
			"            static constexpr uint32_t inv_1_2 = Modular32<_P2>::pow(_P1, _P2 - 2), inv_12_3 = Modular32<_P3>::pow(Modular32<_P3>::multiply(_P1, _P2), _P3 - 2);",
			"            static constexpr uint64_t P12 = uint64_t(_P1) * _P2;",
			"            uint32_t x, y, z;",
			"            triple() = default;",
			"            triple(uint32_t _val) : x(_val), y(_val), z(_val) {}",
			"            triple(_Tp _val) : x(_val.val()), y(_val.val()), z(_val.val()) {}",
			"            triple(uint32_t _x, uint32_t _y, uint32_t _z) : x(_x), y(_y), z(_z) {}",
			"            static triple root(uint32_t __n) { return triple(Modular32<_P1>::pow(_R1, (_P1 - 1) / __n), Modular32<_P2>::pow(_R2, (_P2 - 1) / __n), Modular32<_P3>::pow(_R3, (_P3 - 1) / __n)); }",
			"            static triple inv(uint32_t __x) { return triple(Modular32<_P1>::pow(__x, _P1 - 2), Modular32<_P2>::pow(__x, _P2 - 2), Modular32<_P3>::pow(__x, _P3 - 2)); }",
			"            triple operator+(const triple &_other) const { return triple(Modular32<_P1>::plus(x, _other.x), Modular32<_P2>::plus(y, _other.y), Modular32<_P3>::plus(z, _other.z)); }",
			"            triple operator-(const triple &_other) const { return triple(Modular32<_P1>::minus(x, _other.x), Modular32<_P2>::minus(y, _other.y), Modular32<_P3>::minus(z, _other.z)); }",
			"            triple operator*(const triple &_other) const { return triple(Modular32<_P1>::multiply(x, _other.x), Modular32<_P2>::multiply(y, _other.y), Modular32<_P3>::multiply(z, _other.z)); }",
			"            triple &operator+=(const triple &_other) { return *this = operator+(_other); }",
			"            triple &operator-=(const triple &_other) { return *this = operator-(_other); }",
			"            triple &operator*=(const triple &_other) { return *this = operator*(_other); }",
			"            triple &reduce() {",
			"                uint64_t X = uint64_t(Modular32<_P2>::multiply(Modular32<_P2>::minus(y, x), inv_1_2)) * _P1 + x;",
			"                _Tp val(Modular32<_P3>::multiply(Modular32<_P3>::minus(z, Modular32<_P3>::mod(X)), inv_12_3) * _Tp(P12) + X);",
			"                return *this = triple(val.val(), val.val(), val.val());",
			"            }",
			"            operator _Tp() const { return _Tp(x); }",
			"        } s_dftRoots[_MAXN], s_dftBuffer[_MAXN * 2], s_treeBuffer[_MAXN * 2 * (std::__countr_zero(_MAXN))];",
			"        static inline _Tp s_inverse[_MAXN + 1];",
			"        static inline uint32_t s_dftBin[_MAXN * 2], s_dftSize = 1, s_inverseSize = 0;",
			"        static inline poly s_treeSum;",
			"        static void prepareDFT(uint32_t __length) {",
			"            if (__length > s_dftSize) {",
			"                if (s_dftSize == 1) s_dftRoots[s_dftSize++] = triple(1);",
			"                for (; s_dftSize < __length; s_dftSize *= 2) {",
			"                    const triple wn(triple::root(s_dftSize * 2));",
			"                    for (uint32_t i = s_dftSize; i < s_dftSize * 2; i += 2) {",
			"                        s_dftRoots[i] = s_dftRoots[i / 2];",
			"                        s_dftRoots[i + 1] = s_dftRoots[i / 2] * wn;",
			"                    }",
			"                }",
			"            }",
			"            if (__length > 1 && !s_dftBin[__length + 1])",
			"                for (uint32_t i = 0; i < __length; i += 2) {",
			"                    s_dftBin[__length + i] = s_dftBin[__length + i / 2] / 2;",
			"                    s_dftBin[__length + i + 1] = s_dftBin[__length + i / 2] / 2 + __length / 2;",
			"                }",
			"        }",
			"        template <typename _Iterator>",
			"        static _Iterator _dft(_Iterator __iter, uint32_t __length) {",
			"            for (uint32_t i = 0; i < __length; i++)",
			"                if (uint32_t j = s_dftBin[__length + i]; i < j) std::swap(*(__iter + i), *(__iter + j));",
			"            for (uint32_t h = 2; h <= __length; h *= 2)",
			"                for (uint32_t j = 0; j < __length; j += h)",
			"                    for (uint32_t k = j; k < j + h / 2; k++) {",
			"                        triple x(*(__iter + k)), y(*(__iter + (k + h / 2)) * s_dftRoots[h / 2 + k - j]);",
			"                        *(__iter + k) += y;",
			"                        *(__iter + (k + h / 2)) = x - y;",
			"                    }",
			"            return __iter;",
			"        }",
			"        template <typename _Iterator>",
			"        static _Iterator _setHighZero(_Iterator __iter, uint32_t __length) { return std::fill_n(__iter + __length / 2, __length / 2, 0) - __length; }",
			"        template <typename _Iterator>",
			"        static _Iterator dft(_Iterator __iter, uint32_t __length) { return prepareDFT(__length), _dft(__iter, __length); }",
			"        template <typename _Iterator, typename _Iterator2>",
			"        static _Iterator dft(_Iterator __iter, uint32_t __dftLength, _Iterator2 __source, uint32_t __sourceLength) { return dft(std::fill_n(std::copy_n(__source, __sourceLength, __iter), __dftLength - __sourceLength, 0) - __dftLength, __dftLength); }",
			"        template <typename _Iterator>",
			"        static _Iterator idft(_Iterator __iter, uint32_t __length) {",
			"            _dft(__iter, __length);",
			"            std::reverse(__iter + 1, __iter + __length);",
			"            const triple inv(triple::inv(__length));",
			"            for (uint32_t i = 0; i < __length; i++) (*(__iter + i) *= inv).reduce();",
			"            return __iter;",
			"        }",
			"        template <typename _Iterator, typename _Iterator2, typename _Operation>",
			"        static _Iterator _transform(_Iterator __iter1, _Iterator2 __iter2, uint32_t __length, _Operation __op = _Operation()) { return std::transform(__iter1, __iter1 + __length, __iter2, __iter1, __op) - __length; }",
			"        static void prepareInverse(uint32_t __length) {",
			"            if (s_inverseSize >= __length) return;",
			"            if (!s_inverseSize) s_inverse[0] = s_inverse[++s_inverseSize] = _Tp(1);",
			"            const long long P(_Tp::mod());",
			"            for (uint32_t i = s_inverseSize + 1; i <= __length; i++) {",
			"                auto [q, r] = std::div(P, (long long)i);",
			"                s_inverse[i] = s_inverse[r] * _Tp(P - q);",
			"            }",
			"            s_inverseSize = __length;",
			"        }",
			"        template <typename _Iterator>",
			"        static void derivate(_Iterator __iter, uint32_t __length) {",
			"            if (!__length) return;",
			"            for (uint32_t i = 0; i + 1 < __length; i++) *(__iter + i) = *(__iter + (i + 1)) * (i + 1);",
			"            *(__iter + (__length - 1)) = _Tp(0);",
			"        }",
			"        template <typename _Iterator>",
			"        static void integrate(_Iterator __iter, uint32_t __length) {",
			"            if (!__length) return;",
			"            prepareInverse(__length);",
			"            for (uint32_t i = __length; i; i--) *(__iter + i) = *(__iter + (i - 1)) * s_inverse[i];",
			"            __iter[0] = 0;",
			"        }",
			"        static poly product(const poly &__a, const poly &__b, uint32_t __length) {",
			"            if (__a.empty() || __b.empty()) return poly();",
			"            idft(_transform(dft(s_dftBuffer, __length, __a.begin(), std::min<uint32_t>(__length, __a.size())), dft(s_dftBuffer + __length, __length, __b.begin(), std::min<uint32_t>(__length, __b.size())), __length, std::multiplies<triple>()), __length);",
			"            return poly(s_dftBuffer, s_dftBuffer + __length);",
			"        }",
			"        poly &shrink() {",
			"            while (size() && !back()) pop_back();",
			"            return *this;",
			"        }",
			"        poly &reverse() {",
			"            std::reverse(begin(), end());",
			"            return *this;",
			"        }",
			"        poly &sizeTo(uint32_t __size) {",
			"            resize(__size);",
			"            return *this;",
			"        }",
			"        poly &derivate() {",
			"            derivate(begin(), size());",
			"            shrink();",
			"            return *this;",
			"        }",
			"        poly &integrate() {",
			"            push_back(0);",
			"            integrate(begin(), size() - 1);",
			"            shrink();",
			"            return *this;",
			"        }",
			"        _Tp at(uint32_t __i) const { return __i < size() ? (*this)[__i] : 0; }",
			"        poly &operator+=(const poly &__other) {",
			"            _transform(sizeTo(std::max<uint32_t>(size(), __other.size())).begin(), __other.begin(), __other.size(), std::plus<_Tp>());",
			"            return shrink();",
			"        }",
			"        poly &operator-=(const poly &__other) {",
			"            _transform(sizeTo(std::max<uint32_t>(size(), __other.size())).begin(), __other.begin(), __other.size(), std::minus<_Tp>());",
			"            return shrink();",
			"        }",
			"        poly &operator*=(_Tp __other) {",
			"            if (!__other)",
			"                clear();",
			"            else",
			"                for (auto &a : *this) a *= __other;",
			"            return *this;",
			"        }",
			"        poly &operator*=(const poly &__other) { return (*this = product(*this, __other, std::__bit_ceil(size() + __other.size() - 1))).shrink(); }",
			"        poly &operator/=(_Tp __other) {",
			"            for (auto &a : *this) a /= __other;",
			"            return *this;",
			"        }",
			"        poly operator+() const { return *this; }",
			"        poly operator-() const {",
			"            poly res(*this);",
			"            std::transform(res.begin(), res.end(), res.begin(), std::negate<_Tp>());",
			"            return res;",
			"        }",
			"        friend poly operator+(const poly &__a, const poly &__b) {",
			"            poly res(__a);",
			"            res += __b;",
			"            return res;",
			"        }",
			"        friend poly operator-(const poly &__a, const poly &__b) {",
			"            poly res(__a);",
			"            res -= __b;",
			"            return res;",
			"        }",
			"        friend poly operator*(const poly &__a, _Tp __b) {",
			"            poly res(__a);",
			"            res *= __b;",
			"            return res;",
			"        }",
			"        friend poly operator*(const poly &__a, const poly &__b) {",
			"            poly res(product(__a, __b, std::__bit_ceil(__a.size() + __b.size() - 1)));",
			"            res.shrink();",
			"            return res;",
			"        }",
			"        friend poly operator/(const poly &__a, _Tp __b) {",
			"            poly res(__a);",
			"            res /= __b;",
			"            return res;",
			"        }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &__is, poly &__self) {",
			"            for (auto &a : __self) __is >> a;",
			"            return __is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &__os, const poly &__self) {",
			"            for (auto &a : __self) __os << a << ' ';",
			"            return __os;",
			"        }",
			"        _Tp calc(_Tp __x) const {",
			"            _Tp res = 0;",
			"            for (uint32_t i = size() - 1; ~i; i--) res = res * __x + (*this)[i];",
			"            return res;",
			"        }",
			"        poly ChirpZ(_Tp __x, uint32_t __n) const {",
			"            if (empty()) return poly(__n, 0);",
			"            const uint32_t length = std::__bit_ceil(size() + __n - 1);",
			"            const _Tp inv(__x.inv());",
			"            _Tp cur(1), pow(1);",
			"            for (uint32_t i = 0; i < size() + __n - 1; i++, cur *= pow, pow *= __x) s_dftBuffer[i] = cur;",
			"            cur = _Tp(1), pow = _Tp(1);",
			"            for (uint32_t i = size() - 1; ~i; i--, cur *= pow, pow *= inv) s_dftBuffer[length + i] = (*this)[size() - 1 - i] * cur;",
			"            idft(_transform(dft(std::fill_n(s_dftBuffer + size() + __n - 1, length - size() - __n + 1, 0) - length, length), dft(std::fill_n(s_dftBuffer + length + size(), length - size(), 0) - length, length), length, std::multiplies<triple>()), length);",
			"            poly res(s_dftBuffer + size() - 1, s_dftBuffer + size() - 1 + __n);",
			"            cur = _Tp(1).inv(), pow = _Tp(1);",
			"            for (auto &a : res) a *= cur, cur *= pow, pow *= inv;",
			"            return res;",
			"        }",
			"        poly inv() const {",
			"            static constexpr uint32_t R = 16;",
			"            const uint32_t Block = std::__bit_ceil((size() - 1) / R + 1);",
			"            _Tp res[Block * R];",
			"            triple f[Block * R * 2], g[Block * R * 2], h[Block * 2];",
			"            res[0] = (*this)[0].inv();",
			"            auto dfs = [&](auto self, uint32_t n) -> void {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(f, block * 2, begin(), block);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(f + block * k * 2, block * 2, begin() + block * k, block * k < size() ? std::min<uint32_t>(size() - block * k, block) : 0);",
			"                    dft(g + block * (k - 1) * 2, block * 2, res + block * (k - 1), block);",
			"                    std::fill_n(h, block * 2, 0);",
			"                    for (uint32_t j = 0; j < k; j++)",
			"                        for (triple *it = h, *it1 = g + block * j * 2, *it2 = f + block * (k - j) * 2, *it3 = f + block * (k - j - 1) * 2, *end = h + block * 2; it != end;) *it++ += *it1++ * (*it2++ + *it3++), *it++ += *it1++ * (*it2++ - *it3++);",
			"                    idft(h, block * 2);",
			"                    for (uint32_t i = 0; i < block * 2; i++) h[i] = -_Tp(h[i]);",
			"                    std::copy_n(idft(_transform(dft(_setHighZero(h, block * 2), block * 2), g, block * 2, std::multiplies<triple>()), block * 2), block, res + block * k);",
			"                }",
			"            };",
			"            dfs(dfs, size());",
			"            return poly(res, res + size());",
			"        }",
			"        poly sqrt(_Tp __a0 = 1) const {",
			"            if (empty()) return poly();",
			"            static constexpr uint32_t R = 16;",
			"            const _Tp inv(_Tp(2).inv());",
			"            const uint32_t Block = std::__bit_ceil((size() - 1) / R + 1);",
			"            _Tp res[Block * R];",
			"            triple f[Block * 2], g[Block * R * 2], h[Block * 2];",
			"            res[0] = __a0;",
			"            auto dfs = [&](auto self, uint32_t n) {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(f, block * 2, poly(res, res + block).inv().begin(), block);",
			"                std::fill_n(g, block * R * 2, 0);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(g + block * (k - 1) * 2, block * 2, res + block * (k - 1), block);",
			"                    std::fill_n(h, block * 2, 0);",
			"                    for (uint32_t j = 0; j < k; j++)",
			"                        for (triple *it = h, *it1 = g + block * j * 2, *it2 = g + block * (k - j) * 2, *it3 = g + block * (k - j - 1) * 2, *end = h + block * 2; it != end;) *it++ += *it1++ * (*it2++ + *it3++), *it++ += *it1++ * (*it2++ - *it3++);",
			"                    _setHighZero(idft(h, block * 2), block * 2);",
			"                    for (uint32_t i = 0; i < block; i++) h[i] = at(block * k + i) - _Tp(h[i]);",
			"                    idft(_transform(dft(h, block * 2), f, block * 2, std::multiplies<triple>()), block * 2);",
			"                    for (uint32_t i = 0; i < block; i++) res[block * k + i] = _Tp(h[i]) * inv;",
			"                }",
			"            };",
			"            dfs(dfs, size());",
			"            return poly(res, res + size());",
			"        }",
			"        std::pair<poly, poly> divmod(const poly &__other) const {",
			"            if (size() < __other.size()) return {poly(), *this};",
			"            std::pair<poly, poly> res;",
			"            res.first = div(__other, size() - __other.size() + 1);",
			"            res.second = *this - res.first * __other;",
			"            return res;",
			"        }",
			"        poly div(const poly &__other, uint32_t __length = -1) const {",
			"            __length = std::min<uint32_t>(__length, size());",
			"            static constexpr uint32_t R = 16;",
			"            const uint32_t Block = std::__bit_ceil((__length - 1) / R + 1);",
			"            _Tp res[Block * R], a[Block * R], b[Block * R];",
			"            triple f[Block * R * 2], g[Block * R * 2], h[Block * 2], bi[Block * 2];",
			"            poly binv(poly(__other).reverse().sizeTo(Block).inv());",
			"            std::fill(std::copy_n(rbegin(), __length, a), a + Block * R, 0);",
			"            std::fill(std::copy_n(__other.rbegin(), std::min<uint32_t>(__length, __other.size()), b), b + Block * R, 0);",
			"            res[0] = a[0] * b[0].inv();",
			"            auto dfs = [&](auto self, uint32_t n) -> void {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(bi, block * 2, binv.begin(), block);",
			"                dft(f, block * 2, b, block);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(f + block * k * 2, block * 2, b + block * k, block);",
			"                    dft(g + block * (k - 1) * 2, block * 2, res + block * (k - 1), block);",
			"                    std::fill_n(h, block * 2, 0);",
			"                    for (uint32_t j = 0; j < k; j++)",
			"                        for (triple *it = h, *it1 = g + block * j * 2, *it2 = f + block * (k - j) * 2, *it3 = f + block * (k - j - 1) * 2, *end = h + block * 2; it != end;) *it++ += *it1++ * (*it2++ + *it3++), *it++ += *it1++ * (*it2++ - *it3++);",
			"                    _setHighZero(idft(h, block * 2), block * 2);",
			"                    for (uint32_t i = 0; i < block; i++) h[i] = _Tp(a[block * k + i]) - _Tp(h[i]);",
			"                    std::copy_n(idft(_transform(dft(h, block * 2), bi, block * 2, std::multiplies<triple>()), block * 2), block, res + block * k);",
			"                }",
			"            };",
			"            dfs(dfs, __length);",
			"            return poly(res, res + __length).reverse();",
			"        }",
			"        poly mod(const poly &__other) const { return divmod(__other).second; }",
			"        poly logarithm() const {",
			"            prepareInverse(size());",
			"            poly f(*this);",
			"            for (uint32_t i = 0; i < size(); i++) f[i] *= i;",
			"            (f = f.reverse().div(poly(*this).reverse())).reverse();",
			"            for (uint32_t i = 1; i < size(); i++) f[i] *= s_inverse[i];",
			"            return f;",
			"        }",
			"        poly exponent() const {",
			"            if (empty()) return poly{_Tp(1)};",
			"            static constexpr uint32_t R = 16;",
			"            const uint32_t Block = std::__bit_ceil((size() - 1) / R + 1);",
			"            _Tp res[Block * R], a[Block * R];",
			"            triple f[Block * R * 2], g[Block * R * 2], h[Block * 2], bi[Block * 2];",
			"            std::fill(std::copy_n(begin(), size(), a), a + Block * R, 0);",
			"            for (uint32_t i = 0; i < size(); i++) a[i] *= i;",
			"            res[0] = 1;",
			"            prepareInverse(Block * (R + 1));",
			"            auto dfs = [&](auto self, uint32_t n) -> void {",
			"                if (n == 1) return;",
			"                const uint32_t block = std::__bit_ceil((n - 1) / R + 1);",
			"                self(self, block);",
			"                dft(bi, block * 2, poly(res, res + block).inv().begin(), block);",
			"                dft(f, block * 2, a, block);",
			"                for (uint32_t k = 1; block * k < n; k++) {",
			"                    dft(f + block * k * 2, block * 2, a + block * k, block);",
			"                    dft(g + block * (k - 1) * 2, block * 2, res + block * (k - 1), block);",
			"                    std::fill_n(h, block * 2, 0);",
			"                    for (uint32_t j = 0; j < k; j++)",
			"                        for (triple *it = h, *it1 = g + block * j * 2, *it2 = f + block * (k - j) * 2, *it3 = f + block * (k - j - 1) * 2, *end = h + block * 2; it != end;) *it++ += *it1++ * (*it2++ + *it3++), *it++ += *it1++ * (*it2++ - *it3++);",
			"                    std::copy_n(idft(_transform(dft(_transform(_setHighZero(idft(_transform(dft(_setHighZero(idft(h, block * 2), block * 2), block * 2), bi, block * 2, std::multiplies<triple>()), block * 2), block * 2), s_inverse + block * k, block, std::multiplies<_Tp>()), block * 2), g, block * 2, std::multiplies<triple>()), block * 2), block, res + block * k);",
			"                }",
			"            };",
			"            dfs(dfs, size());",
			"            return poly(res, res + size());",
			"        }",
			"        static poly _simplePow(const poly &__a, _Tp __n) { return (__a.logarithm() * __n).exponent(); }",
			"        template <typename _Fp>",
			"        poly pow(_Tp __n1, _Fp __n2, uint64_t __nAbs = UINT_MAX) const {",
			"            const uint64_t zero = std::find_if(begin(), end(), [](const _Tp &x) { return x.val() != 0; }) - begin();",
			"            if (zero && __nAbs >= (size() + zero - 1) / zero) return poly();",
			"            if (!__n1) return poly{(*this)[zero].pow(__n2.val())};",
			"            uint32_t rest = size() - zero * __nAbs;",
			"            poly a(begin() + zero, begin() + zero + std::min<uint32_t>(rest, size() - zero)), res(size(), _Tp(0));",
			"            const _Tp a0(a[0]);",
			"            (a = _simplePow(a *= a0.inv(), __n1)) *= a0.pow(__n2.val());",
			"            std::copy_n(a.begin(), a.size(), res.begin() + (size() - rest));",
			"            return res;",
			"        }",
			"        static void _initTree(const poly &__xs, uint32_t __length) {",
			"            triple *it = s_treeBuffer + __length * 2 * std::__countr_zero(__length / 2);",
			"            for (uint32_t i = 0; i < __length; i++) *it++ = triple(1), *it++ = triple(-__xs.at(i));",
			"            for (uint32_t h = 2; h < __length; h *= 2) {",
			"                triple *it = s_treeBuffer + __length * 2 * std::__countr_zero(__length / 2 / h);",
			"                for (uint32_t i = 0; i < __length; i += h, it += h * 2) {",
			"                    idft(std::fill_n(std::transform(dft(it + __length * 2, h), it + __length * 2 + h, dft(it + __length * 2 + h, h), it, std::multiplies<triple>()), h, 0) - h * 2, h);",
			"                    *(it + h) = *it - 1, *it = 1;",
			"                }",
			"            }",
			"            std::copy_n(idft(std::transform(dft(s_treeBuffer, __length), s_treeBuffer + __length, dft(s_treeBuffer + __length, __length), s_dftBuffer, std::multiplies<triple>()) - __length, __length), __length, s_treeSum.sizeTo(0).sizeTo(__length * 2).begin());",
			"            s_treeSum[__length] = s_treeSum[0] - _Tp(1);",
			"            s_treeSum[0] = _Tp(1);",
			"        }",
			"        static poly _calcTree(const poly &__f, uint32_t __resLength) {",
			"            const uint32_t length = s_treeSum.size() / 2;",
			"            triple res[length];",
			"            std::copy_n(__f.div(s_treeSum.reverse()).reverse().begin(), __f.size(), std::fill_n(res, length - __f.size(), 0));",
			"            for (uint32_t h = length / 2; h; h /= 2)",
			"                for (triple *it = res, *end = res + __resLength, *it2 = s_treeBuffer + length * 2 * std::__countr_zero(length / 2 / h); it < end; it += h * 2, it2 += h * 4) std::copy_n(s_dftBuffer + h, h, std::copy_n(idft(_transform(idft(_transform(std::copy_n(it2 + h * 2, h * 2, std::copy_n(it2, h * 2, s_dftBuffer)) - h * 4, dft(it, h * 2), h * 2, std::multiplies<triple>()), h * 2) + h * 2, it, h * 2, std::multiplies<triple>()), h * 2) + h, h, it));",
			"            return poly(res, res + __resLength);",
			"        }",
			"        static poly fromPoints(const poly &__xs, const poly &__ys) {",
			"            if (__xs.size() <= 1) return __ys;",
			"            const uint32_t length = std::__bit_ceil(__xs.size());",
			"            _initTree(__xs, length);",
			"            triple res[length];",
			"            std::fill(std::copy_n(_calcTree(poly(s_treeSum).sizeTo(__xs.size() + 1).reverse().derivate(), __xs.size()).begin(), __xs.size(), res), res + length, 0);",
			"            for (uint32_t i = 0; i < __ys.size(); i++) res[i] = __ys[i] / _Tp(res[i]);",
			"            for (uint32_t h = 1; h < length; h *= 2)",
			"                for (triple *it = res, *end = res + __xs.size(), *it2 = s_treeBuffer + length * 2 * std::__countr_zero(length / 2 / h); it < end; it += h * 2, it2 += h * 4) {",
			"                    dft(dft(s_dftBuffer, h * 2, it, h) + h * 2, h * 2, it + h, h);",
			"                    for (uint32_t i = 0; i < h * 2; i++) *(it + i) = s_dftBuffer[i] * *(it2 + (h * 2 + i)) + s_dftBuffer[h * 2 + i] * *(it2 + i);",
			"                    idft(it, h * 2);",
			"                }",
			"            poly _res(res, res + __xs.size());",
			"            _res.reverse();",
			"            return _res;",
			"        }",
			"        poly calc(const poly &__xs) const {",
			"            _initTree(__xs, std::__bit_ceil(std::max<uint32_t>(__xs.size(), size())));",
			"            return _calcTree(*this, __xs.size());",
			"        }",
			"    };",
			"}",
		],
		"description": "NTT_ex polynomial"
	},
	"pollard rho":{
		"prefix": "PR",
		"body": [
			"namespace OY {",
			"    struct Pollard_Rho {",
			"        static constexpr uint64_t batch = 128;",
			"        static inline std::mt19937_64 s_rander;",
			"        template <typename _Elem>",
			"        static _Elem pick(_Elem __n) {",
			"            // assert(!isPrime<_Elem>(__n));",
			"            if (__n % 2 == 0) return 2;",
			"            static Montgomery<_Elem> mg;",
			"            if (mg.mod() != __n) mg = Montgomery<_Elem>(__n);",
			"            std::uniform_int_distribution<_Elem> distribute(2, __n - 1);",
			"            _Elem v0, v1 = mg.init(distribute(s_rander)), prod = mg.init(1), c = mg.init(distribute(s_rander));",
			"            for (int i = 1; i < batch; i <<= 1) {",
			"                v0 = v1;",
			"                for (int j = 0; j < i; j++) v1 = mg.multiply(v1, v1) + c;",
			"                for (int j = 0; j < i; j++) {",
			"                    v1 = mg.multiply(v1, v1) + c;",
			"                    prod = mg.multiply(prod, v0 > v1 ? v0 - v1 : v1 - v0);",
			"                    if (!prod) return pick(__n);",
			"                }",
			"                if (_Elem g = std::gcd(prod, __n); g > 1) return g;",
			"            }",
			"            for (int i = batch;; i <<= 1) {",
			"                v0 = v1;",
			"                for (int j = 0; j < i; j++) v1 = mg.multiply(v1, v1) + c;",
			"                for (int j = 0; j < i; j += batch) {",
			"                    for (int k = 0; k < batch; k++) {",
			"                        v1 = mg.multiply(v1, v1) + c;",
			"                        prod = mg.multiply(prod, v0 > v1 ? v0 - v1 : v1 - v0);",
			"                        if (!prod) return pick(__n);",
			"                    }",
			"                    if (_Elem g = std::gcd(prod, __n); g > 1) return g;",
			"                }",
			"            }",
			"            return __n;",
			"        }",
			"        template <typename _Elem>",
			"        static auto decomposite(_Elem __n) {",
			"            struct node {",
			"                _Elem prime;",
			"                uint32_t count;",
			"            };",
			"            std::vector<node> res;",
			"            auto dfs = [&](auto self, _Elem cur) -> void {",
			"                if (!isPrime<_Elem>(cur)) {",
			"                    _Elem a = pick<_Elem>(cur);",
			"                    self(self, a);",
			"                    self(self, cur / a);",
			"                } else {",
			"                    auto find = std::find_if(res.begin(), res.end(), [cur](auto x) { return x.prime == cur; });",
			"                    if (find == res.end())",
			"                        res.push_back({cur, 1u});",
			"                    else",
			"                        find->count++;",
			"                }",
			"            };",
			"            if (__n % 2 == 0) {",
			"                res.push_back({2, uint32_t(std::__countr_zero(__n))});",
			"                __n >>= std::__countr_zero(__n);",
			"            }",
			"            if (__n > 1) dfs(dfs, __n);",
			"            std::sort(res.begin(), res.end(), [](auto &x, auto &y) { return x.prime < y.prime; });",
			"            return res;",
			"        }",
			"        template <typename _Elem>",
			"        static std::vector<_Elem> getFactors(_Elem __n) {",
			"            auto pf = decomposite(__n);",
			"            std::vector<_Elem> res;",
			"            _Elem count = 1;",
			"            for (auto [p, c] : pf) count *= c + 1;",
			"            res.reserve(count);",
			"            auto dfs = [&](auto self, int i, _Elem prod) -> void {",
			"                if (i == pf.size())",
			"                    res.push_back(prod);",
			"                else {",
			"                    auto [p, c] = pf[i];",
			"                    self(self, i + 1, prod);",
			"                    while (c--) self(self, i + 1, prod *= p);",
			"                }",
			"            };",
			"            dfs(dfs, 0, 1);",
			"            std::sort(res.begin(), res.end());",
			"            return res;",
			"        }",
			"        template <typename _Elem>",
			"        static _Elem EulerPhi(_Elem __n) {",
			"            for (auto [p, c] : decomposite(__n)) __n = __n / p * (p - 1);",
			"            return __n;",
			"        }",
			"    };",
			"}",
		],
		"description": "pollard rho"
	},
	"prime check":{
		"prefix": "PRIME",
		"body": [
			"namespace OY {",
			"    template <typename _Elem>",
			"    constexpr bool isPrime(_Elem n) {",
			"        if (std::is_same_v<_Elem, uint32_t> || n <= UINT32_MAX) {",
			"            if (n <= 1) return false;",
			"            if (n == 2 || n == 7 || n == 61) return true;",
			"            if (n % 2 == 0) return false;",
			"            Barrett32 brt(n);",
			"            uint32_t d = (n - 1) >> std::__countr_zero(n - 1);",
			"            for (auto &&a : {2, 7, 61}) {",
			"                uint32_t s = d, y = brt.pow_64(a, s);",
			"                while (s != n - 1 && y != 1 && y != n - 1) {",
			"                    y = brt.multiply_64(y, y);",
			"                    s <<= 1;",
			"                }",
			"                if (y != n - 1 && s % 2 == 0) return false;",
			"            }",
			"            return true;",
			"        } else {",
			"            // assert(n < 1ull < 63);",
			"            if (n % 2 == 0) return false;",
			"            Montgomery64 mg(n);",
			"            uint64_t d = (n - 1) >> std::__countr_zero(n - 1), one = mg.init(1);",
			"            for (auto &&a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {",
			"                uint64_t s = d, y = mg.pow(mg.init(a), s), t = mg.init(n - 1);",
			"                while (s != n - 1 && y != one && y != t) {",
			"                    y = mg.multiply(y, y);",
			"                    s <<= 1;",
			"                }",
			"                if (y != t && s % 2 == 0) return false;",
			"            }",
			"            return true;",
			"        }",
			"    }",
			"    constexpr auto isPrime32 = isPrime<uint32_t>;",
			"    constexpr auto isPrime64 = isPrime<uint64_t>;",
			"}",
		],
		"description": "prime check"
	},
	"prime sieve":{
		"prefix": "PRIME",
		"body": [
			"namespace OY {",
			"#pragma pack(4)",
			"    struct SievePair {",
			"        uint32_t P;",
			"        __uint128_t Pinv;",
			"        constexpr SievePair() : P{}, Pinv{} {}",
			"        constexpr SievePair(uint32_t _P) : P{_P}, Pinv{uint64_t(-1) / _P + 1} {}",
			"    };",
			"#pragma pack()",
			"    struct SievePairs {",
			"        static constexpr uint32_t smallBound = 10000;",
			"        static constexpr uint32_t smallPrimeCount = 1228;",
			"        static constexpr uint32_t smallPrimes[smallPrimeCount]{3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973};",
			"        SievePair sp[smallPrimeCount];",
			"        constexpr SievePairs() {",
			"            for (int i = 0; i < smallPrimeCount; i++) sp[i] = SievePair(smallPrimes[i]);",
			"        }",
			"    };",
			"    template <uint32_t _N>",
			"    class PrimeSieve {",
			"        uint32_t m_primeList[_N >= 1000000 ? _N / 12 : 100000];",
			"        uint32_t m_primeCnt;",
			"        static constexpr SievePairs s_pairs{};",
			"",
			"    public:",
			"        PrimeSieve() : m_primeList{}, m_primeCnt{0} {",
			"            constexpr uint32_t blockSize = 32768;",
			"            bool notP[blockSize]{0};",
			"            m_primeList[m_primeCnt++] = 2;",
			"            for (auto &&p : s_pairs.smallPrimes) m_primeList[m_primeCnt++] = p;",
			"            for (int start = s_pairs.smallBound, end = s_pairs.smallBound + (blockSize << 1); start <= _N; start = end, end += blockSize << 1) {",
			"                for (auto &&[p, pInv] : s_pairs.sp) {",
			"                    uint32_t j = ((start + p - 1) * pInv) >> 64;",
			"                    if (j * p > start + p - 1) j--;",
			"                    for (bool *it = notP + (((j | 1) * p - start) >> 1), *itend = notP + blockSize; it < itend; it += p) *it = true;",
			"                }",
			"                for (auto &b : notP) {",
			"                    if (b)",
			"                        b = false;",
			"                    else if (int i = start + ((&b - notP) << 1 | 1); i <= _N)",
			"                        m_primeList[m_primeCnt++] = i;",
			"                    else",
			"                        break;",
			"                }",
			"            }",
			"        }",
			"        std::bitset<_N + 1> to_bitset() const {",
			"            std::bitset<_N + 1> res;",
			"            for (int i = 0; i < m_primeCnt && i <= _N; i++) res.set(m_primeList[i]);",
			"            return res;",
			"        }",
			"        uint32_t queryKthPrime(int __k) const { return m_primeList[__k]; }",
			"        uint32_t count() const { return m_primeCnt; }",
			"    };",
			"}",
		],
		"description": "prime sieve"
	},
	"primitive root":{
		"prefix": "PROOT",
		"body": [
			"namespace OY {",
			"    template <uint32_t _N>",
			"    struct PrimitiveRootSieveSolver {",
			"        static inline EratosthenesSieve<_N, false, false, true, false> es;",
			"        static uint32_t pick(uint32_t P) { return es.querySmallestFactor(P); }",
			"        static std::vector<uint32_t> getSub(uint32_t phi) {",
			"            std::vector<uint32_t> res;",
			"            for (uint32_t cur = phi; cur > 1;) {",
			"                uint32_t prime = es.querySmallestFactor(cur);",
			"                res.push_back(phi / prime);",
			"                while (cur % prime == 0) cur /= prime;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"    struct PrimitiveRootPollardRhoSolver {",
			"        template <typename _ModType>",
			"        static _ModType pick(_ModType P) {",
			"            while (!isPrime<_ModType>(P)) P = Pollard_Rho::pick<_ModType>(P);",
			"            return P;",
			"        }",
			"        template <typename _ModType>",
			"        static std::vector<_ModType> getSub(_ModType phi) {",
			"            std::vector<_ModType> res;",
			"            auto comps = Pollard_Rho::decomposite<_ModType>(phi);",
			"            res.reserve(comps.size());",
			"            for (auto [p, c] : comps) res.push_back(phi / p);",
			"            return res;",
			"        }",
			"    };",
			"    template <typename _ModType, typename _Solver>",
			"    struct PrimitiveRoot {",
			"        static bool isPrimitiveRoot(_ModType a, _ModType phi, std::vector<_ModType> &sub, Barrett<_ModType> &brt) {",
			"            if (brt.pow(a, phi) != 1) return false;",
			"            for (auto v : sub)",
			"                if (brt.pow(a, v) == 1) return false;",
			"            return true;",
			"        }",
			"        static _ModType queryMin(_ModType P) {",
			"            if (P <= 4) return P - 1;",
			"            _ModType oddP = P & 1 ? P : P >> 1;",
			"            if (!(oddP & 1)) return 0;",
			"            _ModType prime = _Solver::pick(oddP);",
			"            while (oddP % prime == 0) oddP /= prime;",
			"            if (oddP > 1) return 0;",
			"            _ModType phi = (P & 1 ? P : P >> 1) / prime * (prime - 1);",
			"            std::vector<_ModType> sub = _Solver::getSub(phi);",
			"            Barrett<_ModType> brt(P);",
			"            uint32_t cur = 2;",
			"            while (!isPrimitiveRoot(cur, phi, sub, brt)) cur++;",
			"            return cur;",
			"        }",
			"    };",
			"    template <uint32_t _N>",
			"    using PrimitiveRoot32_Sieve = PrimitiveRoot<uint32_t, PrimitiveRootSieveSolver<_N>>;",
			"    using PrimitiveRoot32_PollardRho = PrimitiveRoot<uint32_t, PrimitiveRootPollardRhoSolver>;",
			"    using PrimitiveRoot64_PollardRho = PrimitiveRoot<uint64_t, PrimitiveRootPollardRhoSolver>;",
			"}",
		],
		"description": "primitive root"
	},
	"Rising Factorial Polynomial":{
		"prefix": "RFP",
		"body": [
			"namespace OY {",
			"    template <typename _Poly>",
			"    struct RisingFactorialPolynomial {",
			"        using rfpoly = RisingFactorialPolynomial<_Poly>;",
			"        using _Tp = typename _Poly::value_type;",
			"        static inline _Tp s_factorial[sizeof(_Poly::s_dftRoots) / sizeof(*_Poly::s_dftRoots)], s_factorialInv[sizeof(_Poly::s_dftRoots) / sizeof(*_Poly::s_dftRoots)];",
			"        static inline uint32_t s_factorialSize = 0;",
			"        _Poly m_coef;",
			"        static void prepareFactorial(uint32_t __length) {",
			"            if (s_factorialSize >= __length) return;",
			"            if (!s_factorialSize) {",
			"                s_factorial[0] = s_factorialInv[0] = s_factorial[1] = s_factorialInv[1] = _Tp(1);",
			"                s_factorialSize = 2;",
			"            }",
			"            const auto P(_Tp::mod());",
			"            for (uint32_t i = s_factorialSize; i < __length; i++) {",
			"                auto q = P / i, r = P - q * i;",
			"                s_factorial[i] = s_factorial[i - 1] * _Tp(i), s_factorialInv[i] = s_factorialInv[i - 1] * s_factorialInv[r] * s_factorial[r - 1] * _Tp(P - q);",
			"            }",
			"            s_factorialSize = std::max<uint32_t>(__length, 2);",
			"        }",
			"        static _Poly ex(uint32_t __length) { return prepareFactorial(__length), _Poly(s_factorialInv, s_factorialInv + __length); }",
			"        static _Poly exInv(uint32_t __length) {",
			"            _Poly res(ex(__length));",
			"            for (uint32_t i = 1; i < res.size(); i += 2) res[i] = -res[i];",
			"            return res;",
			"        }",
			"        static rfpoly fromPoints(_Poly __ys) {",
			"            prepareFactorial(__ys.size());",
			"            const uint32_t length = __ys.size();",
			"            for (uint32_t i = 0; i < __ys.size(); i++) __ys[i] *= s_factorialInv[i];",
			"            rfpoly res;",
			"            (res.m_coef = __ys * exInv(__ys.size())).sizeTo(length);",
			"            for (uint32_t i = 1; i < res.m_coef.size(); i += 2) res.m_coef[i] = -res.m_coef[i];",
			"            return res;",
			"        }",
			"        static _Poly toPoints(const rfpoly &__a) { return __a.calcRange(__a.m_coef.size()); }",
			"        static rfpoly fromNormal(const _Poly &__a) {",
			"            _Poly xs(__a.size());",
			"            for (uint32_t i = 0; i < xs.size(); i++) xs[i] = -_Tp(i);",
			"            return fromPoints(__a.calc(xs));",
			"        }",
			"        static _Poly toNormal(const rfpoly &__a) {",
			"            auto dfs = [&](auto self, uint32_t start, uint32_t length) -> std::pair<_Poly, _Poly> {",
			"                std::pair<_Poly, _Poly> res;",
			"                if (length == 1) {",
			"                    res.first.push_back(__a.m_coef.at(start));",
			"                    res.second.emplace_back(start);",
			"                    res.second.emplace_back(1);",
			"                } else {",
			"                    auto [lf, lg] = self(self, start, length / 2);",
			"                    auto [rf, rg] = self(self, start + length / 2, length / 2);",
			"                    (res.first = rf * lg) += lf;",
			"                    res.second = _Poly::product(lg, rg, length);",
			"                    res.second[0]--;",
			"                    res.second.emplace_back(1);",
			"                }",
			"                return res;",
			"            };",
			"            return dfs(dfs, 0, std::__bit_ceil(__a.m_coef.size())).first;",
			"        }",
			"        rfpoly &operator*=(const rfpoly &__other) {",
			"            if (m_coef.empty()) return *this;",
			"            if (__other.m_coef.empty()) {",
			"                m_coef.clear();",
			"                return *this;",
			"            }",
			"            const uint32_t length = m_coef.size() + __other.m_coef.size() - 1;",
			"            _Poly ys(calcRange(length)), ys2(__other.calcRange(length));",
			"            for (uint32_t i = 0; i < length; i++) ys[i] *= ys2[i];",
			"            *this = fromPoints(ys);",
			"            return *this;",
			"        }",
			"        friend rfpoly operator*(const rfpoly &__a, const rfpoly &__b) {",
			"            rfpoly res(__a);",
			"            res *= __b;",
			"            return res;",
			"        }",
			"        _Poly calcRange(uint32_t __range) const {",
			"            prepareFactorial(__range);",
			"            _Poly a(m_coef);",
			"            for (uint32_t i = 1; i < a.size(); i += 2) a[i] = -a[i];",
			"            _Poly res(a * ex(__range));",
			"            res.sizeTo(__range);",
			"            for (uint32_t i = 0; i < __range; i++) res[i] *= s_factorial[i];",
			"            return res;",
			"        }",
			"        _Tp calc(_Tp __x) const {",
			"            _Tp cur(1), res(0);",
			"            for (uint32_t i = 0; i < m_coef.size(); i++) res += cur * m_coef[i], cur *= __x + _Tp(i);",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Rising Factorial Polynomial"
	},
	"static Euclidean":{
		"prefix": "EUC",
		"body": [
			"namespace OY {",
			"    template <uint32_t _P>",
			"    struct StaticEuclidean {",
			"        static constexpr uint32_t inv_2 = StaticModularInverse32<_P>::query_exgcd(2), inv_6 = StaticModularInverse32<_P>::query_exgcd(6);",
			"        struct _StaticEuclidean_ans {",
			"            uint32_t f, g, h;",
			"        };",
			"        static _StaticEuclidean_ans calc(uint32_t __a, uint32_t __b, uint32_t __c, uint32_t __n) {",
			"#define MUL(x, y) Modular32<_P>::multiply_64((x), (y))",
			"#define ADD(x, y) ({auto z=(x)+(y);if(z>=_P)z-=_P;z; })",
			"            uint32_t k1 = __a / __c, k2 = __b / __c;",
			"            __a -= k1 * __c;",
			"            __b -= k2 * __c;",
			"            const uint32_t m = (uint64_t(__a) * __n + __b) / __c, s1 = __n + 1, s2 = MUL(MUL(__n, __n + 1), inv_2), s3 = MUL(MUL(MUL(__n, __n + 1), __n * 2 + 1), inv_6);",
			"            uint32_t F = ADD(MUL(s2, k1), MUL(s1, k2));",
			"            uint32_t G = ADD(MUL(s3, k1), MUL(s2, k2));",
			"            uint32_t H = ADD(ADD(MUL(s3, MUL(k1, k1)), MUL(s1, MUL(k2, k2))), MUL(s2 * 2, MUL(k1, k2)));",
			"            if (__a && m) {",
			"                auto [f, g, h] = calc(__c, __c - __b - 1, __a, m - 1);",
			"                uint32_t df = ADD(MUL(__n, m), _P - f);",
			"                F = ADD(F, df);",
			"                uint32_t dg = ADD(MUL(m, s2), _P - MUL(f + h, inv_2));",
			"                G = ADD(G, dg);",
			"                uint32_t dh = ADD(ADD(ADD(ADD(MUL(__n, MUL(m, m + 1)), ADD(_P - g, _P - g)), ADD(_P - f, _P - f)), _P - df), ADD(MUL(2 * k1, dg), MUL(2 * k2, df)));",
			"                H = ADD(H, dh);",
			"            }",
			"#undef MUL",
			"#undef ADD",
			"            return {F, G, H};",
			"        }",
			"    };",
			"}",
		],
		"description": "static Euclidean"
	},
	"static matrix":{
		"prefix": "MATRIX",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, uint32_t _M, uint32_t _N>",
			"    struct StaticMatrix {",
			"        _Tp m_val[_M][_N];",
			"        static constexpr uint32_t row = _M;",
			"        static constexpr uint32_t column = _N;",
			"        static StaticMatrix<_Tp, _M, _N> raw(_Tp __a) {",
			"            StaticMatrix<_Tp, _M, _N> res;",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++) res[i][j] = __a;",
			"            return res;",
			"        }",
			"        static StaticMatrix<_Tp, _M, _M> unit() {",
			"            static_assert(_M == _N);",
			"            StaticMatrix<_Tp, _M, _M> res{};",
			"            for (uint32_t i = 0; i < _M; i++) res[i][i] = 1;",
			"            return res;",
			"        }",
			"        _Tp *operator[](uint32_t __i) { return m_val[__i]; }",
			"        const _Tp *operator[](uint32_t __i) const { return m_val[__i]; }",
			"        StaticMatrix<_Tp, _M, _N> &operator+=(_Tp __a) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++) m_val[i][j] += __a;",
			"            return *this;",
			"        }",
			"        StaticMatrix<_Tp, _M, _N> &operator-=(_Tp __a) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++) m_val[i][j] -= __a;",
			"            return *this;",
			"        }",
			"        StaticMatrix<_Tp, _M, _N> &operator*=(_Tp __a) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++) m_val[i][j] *= __a;",
			"            return *this;",
			"        }",
			"        StaticMatrix<_Tp, _M, _N> &operator+=(const StaticMatrix<_Tp, _M, _N> &__other) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++) m_val[i][j] += __other[i][j];",
			"            return *this;",
			"        }",
			"        StaticMatrix<_Tp, _M, _N> &operator-=(const StaticMatrix<_Tp, _M, _N> &__other) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++) m_val[i][j] -= __other[i][j];",
			"            return *this;",
			"        }",
			"        StaticMatrix<_Tp, _M, _M> pow(uint64_t __n) const {",
			"            static_assert(_M == _N);",
			"            StaticMatrix<_Tp, _M, _M> res = unit(), a = *this;",
			"            while (__n) {",
			"                if (__n & 1) res = res * a;",
			"                a = a * a;",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Fp>",
			"        friend StaticMatrix<_Tp, _M, _N> operator+(const StaticMatrix<_Tp, _M, _N> &__a, const _Fp &__b) { return StaticMatrix<_Tp, _M, _N>(__a) += __b; }",
			"        template <typename _Fp>",
			"        friend StaticMatrix<_Tp, _M, _N> operator-(const StaticMatrix<_Tp, _M, _N> &__a, const _Fp &__b) { return StaticMatrix<_Tp, _M, _N>(__a) -= __b; }",
			"        friend StaticMatrix<_Tp, _M, _N> operator*(const StaticMatrix<_Tp, _M, _N> &__a, const _Tp &__b) { return StaticMatrix<_Tp, _M, _N>(__a) *= __b; }",
			"        template <uint32_t _L>",
			"        friend StaticMatrix<_Tp, _M, _L> operator*(const StaticMatrix<_Tp, _M, _N> &__a, const StaticMatrix<_Tp, _N, _L> &__b) {",
			"            StaticMatrix<_Tp, _M, _L> res{};",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++) {",
			"                    _Tp a = __a[i][j];",
			"                    for (uint32_t k = 0; k < _L; k++) res[i][k] += a * __b[j][k];",
			"                }",
			"            return res;",
			"        }",
			"        friend bool operator==(const StaticMatrix<_Tp, _M, _N> &__a, const StaticMatrix<_Tp, _M, _N> &__b) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++)",
			"                    if (__a[i][j] != __b[i][j]) return false;",
			"            return true;",
			"        }",
			"        friend bool operator!=(const StaticMatrix<_Tp, _M, _N> &__a, const StaticMatrix<_Tp, _M, _N> &__b) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++)",
			"                    if (__a[i][j] != __b[i][j]) return true;",
			"            return false;",
			"        }",
			"    };",
			"};",
		],
		"description": "static matrix"
	},
	"static modint":{
		"prefix": "MOD",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P, bool _IsPrime = false>",
			"    struct StaticModInt {",
			"        using mint = StaticModInt<_ModType, _P, _IsPrime>;",
			"        _ModType m_val;",
			"        static_assert(_P > 1 && _P < 1ull << 63);",
			"        constexpr StaticModInt() : m_val(0) {}",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp>, bool> = true>",
			"        constexpr StaticModInt(_Tp __val) : m_val(0) {",
			"            int64_t x = int64_t(__val) % int64_t(mod());",
			"            if (x < 0) x += mod();",
			"            m_val = x;",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp>, bool> = true>",
			"        constexpr StaticModInt(_Tp __val) : m_val(__val % mod()) {}",
			"        static constexpr mint raw(_ModType __val) {",
			"            mint res;",
			"            res.m_val = __val;",
			"            return res;",
			"        }",
			"        static constexpr _ModType mod() { return _P; }",
			"        constexpr _ModType val() const { return m_val; }",
			"        constexpr mint pow(uint64_t __n) const { return Modular<_ModType, _P>::pow(m_val, __n); }",
			"        constexpr mint inv() const {",
			"            if constexpr (_IsPrime)",
			"                return inv_Fermat();",
			"            else",
			"                return inv_exgcd();",
			"        }",
			"        constexpr mint inv_exgcd() const {",
			"            _ModType x = mod(), y = m_val, m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                std::swap(x, y);",
			"                std::swap(m0, m1);",
			"            }",
			"            if (m0 >= mod()) m0 += mod() / x;",
			"            return raw(m0);",
			"        }",
			"        constexpr mint inv_Fermat() const { return pow(mod() - 2); }",
			"        constexpr mint &operator++() {",
			"            if (++m_val == mod()) m_val = 0;",
			"            return *this;",
			"        }",
			"        constexpr mint &operator--() {",
			"            if (m_val == 0) m_val = mod();",
			"            m_val--;",
			"            return *this;",
			"        }",
			"        constexpr mint operator++(int) {",
			"            mint old(*this);",
			"            ++*this;",
			"            return old;",
			"        }",
			"        constexpr mint operator--(int) {",
			"            mint old(*this);",
			"            --*this;",
			"            return old;",
			"        }",
			"        constexpr mint &operator+=(const mint &__other) {",
			"            m_val = Modular<_ModType, _P>::plus(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator-=(const mint &__other) {",
			"            m_val = Modular<_ModType, _P>::minus(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator*=(const mint &__other) {",
			"            m_val = Modular<_ModType, _P>::multiply(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator/=(const mint &__other) { return *this *= __other.inv(); }",
			"        constexpr mint operator+() const { return *this; }",
			"        constexpr mint operator-() const { return raw(m_val ? mod() - m_val : 0); }",
			"        constexpr bool operator==(const mint &__other) const { return m_val == __other.m_val; }",
			"        constexpr bool operator!=(const mint &__other) const { return m_val != __other.m_val; }",
			"        constexpr bool operator<(const mint &__other) const { return m_val < __other.m_val; }",
			"        constexpr bool operator>(const mint &__other) const { return m_val > __other.m_val; }",
			"        constexpr bool operator<=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        constexpr bool operator>=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        template <typename _Tp>",
			"        constexpr explicit operator _Tp() const { return _Tp(m_val); }",
			"        constexpr friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }",
			"        constexpr friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }",
			"        constexpr friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }",
			"        constexpr friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, mint &self) { return is >> self.m_val; }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const mint &self) { return os << self.m_val; }",
			"    };",
			"    template <uint32_t _P, bool _IsPrime>",
			"    using StaticModInt32 = StaticModInt<uint32_t, _P, _IsPrime>;",
			"    template <uint64_t _P, bool _IsPrime>",
			"    using StaticModInt64 = StaticModInt<uint64_t, _P, _IsPrime>;",
			"}",
		],
		"description": "static modint"
	},
	"static montgomery modint":{
		"prefix": "MG",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P, bool _IsPrime = false>",
			"    struct StaticMontgomeryModInt {",
			"        using mint = StaticMontgomeryModInt<_ModType, _P, _IsPrime>;",
			"        using _FastType = typename Montgomery<_ModType>::_FastType;",
			"        using _LongType = typename Montgomery<_ModType>::_LongType;",
			"        static constexpr Montgomery<_ModType> mg = Montgomery<_ModType>(_P);",
			"        _FastType m_val;",
			"        static_assert(_P % 2 == 1 && _P > 1 && _P < _MontgomeryTag<_ModType>::limit);",
			"        constexpr StaticMontgomeryModInt() = default;",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp>, bool> = true>",
			"        constexpr StaticMontgomeryModInt(_Tp __val) : m_val(0) {",
			"            int64_t x = int64_t(__val) % int64_t(mod());",
			"            if (x < 0) x += mod();",
			"            m_val = mg.raw_init(x);",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp>> * = nullptr>",
			"        constexpr StaticMontgomeryModInt(_Tp __val) : m_val(mg.raw_init(__val % mod())) {}",
			"        static constexpr mint raw(_FastType __val) {",
			"            mint res;",
			"            res.m_val = __val;",
			"            return res;",
			"        }",
			"        static constexpr _ModType mod() { return _P; }",
			"        constexpr _ModType val() const { return mg.reduce(m_val); }",
			"        constexpr mint pow(uint64_t __n) const { return raw(mg.pow(m_val, __n)); }",
			"        constexpr mint inv() const {",
			"            if constexpr (_IsPrime)",
			"                return inv_Fermat();",
			"            else",
			"                return inv_exgcd();",
			"        }",
			"        constexpr mint inv_exgcd() const {",
			"            _ModType x = mod(), y = val(), m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                std::swap(x, y);",
			"                std::swap(m0, m1);",
			"            }",
			"            if (m0 >= mod()) m0 += mod() / x;",
			"            return m0;",
			"        }",
			"        constexpr mint inv_Fermat() const { return pow(mod() - 2); }",
			"        constexpr mint &operator++() {",
			"            (*this) += raw(mg.raw_init(1));",
			"            return *this;",
			"        }",
			"        constexpr mint &operator--() {",
			"            (*this) -= raw(mg.raw_init(1));",
			"            return *this;",
			"        }",
			"        constexpr mint operator++(int) {",
			"            mint old(*this);",
			"            ++*this;",
			"            return old;",
			"        }",
			"        constexpr mint operator--(int) {",
			"            mint old(*this);",
			"            --*this;",
			"            return old;",
			"        }",
			"        constexpr mint &operator+=(const mint &__other) {",
			"            m_val = mg.plus(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator-=(const mint &__other) { return (*this) += -__other; }",
			"        constexpr mint &operator*=(const mint &__other) {",
			"            m_val = mg.multiply(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        constexpr mint &operator/=(const mint &__other) { return *this *= __other.inv(); }",
			"        constexpr mint operator+() const { return *this; }",
			"        constexpr mint operator-() const { return raw(m_val ? mod() - m_val : 0); }",
			"        constexpr bool operator==(const mint &__other) const { return m_val == __other.m_val; }",
			"        constexpr bool operator!=(const mint &__other) const { return m_val != __other.m_val; }",
			"        constexpr bool operator<(const mint &__other) const { return m_val < __other.m_val; }",
			"        constexpr bool operator>(const mint &__other) const { return m_val > __other.m_val; }",
			"        constexpr bool operator<=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        constexpr bool operator>=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        template <typename _Tp>",
			"        constexpr explicit operator _Tp() const { return _Tp(mg.reduce(m_val)); }",
			"        constexpr friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }",
			"        constexpr friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }",
			"        constexpr friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }",
			"        constexpr friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, mint &self) {",
			"            _ModType x;",
			"            is >> x;",
			"            self = mint(x);",
			"            return is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const mint &self) { return os << self.val(); }",
			"    };",
			"    template <uint32_t _P, bool _IsPrime>",
			"    using StaticMontgomeryModInt32 = StaticMontgomeryModInt<uint32_t, _P, _IsPrime>;",
			"    template <uint64_t _P, bool _IsPrime>",
			"    using StaticMontgomeryModInt64 = StaticMontgomeryModInt<uint64_t, _P, _IsPrime>;",
			"}",
		],
		"description": "static montgomery modint"
	},
	"Stirling":{
		"prefix": "STIRLING",
		"body": [
			"namespace OY {",
			"    template <typename _Poly>",
			"    struct StirlingNumber {",
			"        using _Tp = typename _Poly::value_type;",
			"        std::vector<bool> m_isPrime;",
			"        std::vector<uint32_t> m_smallestFactor;",
			"        std::vector<_Tp> m_factorial, m_factorialInv;",
			"        StirlingNumber(uint32_t __n) : m_isPrime(__n + 1, true), m_smallestFactor(__n + 1), m_factorial(__n + 1, _Tp(1)), m_factorialInv(__n + 1) {",
			"            m_isPrime[0] = m_isPrime[1] = false;",
			"            m_smallestFactor[1] = 1;",
			"            m_smallestFactor[2] = 2;",
			"            const uint32_t sqrt = std::sqrt(__n);",
			"            for (uint32_t i = 3; i <= sqrt; i += 2)",
			"                if (m_isPrime[i]) {",
			"                    m_smallestFactor[i] = i;",
			"                    for (uint32_t j = i * i, k = i; j <= __n; j += i * 2, k += 2)",
			"                        if (m_isPrime[j]) {",
			"                            m_isPrime[j] = false;",
			"                            m_smallestFactor[j] = i;",
			"                        }",
			"                }",
			"            for (uint32_t i = sqrt + sqrt % 2 + 1; i <= __n; i += 2)",
			"                if (m_isPrime[i]) m_smallestFactor[i] = i;",
			"            for (uint32_t i = 1; i <= __n; i++) m_factorial[i] = m_factorial[i - 1] * _Tp(i);",
			"            m_factorialInv.back() = m_factorial.back().inv();",
			"            for (uint32_t i = __n - 1; ~i; i--) m_factorialInv[i] = m_factorialInv[i + 1] * _Tp(i + 1);",
			"        }",
			"        std::vector<_Poly> getFirstStirlingTable(uint32_t __n) const {",
			"            std::vector<_Poly> res(__n + 1);",
			"            for (uint32_t i = 0; i <= __n; i++) {",
			"                res[i].reserve(i + 1);",
			"                for (uint32_t j = 0; j < i; j++) res[i].push_back(j ? res[i - 1][j - 1] + _Tp(i - 1) * res[i - 1][j] : _Tp(0));",
			"                res[i].emplace_back(1);",
			"            }",
			"            return res;",
			"        }",
			"        std::vector<_Poly> getSecondStirlingTable(uint32_t __n) const {",
			"            std::vector<_Poly> res(__n + 1);",
			"            for (uint32_t i = 0; i <= __n; i++) {",
			"                res[i].reserve(i + 1);",
			"                for (uint32_t j = 0; j < i; j++) res[i].push_back(j ? res[i - 1][j - 1] + j * res[i - 1][j] : _Tp(0));",
			"                res[i].emplace_back(1);",
			"            }",
			"            return res;",
			"        }",
			"        _Poly getFirstStirlingRow(uint32_t __row) const {",
			"            if (!__row) return _Poly{_Tp(0)};",
			"            _Poly res{_Tp(0), _Tp(1)};",
			"            for (uint32_t i = std::__countr_zero(std::__bit_floor(__row)) - 1; ~i; i--) {",
			"                _Poly a(res), b(res.size());",
			"                for (uint32_t j = 0; j < b.size(); j++) b[j] = j ? b[j - 1] * _Tp(a.size() - 1) : 1;",
			"                for (uint32_t j = 0; j < b.size(); j++) b[j] *= m_factorialInv[j];",
			"                for (uint32_t j = 0; j < a.size(); j++) a[j] *= m_factorial[j];",
			"                (a.reverse() *= b).sizeTo(b.size()).reverse();",
			"                for (uint32_t j = 0; j < a.size(); j++) a[j] *= m_factorialInv[j];",
			"                if (__row >> i & 1)",
			"                    for (uint32_t j = a.sizeTo(a.size() + 1).size() - 1, k = b.size() * 2 - 2; ~j; j--) (a[j] *= k) += a.at(j - 1);",
			"                res *= a;",
			"            }",
			"            return res;",
			"        }",
			"        _Poly getSecondStirlingRow(uint32_t __row) const {",
			"            _Tp pow[__row + 1];",
			"            pow[0] = _Tp(0);",
			"            pow[1] = _Tp(1);",
			"            for (uint32_t i = 2; i <= __row; i++)",
			"                if (m_isPrime[i])",
			"                    pow[i] = _Tp(i).pow(__row);",
			"                else {",
			"                    uint32_t a = m_smallestFactor[i], b = i / a;",
			"                    pow[i] = pow[a] * pow[b];",
			"                }",
			"            _Poly a(__row + 1), b(__row + 1);",
			"            for (uint32_t i = 0; i <= __row; i++) {",
			"                a[i] = pow[i] * m_factorialInv[i];",
			"                b[i] = i % 2 ? -m_factorialInv[i] : m_factorialInv[i];",
			"            }",
			"            (a *= b).sizeTo(__row + 1);",
			"            return a;",
			"        }",
			"        _Poly getFirstStirlingCol(uint32_t __col, uint32_t __maxRow) const {",
			"            if (!__col) {",
			"                _Poly res(__maxRow + 1);",
			"                res[0] = _Tp(1);",
			"                return res;",
			"            }",
			"            if (__col == 1) {",
			"                _Poly res(__maxRow + 1);",
			"                res[__col] = _Tp(1);",
			"                for (uint32_t i = __col + 1; i < res.size(); i++) res[i] = res[i - 1] * _Tp(i - __col);",
			"                return res;",
			"            }",
			"            if (__maxRow < __col) return _Poly(__maxRow + 1);",
			"            _Poly a(__maxRow);",
			"            for (uint32_t i = 0; i < __maxRow; i++) a[i] = m_factorial[i] * m_factorialInv[i + 1];",
			"            _Poly b(_Poly::_simplePow(a, _Tp(__col))), res(__maxRow + 1);",
			"            for (uint32_t i = __col; i <= __maxRow; i++) res[i] = b[i - __col] * m_factorial[i] * m_factorialInv[__col];",
			"            return res;",
			"        }",
			"        _Poly getSecondStirlingCol(uint32_t __col, uint32_t __maxRow) const {",
			"            if (!__col) {",
			"                _Poly res(__maxRow + 1);",
			"                res[0] = _Tp(1);",
			"                return res;",
			"            }",
			"            if (__col == 1) return _Poly(__maxRow + 1, _Tp(1));",
			"            if (__maxRow < __col) return _Poly(__maxRow + 1);",
			"            _Poly a(m_factorialInv.begin() + 1, m_factorialInv.begin() + (__maxRow - __col + 2)), b(_Poly::_simplePow(a, _Tp(__col))), res(__maxRow + 1);",
			"            for (uint32_t i = __col; i <= __maxRow; i++) res[i] = b[i - __col] * m_factorial[i] * m_factorialInv[__col];",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Stirling number"
	},

	"ac automaton":{
		"prefix": "AC",
		"body": [
			"namespace OY {",
			"    struct ACDefaultInfo {};",
			"    template <typename _Mapping = TrieLowerMapping, typename _Info = ACDefaultInfo, uint32_t _PoolSize = 1000000>",
			"    struct ACAutomaton {",
			"        struct _ACInfo : _Info {",
			"            typename Trie<_Mapping, _ACInfo, _PoolSize>::TrieNode m_fail;",
			"        };",
			"        static inline Trie<_Mapping, _ACInfo, _PoolSize> s_trie;",
			"        using TrieNode = typename Trie<_Mapping, _ACInfo, _PoolSize>::TrieNode;",
			"        static void Init() {",
			"            if (TrieNode(0).child(0)) s_trie = Trie<_Mapping, _ACInfo, _PoolSize>();",
			"            for (uint32_t i = 0; i < _Mapping::range(); i++) TrieNode(0).child(i) = s_trie.m_root;",
			"        }",
			"        template <typename _Iterator>",
			"        static TrieNode Insert(_Iterator __first, _Iterator __last) { return s_trie.insert(__first, __last); }",
			"        static void Build() {",
			"            static TrieNode queue[_PoolSize];",
			"            uint32_t head = 0, tail = 0;",
			"            queue[tail++] = s_trie.m_root;",
			"            while (head < tail) {",
			"                TrieNode cur = queue[head++];",
			"                for (uint32_t i = 0; i < _Mapping::range(); i++)",
			"                    if (TrieNode &child = cur.child(i)) {",
			"                        child->m_fail = cur->m_fail.child(i);",
			"                        queue[tail++] = child;",
			"                    } else",
			"                        child = cur->m_fail.child(i);",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        static auto Iteration(_Iterator __first, _Iterator __last) {",
			"            struct _Iterable {",
			"                _Iterator first, last;",
			"                struct iter {",
			"                    _Iterator elem_iter;",
			"                    mutable TrieNode node;",
			"                    TrieNode operator*() const { return node = node.child(s_trie.s_map(*elem_iter)); }",
			"                    bool operator!=(const iter &other) const { return elem_iter != other.elem_iter; }",
			"                    iter &operator++() {",
			"                        ++elem_iter;",
			"                        return *this;",
			"                    }",
			"                };",
			"                iter begin() const { return iter{first, s_trie.m_root}; }",
			"                iter end() const { return iter{last, s_trie.m_root}; }",
			"            };",
			"            return _Iterable{__first, __last};",
			"        }",
			"    };",
			"};",
		],
		"description": "ac automaton"
	},
	"Duval":{
		"prefix": "DV",
		"body": [
			"namespace OY {",
			"    template <typename _Iterator>",
			"    std::vector<uint32_t> Duval(_Iterator first, _Iterator last) {",
			"        std::vector<uint32_t> res;",
			"        for (uint32_t i = 0, j = 0, k = 1, length = last - first; i < length;) {",
			"            for (j = i, k = i + 1; k < length; k++)",
			"                if (const auto &a = *(first + j), b = *(first + k); a < b)",
			"                    j = i;",
			"                else if (a == b)",
			"                    j++;",
			"                else",
			"                    break;",
			"            while (i <= j) res.push_back(i), i += k - j;",
			"        }",
			"        return res;",
			"    }",
			"}",
		],
		"description": "Duval Lyndon"
	},
	"dynamic sequence hasher":{
		"prefix": "HASH",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    struct DynamicSequenceHasher {",
			"        struct _DefaultMap {",
			"            template <typename _Tp>",
			"            _Tp operator()(_Tp __a) const { return __a; }",
			"        };",
			"        struct _HashResult {",
			"            const DynamicSequenceHasher<_ModType> &hasher;",
			"            std::vector<_ModType> presum;",
			"            _ModType query(uint32_t left, uint32_t right) const {",
			"                _ModType val = presum[right + 1] + hasher.m_P - hasher.m_brt.multiply(presum[left], hasher.m_units[right - left + 1]);",
			"                return val >= hasher.m_P ? val - hasher.m_P : val;",
			"            }",
			"            _ModType queryPrefix(uint32_t i) const { return presum[i + 1]; }",
			"            _ModType querySuffix(uint32_t i) const {",
			"                _ModType val = presum.back() + hasher.m_P - hasher.m_brt.multiply(presum[i], hasher.m_units[presum.size() - 1 - i]);",
			"                return val >= hasher.m_P ? val - hasher.m_P : val;",
			"            }",
			"            _ModType queryAll() const { return presum.back(); }",
			"        };",
			"        _ModType m_base;",
			"        _ModType m_P;",
			"        Barrett<_ModType> m_brt;",
			"        std::vector<_ModType> m_units;",
			"        DynamicSequenceHasher(uint32_t __maxLength, _ModType __base = 100003, _ModType __P = 1000000007) : m_base(__base), m_P(__P), m_brt(__P) {",
			"            m_units.reserve(__maxLength + 1);",
			"            m_units.push_back(1);",
			"            for (uint32_t i = 1; i <= __maxLength; i++) m_units.push_back(m_brt.multiply(m_units.back(), m_base));",
			"        }",
			"        template <typename _Iterator, typename _Mapping = _DefaultMap>",
			"        _HashResult hash(_Iterator __first, _Iterator __last, _Mapping __map = _Mapping()) const {",
			"            std::vector<_ModType> presum;",
			"            presum.reserve(__last - __first + 1);",
			"            presum.push_back(0);",
			"            for (auto it = __first; it != __last; ++it) {",
			"                _ModType val = m_brt.multiply(presum.back(), m_base) + __map(*it);",
			"                presum.push_back(val >= m_P ? val - m_P : val);",
			"            }",
			"            return _HashResult{*this, presum};",
			"        }",
			"    };",
			"    using DynamicSequenceHasher32 = DynamicSequenceHasher<uint32_t>;",
			"    using DynamicSequenceHasher64 = DynamicSequenceHasher<uint64_t>;",
			"}",
		],
		"description": "dynamic sequence hasher"
	},
	"fast sequence automaton":{
		"prefix": "SEQ",
		"body": [
			"namespace OY {",
			"    template <typename _Mapping = TrieLowerMapping, uint32_t _PoolSize = 1000000>",
			"    struct FastSequenceAutomaton {",
			"        static inline uint32_t s_next[_PoolSize][_Mapping::range()];",
			"        static inline uint32_t s_length;",
			"        static inline _Mapping s_map = _Mapping();",
			"        template <typename _Iterator>",
			"        static void Build(_Iterator __first, _Iterator __last) {",
			"            s_length = __last - __first;",
			"            std::fill(s_next[s_length - 1], s_next[s_length], s_length);",
			"            s_next[s_length - 1][s_map(__first[s_length - 1])]--;",
			"            for (uint32_t i = s_length - 2; ~i; i--) {",
			"                std::copy(s_next[i + 1], s_next[i + 2], s_next[i]);",
			"                s_next[i][s_map(__first[i])] = i;",
			"            }",
			"        }",
			"        template <typename _Tp>",
			"        static uint32_t Next(uint32_t __current, _Tp __c) { return s_next[__current][s_map(__c)]; }",
			"        template <typename _Iterator>",
			"        static bool Has(_Iterator __first, _Iterator __last) {",
			"            uint32_t current = 0;",
			"            for (auto it = __first; it != __last; ++it)",
			"                if (current = Next(current, *it) + 1; current > s_length) return false;",
			"            return true;",
			"        }",
			"    };",
			"}",
		],
		"description": "fast sequence automaton"
	},
	"kmp":{
		"prefix": "KMP",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    class KMP {",
			"        std::basic_string<_Tp> m_pattern;",
			"        std::vector<int> m_pi;",
			"",
			"    public:",
			"        template <typename _Iterator>",
			"        KMP(_Iterator __first, _Iterator __last) {",
			"            m_pattern.assign(__first, __last);",
			"            m_pi.reserve(__last - __first);",
			"            m_pi.push_back(0);",
			"            int cursor = -1;",
			"            for (auto it = __first + 1; it != __last; ++it) {",
			"                cursor = adjust(cursor, *it);",
			"                m_pi.push_back(cursor + 1);",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        int search(_Iterator __first, _Iterator __last) const {",
			"            if (m_pi.empty()) return 0;",
			"            int cursor = -1;",
			"            for (auto it = __first; it != __last; ++it) {",
			"                cursor = adjust(cursor, *it);",
			"                if (cursor == m_pi.size() - 1) return (it - __first) - cursor;",
			"            }",
			"            return -1;",
			"        }",
			"        int queryPi(int __i) const { return m_pi[__i]; }",
			"        int adjust(int __cursor, _Tp __c) const {",
			"            __cursor++;",
			"            while (__cursor && (__cursor == m_pattern.size() || m_pattern[__cursor] != __c)) __cursor = m_pi[__cursor - 1];",
			"            return m_pattern[__cursor] == __c ? __cursor : __cursor - 1;",
			"        }",
			"    };",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    KMP(_Iterator, _Iterator) -> KMP<_Tp>;",
			"}",
		],
		"description": "kmp"
	},
	"longest common prefix:hash":{
		"prefix": "LCP",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = char, typename _Hasher = MontgomerySequenceHasher, uint32_t _MAXN = 500000>",
			"    struct LongestCommonPrefix_hash {",
			"        static inline _Hasher s_hasher = _Hasher(_MAXN);",
			"        uint32_t m_length;",
			"        std::basic_string<_Tp> m_text;",
			"        typename _Hasher::_HashResult m_hashResult;",
			"        template <typename _Iterator, typename _Mapping = _Hasher::_DefaultMap>",
			"        LongestCommonPrefix_hash(_Iterator __first, _Iterator __last, _Mapping __map = _Mapping()) : m_length(__last - __first), m_text(__first, __last), m_hashResult(s_hasher.hash(__first, __last, __map)) {}",
			"        uint32_t lcp(uint32_t __a, uint32_t __b, uint32_t __limit) const {",
			"            uint32_t low = 0, high = __limit;",
			"            while (low < high) {",
			"                uint32_t mid = (low + high + 1) / 2;",
			"                if (m_hashResult.query(__a, __a + mid - 1) == m_hashResult.query(__b, __b + mid - 1))",
			"                    low = mid;",
			"                else",
			"                    high = mid - 1;",
			"            }",
			"            return low;",
			"        }",
			"        uint32_t lcp(uint32_t __a, uint32_t __b) const {",
			"            if (__a == __b) return m_length - __a;",
			"            return lcp(__a, __b, m_length - std::max(__a, __b));",
			"        }",
			"        int compare(uint32_t __l1, uint32_t __r1, uint32_t __l2, uint32_t __r2) const {",
			"            uint32_t len1 = __r1 - __l1 + 1, len2 = __r2 - __l2 + 1, len = lcp(__l1, __l2, std::min(len1, len2));",
			"            if (len == len1)",
			"                return len == len2 ? 0 : -1;",
			"            else if (len == len2)",
			"                return 1;",
			"            else",
			"                return m_text[__l1 + len] < m_text[__l2 + len] ? -1 : 1;",
			"        }",
			"    };",
			"}",
		],
		"description": "longest common prefix:hash"
	},
	"longest common prefix:sa":{
		"prefix": "LCP",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = char, typename _SASolver = GetSuffixArray, template <typename...> typename _STSolver = STTable>",
			"    struct LongestCommonPrefix_sa {",
			"        SuffixArray<_Tp, false, _SASolver> m_sa;",
			"        _STSolver<uint32_t, const uint32_t &(*)(const uint32_t &, const uint32_t &)> m_st;",
			"        template <typename _Iterator>",
			"        LongestCommonPrefix_sa(_Iterator __first, _Iterator __last, uint32_t __alpha = 128) : m_sa(__first, __last, __alpha), m_st(m_sa.m_height.begin(), m_sa.m_height.end(), std::min<uint32_t>) {}",
			"        uint32_t lcp(uint32_t __a, uint32_t __b, uint32_t __limit) const {",
			"            if (__a == __b) return m_sa.m_length - __a;",
			"            uint32_t rank1 = m_sa.m_rank[__a], rank2 = m_sa.m_rank[__b];",
			"            if (rank1 > rank2) std::swap(rank1, rank2);",
			"            return std::min<uint32_t>(__limit, m_st.query(rank1 + 1, rank2));",
			"        }",
			"        uint32_t lcp(uint32_t __a, uint32_t __b) const {",
			"            if (__a == __b) return m_sa.m_length - __a;",
			"            return lcp(__a, __b, -1);",
			"        }",
			"        int compare(uint32_t __l1, uint32_t __r1, uint32_t __l2, uint32_t __r2) const {",
			"            if (__l1 == __l2) return 0;",
			"            if (uint32_t rank1 = m_sa.m_rank[__l1], rank2 = m_sa.m_rank[__l2], len1 = __r1 - __l1 + 1, len2 = __r2 - __l2 + 1; rank1 < rank2) {",
			"                uint32_t len = m_st.query(rank1 + 1, rank2);",
			"                if (len < len2 || len1 < len2)",
			"                    return -1;",
			"                else",
			"                    return len1 > len2;",
			"            } else {",
			"                uint32_t len = m_st.query(rank2 + 1, rank1);",
			"                if (len < len1 || len2 < len1)",
			"                    return 1;",
			"                else",
			"                    return len1 < len2 ? -1 : 0;",
			"            }",
			"        }",
			"    };",
			"}",
		],
		"description": "longest common prefix:sa"
	},
	"longest common prefix:sam":{
		"prefix": "LCP",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = char, uint32_t _MAXN = 1000000, typename _Mapping = TrieLowerMapping, template <typename...> typename _Solver = HeavyLightDecompositionLCA>",
			"    struct LongestCommonPrefix_sam {",
			"        using SAM = SuffixAutomaton<_Mapping, SAMDefaultInfo, _MAXN * 2>;",
			"        using TrieNode = SAM::TrieNode;",
			"        uint32_t m_length, m_rootIndex;",
			"        std::vector<uint32_t> m_nodelength, m_pos;",
			"        std::basic_string<_Tp> m_text;",
			"        Tree<_MAXN, bool> m_tree;",
			"        _Solver<Tree<_MAXN, bool>> m_lca;",
			"        template <typename _Iterator>",
			"        Tree<_MAXN, bool> _initTree(_Iterator __first, _Iterator __last) {",
			"            m_pos.resize(m_length = __last - __first);",
			"            SAM::Init();",
			"            m_rootIndex = SAM::s_trie.m_root.index;",
			"            for (uint32_t i = m_length - 1; ~i; i--) m_pos[i] = SAM::Insert(*(__first + i)).index - m_rootIndex;",
			"            m_nodelength.reserve(SAM::s_trie.s_cursor - m_rootIndex);",
			"            Tree<_MAXN, bool> tree(SAM::s_trie.s_cursor - m_rootIndex);",
			"            for (uint32_t i = m_rootIndex; i < SAM::s_trie.s_cursor; i++) {",
			"                m_nodelength.push_back(TrieNode(i)->m_length);",
			"                if (uint32_t p = TrieNode(i).parent().index) tree.addEdge(i - m_rootIndex, p - m_rootIndex);",
			"            }",
			"            tree.prepare();",
			"            tree.setRoot(0);",
			"            return tree;",
			"        }",
			"        template <typename _Iterator>",
			"        LongestCommonPrefix_sam(_Iterator __first, _Iterator __last) : m_tree(_initTree(__first, __last)), m_lca(m_tree), m_text(__first, __last) {}",
			"        uint32_t lcp(uint32_t __a, uint32_t __b, uint32_t __limit) const { return std::min(__limit, m_nodelength[m_lca.calc(m_pos[__a], m_pos[__b])]); }",
			"        uint32_t lcp(uint32_t __a, uint32_t __b) const { return m_nodelength[m_lca.calc(m_pos[__a], m_pos[__b])]; }",
			"        int compare(uint32_t __l1, uint32_t __r1, uint32_t __l2, uint32_t __r2) const {",
			"            uint32_t len1 = __r1 - __l1 + 1, len2 = __r2 - __l2 + 1, len = lcp(__l1, __l2, std::min(len1, len2));",
			"            if (len == len1)",
			"                return len == len2 ? 0 : -1;",
			"            else if (len == len2)",
			"                return 1;",
			"            else",
			"                return m_text[__l1 + len] < m_text[__l2 + len] ? -1 : 1;",
			"        }",
			"    };",
			"}",
		],
		"description": "longest common prefix:sam"
	},
	"manacher":{
		"prefix": "MANACHER",
		"body": [
			"namespace OY {",
			"    struct Manacher {",
			"        int m_length;",
			"        std::vector<int> m_oddArm;",
			"        std::vector<int> m_evenArm;",
			"        template <typename _Iterator>",
			"        Manacher(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_oddArm.reserve(m_length);",
			"            m_evenArm.reserve(m_length);",
			"            for (int l = -1, r = -1, i = 0; i < m_length; i++) {",
			"                int k = i <= r ? std::min(m_oddArm[l + r - i], r - i) + 1 : 1;",
			"                while (k <= i && k < m_length - i && __first[i - k] == __first[i + k]) k++;",
			"                m_oddArm.push_back(k - 1);",
			"                if (i + k - 1 > r) {",
			"                    l = i - k + 1;",
			"                    r = i + k - 1;",
			"                }",
			"            }",
			"            for (int l = 0, r = -1, i = 0; i < m_length; i++) {",
			"                int k = i <= r ? std::min(m_evenArm[l + r - i + 1], r - i + 1) + 1 : 1;",
			"                while (k <= i && k < m_length - i + 1 && __first[i - k] == __first[i + k - 1]) k++;",
			"                m_evenArm.push_back(k - 1);",
			"                if (i + k - 2 > r) {",
			"                    l = i - k + 1;",
			"                    r = i + k - 2;",
			"                }",
			"            }",
			"        }",
			"        bool query(int __left, int __right) const {",
			"            if ((__left ^ __right) & 1)",
			"                return m_evenArm[(__left + __right + 1) >> 1] > (__right - __left) >> 1;",
			"            else",
			"                return m_oddArm[(__left + __right) >> 1] >= (__right - __left) >> 1;",
			"        }",
			"    };",
			"}",
		],
		"description": "manacher"
	},
	"minimal sequence":{
		"prefix": "MINSEQ",
		"body": [
			"namespace OY {",
			"    template <typename _Iterator>",
			"    constexpr uint32_t MinimalSequence(_Iterator first, _Iterator last) {",
			"        const uint32_t length = last - first;",
			"        auto mod = [length](uint32_t a) -> uint32_t { return a >= length ? a - length : a; };",
			"        uint32_t i = 0, j = 1;",
			"        while (j < length) {",
			"            uint32_t same = 0;",
			"            while (same < length && first[mod(i + same)] == first[mod(j + same)]) same++;",
			"            if (same == length) break;",
			"            if (first[mod(i + same)] > first[mod(j + same)])",
			"                i += same + 1;",
			"            else",
			"                j += same + 1;",
			"            if (i == j)",
			"                j++;",
			"            else if (i > j)",
			"                std::swap(i, j);",
			"        }",
			"        return i;",
			"    }",
			"}",
		],
		"description": "minimal sequence"
	},
	"montogomery sequence hasher":{
		"prefix": "HASH",
		"body": [
			"namespace OY {",
			"    struct MontgomerySequenceHasher {",
			"        struct _DefaultMap {",
			"            template <typename _Tp>",
			"            _Tp operator()(_Tp __a) const { return __a; }",
			"        };",
			"        struct _HashResult {",
			"            const MontgomerySequenceHasher &hasher;",
			"            std::vector<uint64_t> presum;",
			"            uint64_t query(uint32_t left, uint32_t right) const {",
			"                uint64_t val = presum[right + 1] + hasher.m_P - hasher.m_mg.multiply(presum[left], hasher.m_units[right - left + 1]);",
			"                return hasher.m_mg.reduce(val >= hasher.m_P ? val - hasher.m_P : val);",
			"            }",
			"            uint64_t queryPrefix(uint32_t i) const { return hasher.m_mg.reduce(presum[i + 1]); }",
			"            uint64_t querySuffix(uint32_t i) const {",
			"                uint64_t val = presum.back() + hasher.m_P - hasher.m_mg.multiply(presum[i], hasher.m_units[presum.size() - 1 - i]);",
			"                return hasher.m_mg.reduce(val >= hasher.m_P ? val - hasher.m_P : val);",
			"            }",
			"            uint64_t queryAll() const { return hasher.m_mg.reduce(presum.back()); }",
			"        };",
			"        uint64_t m_base, m_P;",
			"        Montgomery64 m_mg;",
			"        std::vector<uint64_t> m_units;",
			"        MontgomerySequenceHasher(uint32_t __maxLength, uint64_t __base = 1000000007, uint64_t __P = 4000000000000000037) : m_P(__P), m_mg(__P) {",
			"            assert(__P % 2);",
			"            m_base = m_mg.raw_init(__base);",
			"            m_units.reserve(__maxLength + 1);",
			"            m_units.push_back(m_mg.raw_init(1));",
			"            for (uint32_t i = 1; i <= __maxLength; i++) m_units.push_back(m_mg.multiply(m_units.back(), m_base));",
			"        }",
			"        template <typename _Iterator, typename _Mapping = _DefaultMap>",
			"        _HashResult hash(_Iterator __first, _Iterator __last, _Mapping __map = _Mapping()) const {",
			"            std::vector<uint64_t> presum;",
			"            presum.reserve(__last - __first + 1);",
			"            presum.push_back(0);",
			"            for (auto it = __first; it != __last; ++it) {",
			"                uint64_t val = m_mg.multiply(presum.back(), m_base) + m_mg.raw_init(__map(*it));",
			"                presum.push_back(val >= m_P ? val - m_P : val);",
			"            }",
			"            return _HashResult{*this, presum};",
			"        }",
			"    };",
			"}",
		],
		"description": "montogomery sequence hasher"
	},
	"palindromic automaton":{
		"prefix": "PAM",
		"body": [
			"namespace OY {",
			"    struct PAMDefaultInfo {};",
			"    template <typename _Mapping = TrieLowerMapping, typename _Info = PAMDefaultInfo, uint32_t _PoolSize = 2000000>",
			"    struct PalindromicAutomaton {",
			"        struct _PAMInfo : _Info {",
			"            typename Trie<_Mapping, _PAMInfo, _PoolSize>::TrieNode m_fail;",
			"            uint32_t m_length;",
			"        };",
			"        using TrieNode = typename Trie<_Mapping, _PAMInfo, _PoolSize>::TrieNode;",
			"        static inline Trie<_Mapping, _PAMInfo, _PoolSize> s_trie;",
			"        static inline TrieNode s_evenRoot;",
			"        static inline TrieNode s_last;",
			"        static void Init() {",
			"            if (!~s_trie.m_root->m_length) s_trie = Trie<_Mapping, _PAMInfo, _PoolSize>();",
			"            s_trie.m_root->m_length = -1;",
			"            s_trie.m_root->m_fail = TrieNode(0);",
			"            s_evenRoot = TrieNode::newNode(0);",
			"            s_evenRoot->m_length = 0;",
			"            s_evenRoot->m_fail = s_trie.m_root;",
			"            s_last = s_trie.m_root;",
			"            TrieNode(0)->m_length = -2;",
			"            for (uint32_t i = 0; i < _Mapping::range(); i++) TrieNode(0).child(i) = s_evenRoot;",
			"        }",
			"        template <typename _Sequence>",
			"        static TrieNode Insert(_Sequence &__sequence, uint32_t __index) {",
			"            uint32_t i = s_trie.s_map(__sequence[__index]);",
			"            s_last = Next(__sequence, __index, s_last);",
			"            TrieNode &child = s_last.child(i);",
			"            if (!child) {",
			"                child = TrieNode::newNode(s_last);",
			"                child->m_length = s_last->m_length + 2;",
			"                child->m_fail = Next(__sequence, __index, s_last->m_fail).child(i);",
			"            }",
			"            return s_last = child;",
			"        }",
			"        template <typename _Sequence>",
			"        static TrieNode Next(_Sequence &__sequence, uint32_t __index, TrieNode __cur) {",
			"            if (!__cur) return __cur;",
			"            while (__index == __cur->m_length || __sequence[__index - __cur->m_length - 1] != __sequence[__index]) __cur = __cur->m_fail;",
			"            return __cur;",
			"        }",
			"    };",
			"}",
		],
		"description": "palindromic automaton"
	},
	"primitive repetition helper":{
		"prefix": "RUN",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = char, typename _SASolver = GetSuffixArray, template <typename...> typename _STSolver = STTable>",
			"    struct RepetitionHelper_sa {",
			"        struct _Run {",
			"            uint32_t left, right, length;",
			"            bool operator<(const _Run &_other) const {",
			"                if (left != _other.left)",
			"                    return left < _other.left;",
			"                else",
			"                    return right < _other.right;",
			"            }",
			"            bool operator==(const _Run &_other) const { return left == _other.left && right == _other.right; }",
			"        };",
			"        struct _PrimitiveRepetition {",
			"            uint32_t left, right;",
			"        };",
			"        uint32_t m_length;",
			"        std::basic_string<_Tp> m_text;",
			"        SuffixArray<_Tp, false, _SASolver> m_sa1, m_sa2;",
			"        _STSolver<uint32_t, const uint32_t &(*)(const uint32_t &, const uint32_t &)> m_st1, m_st2;",
			"        std::vector<_Run> m_runs;",
			"        template <typename _Iterator>",
			"        RepetitionHelper_sa(_Iterator __first, _Iterator __last, uint32_t __alpha = 128) : m_length(__last - __first), m_text(__first, __last), m_sa1(m_text.begin(), m_text.end(), __alpha), m_sa2(m_text.rbegin(), m_text.rend(), __alpha), m_st1(m_sa1.m_height.begin(), m_sa1.m_height.end(), std::min<uint32_t>), m_st2(m_sa2.m_height.begin(), m_sa2.m_height.end(), std::min<uint32_t>) {",
			"            std::vector<uint32_t> stack;",
			"            stack.reserve(m_length + 1);",
			"            stack[0] = m_length;",
			"            auto getLCP = [&](uint32_t a, uint32_t b) {",
			"                if (a == b) return m_length - a;",
			"                uint32_t rank1 = m_sa1.m_rank[a], rank2 = m_sa1.m_rank[b];",
			"                if (rank1 > rank2) std::swap(rank1, rank2);",
			"                return m_st1.query(rank1 + 1, rank2);",
			"            };",
			"            auto getLCS = [&](uint32_t a, uint32_t b) {",
			"                if (a == b) return m_length - a;",
			"                uint32_t rank1 = m_sa2.m_rank[a], rank2 = m_sa2.m_rank[b];",
			"                if (rank1 > rank2) std::swap(rank1, rank2);",
			"                return m_st2.query(rank1 + 1, rank2);",
			"            };",
			"            auto traverse = [&](bool reverse) {",
			"                auto bigger = [&](uint32_t l1, uint32_t r1, uint32_t l2, uint32_t r2) -> bool {",
			"                    if (reverse)",
			"                        if (uint32_t rank1 = m_sa1.m_rank[l1], rank2 = m_sa1.m_rank[l2], len1 = r1 - l1 + 1, len2 = r2 - l2 + 1; rank2 < rank1)",
			"                            return len1 > len2 && m_st1.query(rank2 + 1, rank1) >= len2;",
			"                        else",
			"                            return len1 > len2 || m_st1.query(rank1 + 1, rank2) < len1;",
			"                    else if (uint32_t rank1 = m_sa1.m_rank[l1], rank2 = m_sa1.m_rank[l2], len1 = r1 - l1 + 1, len2 = r2 - l2 + 1; rank1 < rank2)",
			"                        return len1 > len2 && m_st1.query(rank1 + 1, rank2) >= len2;",
			"                    else",
			"                        return len1 > len2 || m_st1.query(rank2 + 1, rank1) < len1;",
			"                };",
			"                for (uint32_t i = m_length - 1; ~i; i--) {",
			"                    while (stack.size() > 1 && bigger(stack.back(), stack[stack.size() - 2] - 1, i, stack.back() - 1)) stack.pop_back();",
			"                    if (stack.size() > 1)",
			"                        if (uint32_t j = stack.back(), lcs = getLCS(m_length - 1 - i, m_length - 1 - j); lcs && lcs <= j - i)",
			"                            if (uint32_t lcp = getLCP(i, j); lcs + lcp > j - i) m_runs.push_back({i - lcs + 1, j + lcp - 1, j - i});",
			"                    stack.push_back(i);",
			"                }",
			"            };",
			"            traverse(false);",
			"            stack.resize(1);",
			"            traverse(true);",
			"            std::sort(m_runs.begin(), m_runs.end());",
			"            m_runs.erase(std::unique(m_runs.begin(), m_runs.end()), m_runs.end());",
			"        }",
			"        std::vector<_PrimitiveRepetition> getPrimitiveRepetition() const {",
			"            std::vector<_PrimitiveRepetition> res;",
			"            uint32_t total = 0;",
			"            for (auto &[left, right, length] : m_runs) total += right - left - length * 2 + 2;",
			"            res.reserve(total);",
			"            for (auto &[left, right, length] : m_runs)",
			"                for (uint32_t i = left, iend = right - length * 2 + 1; i <= iend; i++) res.push_back({i, i + length * 2 - 1});",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "primitive repetion helper"
	},
	"sequence automaton":{
		"prefix": "SEQ",
		"body": [
			"namespace OY {",
			"    class SequenceAutomaton {",
			"        uint32_t m_length;",
			"        uint32_t m_alpha;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<uint32_t> m_indexes;",
			"",
			"    public:",
			"        template <typename _Iterator>",
			"        SequenceAutomaton(_Iterator __first, _Iterator __last, uint32_t __alpha) : m_length(__last - __first), m_alpha(__alpha) {",
			"            m_starts.resize(m_alpha + 1, 0);",
			"            for (auto it = __first; it != __last; ++it) m_starts[*it + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_indexes.resize(m_starts.back());",
			"            uint32_t cursor[m_alpha];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_alpha, cursor);",
			"            for (uint32_t i = 0; i < m_length; i++) m_indexes[cursor[__first[i]]++] = i;",
			"        }",
			"        uint32_t next(uint32_t __current, uint32_t __c) const {",
			"            uint32_t begin = m_starts[__c], end = m_starts[__c + 1];",
			"            uint32_t it = std::lower_bound(m_indexes.begin() + begin, m_indexes.begin() + end, __current) - m_indexes.begin();",
			"            return it != end ? m_indexes[it] : m_length;",
			"        }",
			"        template <typename _Iterator>",
			"        bool has(_Iterator __first, _Iterator __last) const {",
			"            uint32_t current = 0;",
			"            for (auto it = __first; it != __last; ++it)",
			"                if (current = next(current, *it) + 1; current > m_length) return false;",
			"            return true;",
			"        }",
			"    };",
			"}",
		],
		"description": "sequence automaton"
	},
	"static sequence hasher":{
		"prefix": "HASH",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _Base, _ModType _P>",
			"    struct StaticSequenceHasher {",
			"        struct _DefaultMap {",
			"            template <typename _Tp>",
			"            _Tp operator()(_Tp __a) const { return __a; }",
			"        };",
			"        struct _HashResult {",
			"            const StaticSequenceHasher<_ModType, _Base, _P> &hasher;",
			"            std::vector<_ModType> presum;",
			"            _ModType query(uint32_t left, uint32_t right) const {",
			"                _ModType val = presum[right + 1] + _P - Modular<_ModType, _P>::multiply(presum[left], hasher.m_units[right - left + 1]);",
			"                return val >= _P ? val - _P : val;",
			"            }",
			"            _ModType queryPrefix(uint32_t i) const { return presum[i + 1]; }",
			"            _ModType querySuffix(uint32_t i) const {",
			"                _ModType val = presum.back() + _P - Modular<_ModType, _P>::multiply(presum[i], hasher.m_units[presum.size() - 1 - i]);",
			"                return val >= _P ? val - _P : val;",
			"            }",
			"            _ModType queryAll() const { return presum.back(); }",
			"        };",
			"        std::vector<_ModType> m_units;",
			"        StaticSequenceHasher(uint32_t __maxLength) {",
			"            m_units.reserve(__maxLength + 1);",
			"            m_units.push_back(1);",
			"            for (uint32_t i = 1; i <= __maxLength; i++) m_units.push_back(Modular<_ModType, _P>::multiply(m_units.back(), _Base));",
			"        }",
			"        template <typename _Iterator, typename _Mapping = _DefaultMap>",
			"        _HashResult hash(_Iterator __first, _Iterator __last, _Mapping __map = _Mapping()) const {",
			"            std::vector<_ModType> presum;",
			"            presum.reserve(__last - __first + 1);",
			"            presum.push_back(0);",
			"            for (auto it = __first; it != __last; ++it) {",
			"                _ModType val = Modular<_ModType, _P>::multiply(presum.back(), _Base) + __map(*it);",
			"                presum.push_back(val >= _P ? val - _P : val);",
			"            }",
			"            return _HashResult{*this, presum};",
			"        }",
			"    };",
			"    template <uint32_t _Base = 100003, uint32_t _P = 1000000007>",
			"    using StaticSequenceHasher32 = StaticSequenceHasher<uint32_t, _Base, _P>;",
			"    template <uint64_t _Base = 1000000007, uint64_t _P = 4000000000000000037>",
			"    using StaticSequenceHasher64 = StaticSequenceHasher<uint64_t, _Base, _P>;",
			"}",
		],
		"description": "static sequence hasher"
	},
	"suffix array":{
		"prefix": "SA",
		"body": [
			"namespace OY {",
			"    struct GetSuffixArray_naive {",
			"        template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"        std::vector<uint32_t> operator()(_Iterator __first, _Iterator __last, uint32_t __alpha) const {",
			"            const uint32_t length = __last - __first;",
			"            std::vector<uint32_t> sa;",
			"            sa.reserve(length);",
			"            for (uint32_t i = 0; i < length; i++) sa.push_back(i);",
			"            std::sort(sa.begin(), sa.end(), [&](uint32_t x, uint32_t y) {",
			"                for (uint32_t i = 0, end = length - std::max(x, y); i < end; i++) {",
			"                    if (__first[x + i] < __first[y + i])",
			"                        return true;",
			"                    else if (__first[x + i] > __first[y + i])",
			"                        return false;",
			"                }",
			"                return x > y;",
			"            });",
			"            return sa;",
			"        }",
			"    };",
			"    struct GetSuffixArray_doubling {",
			"        template <typename _Iterator>",
			"        std::vector<uint32_t> operator()(_Iterator __first, _Iterator __last, uint32_t __alpha) const {",
			"            const uint32_t length = __last - __first;",
			"            uint32_t bucketRange = __alpha;",
			"            std::vector<uint32_t> sa(length);",
			"            std::vector<uint32_t> rank(length + 1);",
			"            rank.back() = -1;",
			"            std::vector<uint32_t> nextRank(rank);",
			"            uint32_t bucket[std::max(length, __alpha)];",
			"            std::fill(bucket, bucket + sizeof(bucket) / sizeof(int), 0);",
			"            for (uint32_t i = 0; i < length; i++) bucket[rank[i] = __first[i]]++;",
			"            std::partial_sum(bucket, bucket + bucketRange, bucket);",
			"            for (uint32_t i = 0; i < length; i++) sa[--bucket[rank[i]]] = i;",
			"            uint32_t w = 1;",
			"            while (true) {",
			"                uint32_t second[length];",
			"                int index = 0;",
			"                for (uint32_t i = length - w; i < length; i++) second[index++] = i;",
			"                for (uint32_t i = 0; i < length; i++)",
			"                    if (sa[i] >= w) second[index++] = sa[i] - w;",
			"                std::fill(bucket, bucket + bucketRange, 0);",
			"                for (uint32_t i = 0; i < length; i++) bucket[rank[i]]++;",
			"                std::partial_sum(bucket, bucket + bucketRange, bucket);",
			"                for (uint32_t i = length - 1; ~i; i--) sa[--bucket[rank[second[i]]]] = second[i];",
			"                nextRank[sa[0]] = bucketRange = 0;",
			"                for (uint32_t i = 1; i < length; i++) nextRank[sa[i]] = rank[sa[i]] == rank[sa[i - 1]] && rank[sa[i] + w] == rank[sa[i - 1] + w] ? bucketRange : ++bucketRange;",
			"                rank.swap(nextRank);",
			"                if (++bucketRange == length)",
			"                    break;",
			"                w <<= 1;",
			"            }",
			"            return sa;",
			"        }",
			"    };",
			"    template <typename _SubSolver>",
			"    struct GetSuffixArray_sa_is {",
			"        template <typename _Iterator>",
			"        std::vector<uint32_t> operator()(_Iterator __first, _Iterator __last, uint32_t __alpha) const {",
			"            const uint32_t length = __last - __first;",
			"            bool isS[length];",
			"            std::fill(isS, isS + length, false);",
			"            for (uint32_t i = length - 2; ~i; i--)",
			"                if (__first[i] < __first[i + 1] || (__first[i] == __first[i + 1] && isS[i + 1])) isS[i] = true;",
			"            uint32_t lmsId[length];",
			"            uint32_t lmsCount = 0;",
			"            std::fill(lmsId, lmsId + length, -1);",
			"            for (uint32_t i = 1, id = 0; i < length; i++)",
			"                if (isS[i] && !isS[i - 1]) {",
			"                    lmsId[i] = id++;",
			"                    lmsCount++;",
			"                }",
			"            uint32_t lms[lmsCount];",
			"            for (uint32_t i = 1; i < length; i++)",
			"                if (~lmsId[i]) lms[lmsId[i]] = i;",
			"",
			"            uint32_t bucket[__alpha];",
			"            std::fill(bucket, bucket + __alpha, 0);",
			"            for (auto it = __first; it != __last; ++it) bucket[*it]++;",
			"            std::partial_sum(bucket, bucket + __alpha, bucket);",
			"",
			"            std::vector<uint32_t> sa(length);",
			"            uint32_t cursor[__alpha];",
			"            auto induce = [&](uint32_t lmsArray[]) {",
			"                std::fill(sa.begin(), sa.end(), -1);",
			"                std::copy(bucket, bucket + __alpha, cursor);",
			"                for (uint32_t i = lmsCount - 1; ~i; i--) sa[--cursor[__first[lmsArray[i]]]] = lmsArray[i];",
			"                for (uint32_t i = 0; i < __alpha; i++) cursor[i] = i ? bucket[i - 1] : 0;",
			"                sa[cursor[__first[length - 1]]++] = length - 1;",
			"                for (uint32_t i : sa)",
			"                    if (i + 1 > 1 && !isS[i - 1]) sa[cursor[__first[i - 1]]++] = i - 1;",
			"                std::copy(bucket, bucket + __alpha, cursor);",
			"                for (uint32_t i = length - 1; ~i; i--)",
			"                    if (sa[i] + 1 > 1 && isS[sa[i] - 1]) sa[--cursor[__first[sa[i] - 1]]] = sa[i] - 1;",
			"            };",
			"            induce(lms);",
			"            if (lmsCount) {",
			"                uint32_t sortedLMS[lmsCount];",
			"                for (uint32_t i = 0, j = 0; i < length; i++)",
			"                    if (~sa[i] && ~lmsId[sa[i]]) sortedLMS[j++] = sa[i];",
			"                uint32_t lmsRank[lmsCount];",
			"                uint32_t prevStart = sortedLMS[0], prevEnd = lmsId[prevStart] + 1 < lmsCount ? lms[lmsId[prevStart] + 1] : length;",
			"                uint32_t curRank = lmsRank[0] = 0;",
			"                auto isSame = [&](int curStart, int curEnd) {",
			"                    if (curEnd - curStart != prevEnd - prevStart) return false;",
			"                    for (; curStart < curEnd; curStart++, prevStart++)",
			"                        if (__first[curStart] != __first[prevStart]) return false;",
			"                    return curStart != length;",
			"                };",
			"                for (uint32_t i = 1; i < lmsCount; i++) {",
			"                    uint32_t curStart = sortedLMS[i], curEnd = lmsId[curStart] + 1 < lmsCount ? lms[lmsId[curStart] + 1] : length;",
			"                    if (!isSame(curStart, curEnd)) curRank++;",
			"                    std::tie(prevStart, prevEnd, lmsRank[i]) = {curStart, curEnd, curRank};",
			"                }",
			"                if (++curRank < lmsCount) {",
			"                    uint32_t mapped[lmsCount];",
			"                    for (uint32_t i = 0; i < lmsCount; i++) mapped[lmsId[sortedLMS[i]]] = lmsRank[i];",
			"                    std::vector<uint32_t> lms_sa = _SubSolver()(mapped, mapped + lmsCount, curRank);",
			"                    for (uint32_t i = 0; i < lmsCount; i++) sortedLMS[i] = lms[lms_sa[i]];",
			"                }",
			"                induce(sortedLMS);",
			"            }",
			"            return sa;",
			"        }",
			"    };",
			"    struct GetSuffixArray {",
			"        template <typename _Iterator>",
			"        std::vector<uint32_t> operator()(_Iterator __first, _Iterator __last, uint32_t __alpha) const {",
			"            const uint32_t length = __last - __first;",
			"            if (length == 1)",
			"                return {0};",
			"            else if (length == 2)",
			"                return __first[0] < __first[1] ? std::vector<uint32_t>{0, 1} : std::vector<uint32_t>{1, 0};",
			"            else if (length <= (1 << 4))",
			"                return GetSuffixArray_naive()(__first, __last, __alpha);",
			"            else if (length <= (1 << (1 << 4)))",
			"                return GetSuffixArray_doubling()(__first, __last, __alpha);",
			"            else",
			"                return GetSuffixArray_sa_is<GetSuffixArray>()(__first, __last, __alpha);",
			"        }",
			"    };",
			"    template <typename _Tp = char, bool _Copy = true, typename _Solver = GetSuffixArray>",
			"    struct SuffixArray {",
			"        uint32_t m_length;",
			"        std::vector<uint32_t> m_sa;",
			"        std::vector<uint32_t> m_rank;",
			"        std::vector<uint32_t> m_height;",
			"        std::basic_string<_Tp> m_text;",
			"        template <typename _Iterator>",
			"        SuffixArray(_Iterator __first, _Iterator __last, uint32_t __alpha) {",
			"            m_length = __last - __first;",
			"            m_sa = _Solver()(__first, __last, __alpha);",
			"            m_rank.resize(m_length);",
			"            for (uint32_t i = 0; i < m_length; i++) m_rank[m_sa[i]] = i;",
			"            m_height.resize(m_length);",
			"            for (uint32_t i = 0, h = 0; i < m_length; i++) {",
			"                if (h) h--;",
			"                if (m_rank[i])",
			"                    while (m_sa[m_rank[i] - 1] + h < m_length && __first[i + h] == __first[m_sa[m_rank[i] - 1] + h]) h++;",
			"                m_height[m_rank[i]] = h;",
			"            }",
			"            if constexpr (_Copy) m_text.assign(__first, __last);",
			"        }",
			"#define bisect(condition)                                                       \\",
			"    static_assert(_Copy);                                                       \\",
			"    uint32_t length = __last - __first, low = 0, high = m_length;               \\",
			"    while (low < high) {                                                        \\",
			"        uint32_t mid = (low + high) / 2, i = 0, j = m_sa[mid];                  \\",
			"        while (i < length && j < m_length && __first[i] == m_text[j]) i++, j++; \\",
			"        if (condition)                                                          \\",
			"            high = mid;                                                         \\",
			"        else                                                                    \\",
			"            low = mid + 1;                                                      \\",
			"    }                                                                           \\",
			"    return low;",
			"        template <typename _Iterator>",
			"        uint32_t lower_bound(_Iterator __first, _Iterator __last) const { bisect(i == length || (j < m_length && __first[i] < m_text[j])); }",
			"        template <typename _Iterator>",
			"        uint32_t upper_bound(_Iterator __first, _Iterator __last) const { bisect(i < length && j < m_length && __first[i] < m_text[j]); }",
			"#undef bisect",
			"    };",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SuffixArray(_Iterator, _Iterator, uint32_t) -> SuffixArray<_Tp>;",
			"}",
		],
		"description": "suffix array"
	},
	"suffix automaton":{
		"prefix": "SAM",
		"body": [
			"namespace OY {",
			"    struct SAMDefaultInfo {};",
			"    template <typename _Mapping = TrieLowerMapping, typename _Info = SAMDefaultInfo, uint32_t _PoolSize = 2000000>",
			"    struct SuffixAutomaton {",
			"        struct _SAMInfo : _Info {",
			"            uint32_t m_size;",
			"            uint32_t m_length;",
			"        };",
			"        using TrieNode = typename Trie<_Mapping, _SAMInfo, _PoolSize>::TrieNode;",
			"        static inline Trie<_Mapping, _SAMInfo, _PoolSize> s_trie;",
			"        static inline TrieNode s_end;",
			"        static void Init() {",
			"            if (!~TrieNode(0).child(0)) s_trie = Trie<_Mapping, _SAMInfo, _PoolSize>();",
			"            std::fill(s_trie.s_child[0], s_trie.s_child[1], -1);",
			"            s_end = s_trie.m_root;",
			"        }",
			"        template <typename _Tp>",
			"        static TrieNode Insert(_Tp __c) {",
			"            TrieNode oldEnd = s_end;",
			"            s_end = oldEnd.childGet(Trie<_Mapping, _SAMInfo, _PoolSize>::s_map(__c));",
			"            s_end->m_length = oldEnd->m_length + 1;",
			"            s_end->m_size = 1;",
			"            while (true) {",
			"                oldEnd = oldEnd.parent();",
			"                if (TrieNode &child = oldEnd.child(Trie<_Mapping, _SAMInfo, _PoolSize>::s_map(__c)))",
			"                    break;",
			"                else",
			"                    child = s_end;",
			"            }",
			"            if (!oldEnd)",
			"                s_end.parent() = s_trie.m_root;",
			"            else {",
			"                TrieNode q = oldEnd.child(Trie<_Mapping, _SAMInfo, _PoolSize>::s_map(__c));",
			"                if (q->m_length == oldEnd->m_length + 1)",
			"                    s_end.parent() = q;",
			"                else {",
			"                    TrieNode newq = s_trie.s_cursor++;",
			"                    newq.parent() = q.parent();",
			"                    std::copy(s_trie.s_child[q.index], s_trie.s_child[q.index + 1], s_trie.s_child[newq]);",
			"                    newq->m_length = oldEnd->m_length + 1;",
			"                    q.parent() = s_end.parent() = newq;",
			"                    while (oldEnd.child(Trie<_Mapping, _SAMInfo, _PoolSize>::s_map(__c)) == q) {",
			"                        oldEnd.child(Trie<_Mapping, _SAMInfo, _PoolSize>::s_map(__c)) = newq;",
			"                        oldEnd = oldEnd.parent();",
			"                    }",
			"                }",
			"            }",
			"            return s_end;",
			"        }",
			"        static void Build() {",
			"            static uint32_t s_deg[_PoolSize];",
			"            static TrieNode s_queue[_PoolSize];",
			"            uint32_t head = 0, tail = 0;",
			"            for (uint32_t i = s_trie.m_root.index; i < s_trie.s_cursor; i++) s_deg[TrieNode(i).parent()]++;",
			"            for (uint32_t i = s_trie.m_root.index; i < s_trie.s_cursor; i++)",
			"                if (!s_deg[i]) s_queue[tail++] = i;",
			"            while (head < tail) {",
			"                TrieNode p = s_queue[head++];",
			"                p.parent()->m_size += p->m_size;",
			"                if (!--s_deg[p.parent().index]) s_queue[tail++] = p.parent();",
			"            }",
			"            TrieNode(0)->m_size = 0;",
			"        }",
			"        template <typename _Iterator>",
			"        static TrieNode Find(_Iterator __first, _Iterator __last) {",
			"            if (__first == __last) return s_trie.m_root;",
			"            TrieNode cur = s_trie.m_root;",
			"            for (auto it = __first; it != __last; ++it) {",
			"                if (cur = cur.child(s_trie.s_map(*it))) continue;",
			"                return TrieNode(0);",
			"            }",
			"            return cur;",
			"        }",
			"    };",
			"    template <typename _Mapping = TrieLowerMapping, uint32_t _PoolSize = 2000000>",
			"    struct GetSuffixArray_sam {",
			"        struct IndexInfo {",
			"            uint32_t m_index;",
			"        };",
			"        using SAM = SuffixAutomaton<_Mapping, IndexInfo, _PoolSize>;",
			"        using TrieNode = typename SAM::TrieNode;",
			"        static inline uint32_t stack[_PoolSize];",
			"        static inline uint32_t stackLen{};",
			"        static inline TrieNode tree[_PoolSize][_Mapping::range()];",
			"        static void makeTree(TrieNode cur) {",
			"            for (uint32_t i = 0; i < _Mapping::range(); i++)",
			"                if (TrieNode child = cur.child(i))",
			"                    if (child->m_length == cur->m_length + 1) {",
			"                        stack[stackLen++] = i;",
			"                        tree[child.parent()][stack[stackLen - child.parent()->m_length - 1]] = child;",
			"                        makeTree(child);",
			"                        stackLen--;",
			"                    }",
			"        }",
			"        static void preOrderTraverse(TrieNode cur, std::vector<uint32_t> &sa) {",
			"            if (cur->m_index) sa.push_back(cur->m_index - 1);",
			"            for (uint32_t i = 0; i < _Mapping::range(); i++)",
			"                if (TrieNode child = tree[cur][i]) preOrderTraverse(child, sa);",
			"        }",
			"        template <typename _Iterator>",
			"        std::vector<uint32_t> operator()(_Iterator __first, _Iterator __last, uint32_t __alpha) const {",
			"            SAM::Init();",
			"            for (uint32_t i = __last - __first - 1; ~i; i--) SAM::Insert(__first[i])->m_index = i + 1;",
			"            makeTree(SAM::s_trie.m_root);",
			"            std::vector<uint32_t> sa;",
			"            sa.reserve(__last - __first);",
			"            preOrderTraverse(SAM::s_trie.m_root, sa);",
			"            return sa;",
			"        }",
			"    };",
			"}",
		],
		"description": "suffix automaton"
	},
	"suffix tree":{
		"prefix": "ST",
		"body": [
			"namespace OY {",
			"    struct SuffixTreeDefaultInfo {};",
			"    template <typename _Mapping = TrieLowerMapping, typename _Info = SuffixTreeDefaultInfo, uint32_t _PoolSize = 1000000>",
			"    struct SuffixTree {",
			"        struct _SuffixTreeInfo : _Info {",
			"            uint32_t m_begin;",
			"            uint32_t m_end;",
			"            uint32_t m_index;",
			"            uint32_t m_size;",
			"            typename Trie<_Mapping, _SuffixTreeInfo, _PoolSize>::TrieNode m_link;",
			"        };",
			"        using TrieNode = typename Trie<_Mapping, _SuffixTreeInfo, _PoolSize>::TrieNode;",
			"        static inline Trie<_Mapping, _SuffixTreeInfo, _PoolSize> s_trie;",
			"        static inline uint32_t s_length;",
			"        static inline TrieNode s_activeNode;",
			"        static inline uint32_t s_activeChild;",
			"        static inline uint32_t s_activeLength;",
			"        static inline uint32_t s_leafEnd = -1;",
			"        static inline uint32_t s_phase;",
			"        static void Init() {",
			"            if (!~s_trie.m_root->m_index) s_trie = Trie<_Mapping, _SuffixTreeInfo, _PoolSize>();",
			"            s_trie.m_root->m_index = -1;",
			"            s_length = 0;",
			"            s_activeNode = s_trie.m_root;",
			"            s_activeLength = 0;",
			"            s_phase = 0;",
			"        }",
			"        template <typename _Iterator>",
			"        static void Insert(_Iterator __first, _Iterator __last) {",
			"            TrieNode waitLink;",
			"            auto goForward = [&](TrieNode child) {",
			"                if (s_activeLength >= child->m_end - child->m_begin) {",
			"                    s_activeLength -= child->m_end - child->m_begin;",
			"                    s_activeNode = child;",
			"                    s_activeChild = s_trie.s_map(__first[s_length - s_activeLength]);",
			"                    return true;",
			"                } else",
			"                    return false;",
			"            };",
			"            auto split = [&](TrieNode child, uint32_t index) {",
			"                TrieNode p = TrieNode::newNode(s_activeNode, s_activeChild);",
			"                p->m_begin = child->m_begin;",
			"                p->m_end = child->m_begin + s_activeLength;",
			"                p->m_index = index;",
			"                child->m_begin += s_activeLength;",
			"                p.child(s_trie.s_map(__first[child->m_begin])) = child;",
			"                child.parent() = p;",
			"                waitLink->m_link = p;",
			"                return waitLink = p;",
			"            };",
			"            auto transform = [&] {",
			"                s_phase++;",
			"                if (s_activeNode != s_trie.m_root)",
			"                    s_activeNode = s_activeNode->m_link;",
			"                else if (s_activeLength) {",
			"                    s_activeLength--;",
			"                    s_activeChild = s_trie.s_map(__first[s_phase]);",
			"                }",
			"            };",
			"            auto extend = [&](auto c) {",
			"                waitLink = 0;",
			"                while (s_phase <= s_length) {",
			"                    if (!s_activeLength) s_activeChild = s_trie.s_map(c);",
			"                    if (TrieNode child = s_activeNode.child(s_activeChild)) {",
			"                        if (goForward(child)) continue;",
			"                        if (__first[child->m_begin + s_activeLength] == c) {",
			"                            waitLink->m_link = s_activeNode;",
			"                            s_activeLength++;",
			"                            break;",
			"                        }",
			"                        TrieNode q = split(child, s_leafEnd).childGet(s_trie.s_map(c));",
			"                        std::tie(q->m_begin, q->m_end, q->m_index) = {s_length, s_leafEnd, s_phase};",
			"                    } else {",
			"                        TrieNode q = s_activeNode.childGet(s_activeChild);",
			"                        std::tie(q->m_begin, q->m_end, q->m_index) = {s_length, s_leafEnd, s_phase};",
			"                        waitLink->m_link = s_activeNode;",
			"                        waitLink = 0;",
			"                    }",
			"                    transform();",
			"                }",
			"                s_length++;",
			"            };",
			"            for (auto it = __first; it != __last; ++it) extend(*it);",
			"            waitLink = 0;",
			"            while (s_phase < s_length) {",
			"                if (!s_activeLength)",
			"                    s_activeNode->m_index = s_phase;",
			"                else if (TrieNode child = s_activeNode.child(s_activeChild)) {",
			"                    if (goForward(child)) continue;",
			"                    split(child, s_phase);",
			"                }",
			"                transform();",
			"            }",
			"        }",
			"        static void Build() {",
			"            static uint32_t s_deg[_PoolSize];",
			"            static TrieNode s_queue[_PoolSize];",
			"            uint32_t head = 0, tail = 0;",
			"            for (uint32_t i = s_trie.m_root.index; i < s_trie.s_cursor; i++) s_deg[TrieNode(i).parent()]++;",
			"            for (uint32_t i = s_trie.m_root.index; i < s_trie.s_cursor; i++)",
			"                if (!s_deg[i]) s_queue[tail++] = i;",
			"            while (head < tail) {",
			"                TrieNode p = s_queue[head++];",
			"                if (~p->m_index) p->m_size++;",
			"                p.parent()->m_size += p->m_size;",
			"                if (!--s_deg[p.parent().index]) s_queue[tail++] = p.parent();",
			"            }",
			"            TrieNode(0)->m_size = 0;",
			"        }",
			"        template <typename _Sequence, typename _Iterator>",
			"        static auto Find(const _Sequence &__seq, _Iterator __first, _Iterator __last) {",
			"            struct _Find_ans {",
			"                TrieNode node;",
			"                uint32_t length;",
			"            };",
			"            if (__first == __last) return _Find_ans{0, 0};",
			"            TrieNode curNode = s_trie.m_root;",
			"            uint32_t curLength = 0;",
			"            for (auto it = __first; it != __last; ++it) {",
			"                if (curLength == curNode->m_end - curNode->m_begin) {",
			"                    if (TrieNode child = curNode.child(s_trie.s_map(*it))) {",
			"                        curNode = child;",
			"                        curLength = 1;",
			"                        continue;",
			"                    }",
			"                } else if (__seq[curNode->m_begin + curLength] == *it) {",
			"                    curLength++;",
			"                    continue;",
			"                }",
			"                return _Find_ans{0, 0};",
			"            }",
			"            return _Find_ans{curNode, curLength};",
			"        }",
			"    };",
			"    template <typename _Mapping = TrieLowerMapping, uint32_t _PoolSize = 2000000, bool log = true>",
			"    struct GetSuffixArray_tree {",
			"        using ST = SuffixTree<_Mapping, SuffixTreeDefaultInfo, _PoolSize>;",
			"        using TrieNode = typename ST::TrieNode;",
			"        static void dfs(TrieNode cur, std::vector<uint32_t> &sa) {",
			"            if (~cur->m_index) sa.push_back(cur->m_index);",
			"            for (uint32_t i = 0; i < _Mapping::range(); i++)",
			"                if (TrieNode child = cur.child(i)) dfs(child, sa);",
			"        }",
			"        template <typename _Iterator>",
			"        std::vector<uint32_t> operator()(_Iterator __first, _Iterator __last, uint32_t __alpha) const {",
			"            ST::Init();",
			"            ST::Insert(__first, __last);",
			"            std::vector<uint32_t> sa;",
			"            sa.reserve(__last - __first);",
			"            dfs(ST::s_trie.m_root, sa);",
			"            return sa;",
			"        }",
			"    };",
			"}",
		],
		"description": "suffix tree"
	},
	"trie":{
		"prefix": "TRIE",
		"body": [
			"namespace OY {",
			"    struct TrieDigitMapping {",
			"        static constexpr int range() { return 10; }",
			"        int operator()(char __c) const { return __c - '0'; }",
			"    };",
			"    struct TrieLowerMapping {",
			"        static constexpr int range() { return 26; }",
			"        int operator()(char __c) const { return __c - 'a'; }",
			"    };",
			"    struct TrieUpperMapping {",
			"        static constexpr int range() { return 26; }",
			"        int operator()(char __c) const { return __c - 'A'; }",
			"    };",
			"    struct TrieCharMapping {",
			"        static constexpr int range() { return 128; }",
			"        int operator()(char __c) const { return __c; }",
			"    };",
			"    struct TrieDefaultInfo {",
			"        bool m_isEnd = false;",
			"    };",
			"    template <typename _Mapping = TrieLowerMapping, typename _Info = TrieDefaultInfo, uint32_t _PoolSize = 1000000>",
			"    struct Trie {",
			"        struct TrieNode;",
			"        static inline _Mapping s_map = _Mapping();",
			"        static inline TrieNode s_parent[_PoolSize];",
			"        static inline TrieNode s_child[_PoolSize][_Mapping::range()];",
			"        static inline _Info s_info[_PoolSize];",
			"        static inline uint32_t s_cursor = 1;",
			"        struct TrieNode {",
			"            uint32_t index;",
			"            TrieNode() = default;",
			"            TrieNode(uint32_t index) : index(index) {}",
			"            static constexpr TrieNode newNode(TrieNode parent) {",
			"                s_parent[s_cursor] = parent;",
			"                return s_cursor++;",
			"            }",
			"            static constexpr TrieNode newNode(TrieNode parent, uint32_t i) {",
			"                s_parent[s_cursor] = parent;",
			"                s_child[parent.index][i] = s_cursor;",
			"                return s_cursor++;",
			"            }",
			"            constexpr TrieNode &parent() { return s_parent[index]; }",
			"            constexpr TrieNode &child(uint32_t i) { return s_child[index][i]; }",
			"            constexpr TrieNode &child(uint32_t i) const { return s_child[index][i]; }",
			"            constexpr TrieNode &childGet(uint32_t i) {",
			"                if (!s_child[index][i]) s_child[index][i] = newNode(*this, i);",
			"                return s_child[index][i];",
			"            }",
			"            template <typename _Iterator>",
			"            constexpr TrieNode insert(_Iterator first, _Iterator last) {",
			"                if (first == last)",
			"                    return *this;",
			"                else",
			"                    return childGet(s_map(*first)).insert(first + 1, last);",
			"            }",
			"            template <typename _Sequence>",
			"            constexpr TrieNode insert(_Sequence &sequence) { return insert(sequence.begin(), sequence.end()); }",
			"            template <typename _Iterator>",
			"            constexpr TrieNode find(_Iterator first, _Iterator last) const {",
			"                if (first == last)",
			"                    return *this;",
			"                else if (child(s_map(*first)))",
			"                    return child(s_map(*first)).find(first + 1, last);",
			"                else",
			"                    return 0;",
			"            }",
			"            template <typename _Sequence>",
			"            constexpr TrieNode find(_Sequence &sequence) const { return find(sequence.begin(), sequence.end()); }",
			"            constexpr _Info *operator->() const { return s_info + index; }",
			"            constexpr _Info &operator*() { return s_info[index]; }",
			"            constexpr explicit operator bool() const { return index; }",
			"            constexpr operator uint32_t() const { return index; }",
			"        };",
			"        TrieNode m_root;",
			"        Trie() : m_root(s_cursor++) {}",
			"        template <typename _Iterator>",
			"        TrieNode insert(_Iterator __first, _Iterator __last) { return m_root.insert(__first, __last); }",
			"        template <typename _Sequence>",
			"        TrieNode insert(const _Sequence &__sequence) { return m_root.insert(__sequence.begin(), __sequence.end()); }",
			"        template <typename _Iterator>",
			"        TrieNode find(_Iterator __first, _Iterator __last) const { return m_root.find(__first, __last); }",
			"        template <typename _Sequence>",
			"        TrieNode find(const _Sequence &__sequence) const { return m_root.find(__sequence.begin(), __sequence.end()); }",
			"    };",
			"    template <typename _Mapping = TrieLowerMapping, typename _Info = TrieDefaultInfo, uint32_t _PoolSize = 1000000>",
			"    Trie() -> Trie<_Mapping, _Info, _PoolSize>;",
			"}",
		],
		"description": "trie"
	},
	"Z algorithm":{
		"prefix": "Z",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    class ZAlgorithm {",
			"        std::basic_string<_Tp> m_pattern;",
			"        std::vector<int> m_z;",
			"",
			"    public:",
			"        template <typename _Iterator>",
			"        ZAlgorithm(_Iterator __first, _Iterator __last) {",
			"            m_pattern.assign(__first, __last);",
			"            m_z.reserve(__last - __first);",
			"            m_z.push_back(0);",
			"            for (int l = 0, r = 0, i = 1; i < m_pattern.size(); i++) m_z.push_back(adjust(l, r, i, m_pattern.size(), m_pattern));",
			"        }",
			"        template <typename _Iterator>",
			"        int search(_Iterator __first, _Iterator __last) const {",
			"            if (m_z.empty()) return 0;",
			"            const int length = __last - __first;",
			"            for (int l = -1, r = -1, i = 0; i < length; i++)",
			"                if (adjust(l, r, i, length, __first) == m_pattern.size()) return i;",
			"            return -1;",
			"        }",
			"        int queryZ(int __i) const { return m_z[__i]; }",
			"        template <typename _Sequence>",
			"        int adjust(int &__l, int &__r, int __i, int __length, const _Sequence &__sequence) const {",
			"            if (__i <= __r && m_z[__i - __l] < __r - __i + 1)",
			"                return m_z[__i - __l];",
			"            else if (__sequence[__i] != m_pattern[0])",
			"                return 0;",
			"            __l = __i;",
			"            if (__r < __i) __r = __i;",
			"            while (__r + 1 < __length && __sequence[__r + 1] == m_pattern[__r + 1 - __i]) __r++;",
			"            return __r - __i + 1;",
			"        }",
			"    };",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    ZAlgorithm(_Iterator, _Iterator) -> ZAlgorithm<_Tp>;",
			"}",
		],
		"description": "Z algorithm"
	},

	"Bellman ford":{
		"prefix": "BF",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct BellmanFord {",
			"        struct _Edge {",
			"            uint32_t from, to;",
			"            _Tp distance;",
			"        };",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<_Tp> m_distances;",
			"        std::vector<uint32_t> m_from;",
			"        uint32_t m_vertexNum;",
			"        _Tp m_infiniteDistance;",
			"        BellmanFord(uint32_t __vertexNum, uint32_t __edgeNum, _Tp __infiniteDistance = std::numeric_limits<_Tp>::max() / 2) : m_distances(__vertexNum, __infiniteDistance), m_vertexNum(__vertexNum), m_infiniteDistance(__infiniteDistance) { m_edges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __distance) { m_edges.push_back({__a, __b, __distance}); }",
			"        void setDistance(uint32_t __i, _Tp __distance = 0) { m_distances[__i] = __distance; }",
			"        template <bool _GetPath = false>",
			"        bool calc() {",
			"            if constexpr (_GetPath) m_from.resize(m_vertexNum, -1);",
			"            uint32_t lastUpdate = -1;",
			"            for (uint32_t i = 0; i < m_vertexNum && lastUpdate == i - 1; i++)",
			"                for (uint32_t index = 0; index < m_edges.size(); index++)",
			"                    if (auto &[from, to, distance] = m_edges[index]; m_distances[from] != m_infiniteDistance && chmin(m_distances[to], m_distances[from] + distance)) {",
			"                        lastUpdate = i;",
			"                        if constexpr (_GetPath) m_from[to] = index;",
			"                    }",
			"            return lastUpdate != m_vertexNum - 1;",
			"        }",
			"        std::vector<uint32_t> getPath_edge(uint32_t __target) const {",
			"            std::vector<uint32_t> path;",
			"            for (uint32_t cur = __target; ~m_from[cur]; cur = m_edges[m_from[cur]].from) path.push_back(m_from[cur]);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"        std::vector<uint32_t> getPath_vertex(uint32_t __target) const {",
			"            std::vector<uint32_t> path;",
			"            path.push_back(__target);",
			"            for (uint32_t cur = __target; ~m_from[cur];) path.push_back(cur = m_edges[m_from[cur]].from);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"    };",
			"}",
		],
		"description": "Bellman Ford"
	},
	"Bipartite check":{
		"prefix": "BIPARTITE",
		"body": [
			"namespace OY {",
			"    struct BipartiteCheck {",
			"        struct _Edge {",
			"            uint32_t from, to;",
			"        };",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_adj;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<uint32_t> m_color;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_colorCount;",
			"        BipartiteCheck(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_color(__vertexNum, -1), m_vertexNum(__vertexNum) { m_edges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_edges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[from, to] : m_edges) {",
			"                m_starts[from + 1]++;",
			"                if (from != to) m_starts[to + 1]++;",
			"            }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_adj.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_edges.size(); index++) {",
			"                auto &[from, to] = m_edges[index];",
			"                m_adj[cursor[from]++] = to;",
			"                if (from != to) m_adj[cursor[to]++] = from;",
			"            }",
			"        }",
			"        bool calc() {",
			"            uint32_t queue[m_vertexNum];",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                if (!~m_color[i]) {",
			"                    uint32_t head = 0, tail = 0;",
			"                    m_color[i] = m_colorCount;",
			"                    queue[tail++] = i;",
			"                    while (head < tail)",
			"                        for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                            if (uint32_t to = m_adj[cur]; !~m_color[to]) {",
			"                                m_color[to] = m_color[from] ^ 1;",
			"                                queue[tail++] = to;",
			"                            } else if (m_color[to] == m_color[from])",
			"                                return false;",
			"                    m_colorCount += 2;",
			"                }",
			"            return true;",
			"        }",
			"    };",
			"}",
		],
		"description": "bipartite check"
	},
	"Borivka":{
		"prefix": "BORUVKA",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Boruvka {",
			"        struct _Edge {",
			"            uint32_t from, to;",
			"            _Tp cost;",
			"        };",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<bool> m_used;",
			"        UnionFind m_union;",
			"        uint32_t m_vertexNum;",
			"        Boruvka(uint32_t __vertexNum, uint32_t __edgeNum) : m_union(__vertexNum), m_vertexNum(__vertexNum) { m_edges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_edges.push_back({__a, __b, __cost}); }",
			"        bool calc() {",
			"            m_used.resize(m_edges.size(), false);",
			"            uint32_t closest[m_vertexNum];",
			"            std::fill(closest, closest + m_vertexNum, -1);",
			"            while (m_union.count() > 1) {",
			"                bool flag = false;",
			"                for (uint32_t index = 0; index < m_edges.size(); index++) {",
			"                    auto [from, to, cost] = m_edges[index];",
			"                    if (from = m_union.find(from), to = m_union.find(to); from != to) {",
			"                        flag = true;",
			"                        if (!~closest[from] || m_edges[closest[from]].cost > cost) closest[from] = index;",
			"                        if (!~closest[to] || m_edges[closest[to]].cost > cost) closest[to] = index;",
			"                    }",
			"                }",
			"                if (!flag) break;",
			"                for (uint32_t &d : closest)",
			"                    if (~d && m_union.uniteBySize(m_edges[d].from, m_edges[d].to)) m_used[d] = true;",
			"                std::fill(closest, closest + m_vertexNum, -1);",
			"            }",
			"            return m_union.count() == 1;",
			"        }",
			"        _Tp totalCost() const {",
			"            _Tp res = 0;",
			"            for (uint32_t index = 0; index < m_used.size(); index++)",
			"                if (m_used[index]) res += m_edges[index].cost;",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Boruvka"
	},
	"Capacity Scaling":{
		"prefix": "CS",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct CapacityScaling_mcmf {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"            _Fp cost;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap, flow;",
			"            _Fp cost;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_source;",
			"        uint32_t m_target;",
			"        _Tp m_infiniteCap;",
			"        _Fp m_infiniteCost;",
			"        CapacityScaling_mcmf(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum + 1); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap, _Fp __cost) { m_rawEdges.push_back({__a, __b, __cap, __cost}); }",
			"        void setting(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2, _Fp __infiniteCost = std::numeric_limits<_Fp>::max() / 2) {",
			"            m_source = __source;",
			"            m_target = __target;",
			"            m_infiniteCap = __infiniteCap;",
			"            m_infiniteCost = __infiniteCost;",
			"        }",
			"        void prepare() {",
			"            m_rawEdges.push_back({m_target, m_source, m_infiniteCap, -m_infiniteCost});",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{to, cursor[to], cap, 0, cost};",
			"                    m_edges[cursor[to]++] = _Edge{from, cursor[from]++, 0, 0, -cost};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        std::pair<_Tp, _Fp> calc() {",
			"            uint32_t queue[m_vertexNum + 1], fromEdge[m_vertexNum], prev[m_vertexNum], head = 0, tail = 0;",
			"            std::vector<bool> inQueue(m_vertexNum, false);",
			"            _Tp totalFlow = 0;",
			"            _Fp costs[m_vertexNum], totalCost = 0;",
			"            auto spfa = [&](uint32_t i) {",
			"                std::fill(costs, costs + m_vertexNum, m_infiniteCost);",
			"                costs[i] = 0;",
			"                queue[tail++] = i;",
			"                if (tail == m_vertexNum + 1) tail = 0;",
			"                inQueue[i] = true;",
			"                while (head != tail) {",
			"                    uint32_t from = queue[head++];",
			"                    if (head == m_vertexNum + 1) head = 0;",
			"                    inQueue[from] = false;",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap, flow, cost] = m_edges[cur]; flow && chmin(costs[to], costs[from] + cost)) {",
			"                            fromEdge[to] = cur;",
			"                            prev[to] = from;",
			"                            if (!inQueue[to]) {",
			"                                queue[tail++] = to;",
			"                                if (tail == m_vertexNum + 1) tail = 0;",
			"                                inQueue[to] = true;",
			"                            }",
			"                        }",
			"                }",
			"            };",
			"            for (uint32_t i = std::__countr_zero(std::__bit_floor(m_infiniteCap)); ~i; i--) {",
			"                for (auto &[to, rev, cap, flow, cost] : m_edges) flow <<= 1;",
			"                for (uint32_t from = 0; from < m_vertexNum; from++)",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap, flow, cost] = m_edges[cur]; cap >> i & 1) {",
			"                            if (flow) {",
			"                                flow++;",
			"                                continue;",
			"                            }",
			"                            spfa(to);",
			"                            if (costs[from] < m_infiniteCost && costs[from] + cost < 0) {",
			"                                m_edges[rev].flow++;",
			"                                for (uint32_t cur = from; cur != to; cur = prev[cur]) {",
			"                                    auto &[to, rev, cap, flow, cost] = m_edges[fromEdge[cur]];",
			"                                    flow--;",
			"                                    m_edges[rev].flow++;",
			"                                }",
			"                            } else",
			"                                flow++;",
			"                        }",
			"            }",
			"            for (uint32_t from = 0; from < m_vertexNum; from++)",
			"                for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                    if (auto &[to, rev, cap, flow, cost] = m_edges[cur]; cap)",
			"                        if (cap == m_infiniteCap)",
			"                            totalFlow = m_edges[rev].flow;",
			"                        else",
			"                            totalCost += m_edges[rev].flow * cost;",
			"            return {totalFlow, totalCost};",
			"        }",
			"    };",
			"}",
		],
		"description": "Capacity Scaling mcmf"
	},
	"CostFlow helper":{
		"prefix": "FLOW",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp, template <typename...> typename _Solver>",
			"    struct CostFlowHelper : _Solver<_Tp, _Fp> {",
			"        using _Solver<_Tp, _Fp>::m_vertexNum, _Solver<_Tp, _Fp>::m_starts, _Solver<_Tp, _Fp>::m_rawEdges, _Solver<_Tp, _Fp>::m_edges;",
			"        CostFlowHelper(uint32_t __vertexNum, uint32_t __edgeNum) : _Solver<_Tp, _Fp>(__vertexNum, __edgeNum) {}",
			"        void recover() {",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    _Tp flow = m_edges[cursor[to]].cap;",
			"                    m_edges[cursor[to]++].cap = 0;",
			"                    m_edges[cursor[from]++].cap += flow;",
			"                }",
			"        }",
			"        std::vector<_Tp> getPath() const {",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            std::vector<_Tp> res;",
			"            res.reserve(m_rawEdges.size());",
			"            for (auto &[from, to, cap, cost] : m_rawEdges) {",
			"                if (from != to) {",
			"                    res.push_back(m_edges[cursor[to]++].cap);",
			"                    cursor[from]++;",
			"                } else",
			"                    res.push_back(0);",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"    template <typename _Tp, typename _Fp, template <typename...> typename _Solver>",
			"    struct BoundCostFlow : CostFlowHelper<_Tp, _Fp, _Solver> {",
			"        std::vector<_Tp> m_delta, m_low;",
			"        _Tp m_initFlow, m_infiniteCap;",
			"        _Fp m_initCost, m_cost, m_infiniteCost;",
			"        uint32_t m_source, m_target;",
			"        BoundCostFlow(uint32_t __vertexNum, uint32_t __edgeNum) : CostFlowHelper<_Tp, _Fp, _Solver>(__vertexNum + 2, __edgeNum + __vertexNum + 1), m_delta(__vertexNum + 2, 0), m_initFlow(0), m_initCost(0) { m_low.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __lower, _Tp __upper, _Fp __cost) {",
			"            m_delta[__a] -= __lower;",
			"            m_delta[__b] += __lower;",
			"            m_low.push_back(__lower);",
			"            m_initCost += __lower * __cost;",
			"            CostFlowHelper<_Tp, _Fp, _Solver>::addEdge(__a, __b, __upper - __lower, __cost);",
			"        }",
			"        void setting(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            m_source = __source;",
			"            m_target = __target;",
			"            CostFlowHelper<_Tp, _Fp, _Solver>::addEdge(__target, __source, m_infiniteCap = __infiniteCap, 0);",
			"        }",
			"        void prepare() {",
			"            for (uint32_t i = 0; i < m_delta.size(); i++)",
			"                if (m_delta[i] > 0) {",
			"                    CostFlowHelper<_Tp, _Fp, _Solver>::addEdge(m_delta.size() - 2, i, m_delta[i], 0);",
			"                    m_initFlow += m_delta[i];",
			"                } else if (m_delta[i] < 0)",
			"                    CostFlowHelper<_Tp, _Fp, _Solver>::addEdge(i, m_delta.size() - 1, -m_delta[i], 0);",
			"            CostFlowHelper<_Tp, _Fp, _Solver>::prepare();",
			"        }",
			"        bool isPossible(_Fp __infiniteCost = std::numeric_limits<_Fp>::max() / 2) {",
			"            auto [flow, cost] = CostFlowHelper<_Tp, _Fp, _Solver>::calc(CostFlowHelper<_Tp, _Fp, _Solver>::m_vertexNum - 2, CostFlowHelper<_Tp, _Fp, _Solver>::m_vertexNum - 1, m_infiniteCap, m_infiniteCost = __infiniteCost);",
			"            m_cost = m_initCost + cost;",
			"            return flow == m_initFlow;",
			"        }",
			"        std::pair<_Tp, _Fp> minFlow() {",
			"            auto [flow, cost] = CostFlowHelper<_Tp, _Fp, _Solver>::calc(m_target, m_source, m_infiniteCap, m_infiniteCost);",
			"            m_cost -= cost;",
			"            return {m_infiniteCap - flow, m_cost};",
			"        }",
			"        std::pair<_Tp, _Fp> maxFlow() {",
			"            auto [flow, cost] = CostFlowHelper<_Tp, _Fp, _Solver>::calc(m_source, m_target, m_infiniteCap, m_infiniteCost);",
			"            m_cost += cost;",
			"            return {flow, m_cost};",
			"        }",
			"        std::vector<_Tp> getPath() const {",
			"            uint32_t cursor[CostFlowHelper<_Tp, _Fp, _Solver>::m_vertexNum];",
			"            std::copy(CostFlowHelper<_Tp, _Fp, _Solver>::m_starts.begin(), CostFlowHelper<_Tp, _Fp, _Solver>::m_starts.begin() + CostFlowHelper<_Tp, _Fp, _Solver>::m_vertexNum, cursor);",
			"            std::vector<_Tp> res(m_low);",
			"            for (uint32_t index = 0; index < res.size(); index++)",
			"                if (auto &[from, to, cap, cost] = CostFlowHelper<_Tp, _Fp, _Solver>::m_rawEdges[index]; from != to) {",
			"                    res[index] += CostFlowHelper<_Tp, _Fp, _Solver>::m_edges[cursor[to]++].cap;",
			"                    cursor[from]++;",
			"                }",
			"            return res;",
			"        }",
			"    };",
			"    template <typename _Tp, typename _Fp, template <typename...> typename _Solver>",
			"    struct NegativeCostFlow : CostFlowHelper<_Tp, _Fp, _Solver> {",
			"        std::vector<_Tp> m_delta, m_low;",
			"        _Fp m_initCost;",
			"        uint32_t m_source, m_target;",
			"        NegativeCostFlow(uint32_t __vertexNum, uint32_t __edgeNum) : CostFlowHelper<_Tp, _Fp, _Solver>(__vertexNum + 2, __edgeNum + __vertexNum + 1), m_delta(__vertexNum + 2, 0), m_initCost(0) { m_low.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap, _Fp __cost) {",
			"            if (__cap && __cost < 0 && __a != __b) {",
			"                m_low.push_back(-__cap);",
			"                m_initCost += __cap * __cost;",
			"                m_delta[__b] += __cap;",
			"                m_delta[__a] -= __cap;",
			"                CostFlowHelper<_Tp, _Fp, _Solver>::addEdge(__b, __a, __cap, -__cost);",
			"            } else {",
			"                m_low.push_back(0);",
			"                CostFlowHelper<_Tp, _Fp, _Solver>::addEdge(__a, __b, __cap, __cost);",
			"            }",
			"        }",
			"        void setting(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            m_source = __source;",
			"            m_target = __target;",
			"            CostFlowHelper<_Tp, _Fp, _Solver>::addEdge(__target, __source, __infiniteCap, 0);",
			"        }",
			"        void prepare() {",
			"            for (uint32_t i = 0; i < m_delta.size(); i++)",
			"                if (m_delta[i] > 0) {",
			"                    CostFlowHelper<_Tp, _Fp, _Solver>::addEdge(m_delta.size() - 2, i, m_delta[i], 0);",
			"                } else if (m_delta[i] < 0)",
			"                    CostFlowHelper<_Tp, _Fp, _Solver>::addEdge(i, m_delta.size() - 1, -m_delta[i], 0);",
			"            CostFlowHelper<_Tp, _Fp, _Solver>::prepare();",
			"        }",
			"        std::pair<_Tp, _Fp> calc(_Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2, _Fp __infiniteCost = std::numeric_limits<_Fp>::max() / 2) {",
			"            _Fp cost1 = CostFlowHelper<_Tp, _Fp, _Solver>::calc(CostFlowHelper<_Tp, _Fp, _Solver>::m_vertexNum - 2, CostFlowHelper<_Tp, _Fp, _Solver>::m_vertexNum - 1, __infiniteCap, __infiniteCost).second;",
			"            auto [flow, cost2] = CostFlowHelper<_Tp, _Fp, _Solver>::calc(m_source, m_target, __infiniteCap, __infiniteCost);",
			"            return {flow, m_initCost + cost1 + cost2};",
			"        }",
			"        std::vector<_Tp> getPath() const {",
			"            uint32_t cursor[CostFlowHelper<_Tp, _Fp, _Solver>::m_vertexNum];",
			"            std::copy(CostFlowHelper<_Tp, _Fp, _Solver>::m_starts.begin(), CostFlowHelper<_Tp, _Fp, _Solver>::m_starts.begin() + CostFlowHelper<_Tp, _Fp, _Solver>::m_vertexNum, cursor);",
			"            std::vector<_Tp> res(m_low);",
			"            for (uint32_t index = 0; index < res.size(); index++)",
			"                if (auto &[from, to, cap, cost] = CostFlowHelper<_Tp, _Fp, _Solver>::m_rawEdges[index]; from != to) {",
			"                    res[index] += CostFlowHelper<_Tp, _Fp, _Solver>::m_edges[cursor[to]++].cap;",
			"                    cursor[from]++;",
			"                }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "CostFlow helper"
	},
	"dijkstra heap":{
		"prefix": "DIJK",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Dijkstra_heap {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp distance;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"            _Tp distance;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<_Tp> m_distances;",
			"        std::vector<uint32_t> m_from;",
			"        SiftHeap<SiftGetter<std::vector<_Tp>>, std::greater<_Tp>> m_heap;",
			"        uint32_t m_vertexNum;",
			"        _Tp m_infiniteDistance;",
			"        Dijkstra_heap(uint32_t __vertexNum, uint32_t __edgeNum, _Tp __infiniteDistance = std::numeric_limits<_Tp>::max() / 2) : m_starts(__vertexNum + 1, 0), m_distances(__vertexNum, __infiniteDistance), m_vertexNum(__vertexNum), m_infiniteDistance(__infiniteDistance), m_heap(__vertexNum, m_distances) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_rawEdges.push_back({__a, __b, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, distance] : m_rawEdges)",
			"                if (from != to) m_starts[from + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++)",
			"                if (auto &[from, to, distance] = m_rawEdges[index]; from != to) m_edges[cursor[from]++] = _Edge{index, to, distance};",
			"        }",
			"        void setDistance(uint32_t __i, _Tp __distance = 0) {",
			"            m_distances[__i] = __distance;",
			"            m_heap.push(__i);",
			"        }",
			"        template <bool _GetPath = false>",
			"        void calc() {",
			"            if constexpr (_GetPath) m_from.resize(m_vertexNum, -1);",
			"            while (m_heap.size()) {",
			"                uint32_t from = m_heap.top();",
			"                _Tp curDistance = m_distances[from];",
			"                m_heap.pop();",
			"                for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                    if (auto &[index, to, distance] = m_edges[cur]; chmin(m_distances[to], curDistance + distance)) {",
			"                        m_heap.push(to);",
			"                        if constexpr (_GetPath) m_from[to] = index;",
			"                    }",
			"            }",
			"        }",
			"        std::vector<uint32_t> getPath_edge(uint32_t __target) const {",
			"            std::vector<uint32_t> path;",
			"            for (uint32_t cur = __target; ~m_from[cur]; cur = m_rawEdges[m_from[cur]].from) path.push_back(m_from[cur]);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"        std::vector<uint32_t> getPath_vertex(uint32_t __target) const {",
			"            std::vector<uint32_t> path;",
			"            path.push_back(__target);",
			"            for (uint32_t cur = __target; ~m_from[cur];) path.push_back(cur = m_rawEdges[m_from[cur]].from);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"    };",
			"}",
		],
		"description": "dijkstra heap"
	},
	"dijkstra naive":{
		"prefix": "DIJK",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Dijkstra_naive {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp distance;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"            _Tp distance;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<_Tp> m_distances;",
			"        std::vector<uint32_t> m_from;",
			"        uint32_t m_vertexNum;",
			"        _Tp m_infiniteDistance;",
			"        Dijkstra_naive(uint32_t __vertexNum, uint32_t __edgeNum, _Tp __infiniteDistance = std::numeric_limits<_Tp>::max() / 2) : m_starts(__vertexNum + 1, 0), m_distances(__vertexNum, __infiniteDistance), m_vertexNum(__vertexNum), m_infiniteDistance(__infiniteDistance) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_rawEdges.push_back({__a, __b, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, distance] : m_rawEdges)",
			"                if (from != to) m_starts[from + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++)",
			"                if (auto &[from, to, distance] = m_rawEdges[index]; from != to) m_edges[cursor[from]++] = _Edge{index, to, distance};",
			"        }",
			"        void setDistance(uint32_t __i, _Tp __distance = 0) { m_distances[__i] = __distance; }",
			"        template <bool _GetPath = false>",
			"        void calc() {",
			"            if constexpr (_GetPath) m_from.resize(m_vertexNum, -1);",
			"            std::vector<bool> visit(m_vertexNum, false);",
			"            while (true) {",
			"                uint32_t lastUpdate = -1;",
			"                _Tp lastUpdateDistance = m_infiniteDistance;",
			"                for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                    if (!visit[i] && chmin(lastUpdateDistance, m_distances[i])) lastUpdate = i;",
			"                if (lastUpdate == -1) break;",
			"                visit[lastUpdate] = true;",
			"                for (uint32_t cur = m_starts[lastUpdate], end = m_starts[lastUpdate + 1]; cur < end; cur++)",
			"                    if (auto &[index, to, distance] = m_edges[cur]; chmin(m_distances[to], lastUpdateDistance + distance)) {",
			"                        if constexpr (_GetPath) m_from[to] = index;",
			"                    }",
			"            }",
			"        }",
			"        std::vector<uint32_t> getPath_edge(uint32_t __target) const {",
			"            std::vector<uint32_t> path;",
			"            for (uint32_t cur = __target; ~m_from[cur]; cur = m_rawEdges[m_from[cur]].from) path.push_back(m_from[cur]);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"        std::vector<uint32_t> getPath_vertex(uint32_t __target) const {",
			"            std::vector<uint32_t> path;",
			"            path.push_back(__target);",
			"            for (uint32_t cur = __target; ~m_from[cur];) path.push_back(cur = m_rawEdges[m_from[cur]].from);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"    };",
			"}",
		],
		"description": "dijkstra naive"
	},
	"dinic":{
		"prefix": "DINIC",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Dinic {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        Dinic(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap) { m_rawEdges.push_back({__a, __b, __cap}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{to, cursor[to], cap};",
			"                    m_edges[cursor[to]++] = _Edge{from, cursor[from]++, 0};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        _Tp calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            uint32_t queue[m_vertexNum], depth[m_vertexNum], it[m_vertexNum], end[m_vertexNum];",
			"            _Tp res = 0;",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) end[i] = m_starts[i + 1];",
			"            auto dfs = [&](auto self, uint32_t i, _Tp _cap) {",
			"                if (i == __target || !_cap) return _cap;",
			"                _Tp flow = 0, f;",
			"                for (uint32_t &cur = it[i]; cur != end[i]; cur++)",
			"                    if (auto &[to, rev, cap] = m_edges[cur]; depth[i] + 1 == depth[to] && (f = self(self, to, std::min(_cap, cap))))",
			"                        if (flow += f, _cap -= f, cap -= f, m_edges[rev].cap += f; !_cap) break;",
			"                return flow;",
			"            };",
			"            while (true) {",
			"                std::fill(depth, depth + m_vertexNum, -1);",
			"                uint32_t head = 0, tail = 0;",
			"                depth[__source] = 0;",
			"                queue[tail++] = __source;",
			"                while (head < tail)",
			"                    for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap] = m_edges[cur]; cap && chmin(depth[to], depth[from] + 1)) queue[tail++] = to;",
			"                if (!~depth[__target]) break;",
			"                for (uint32_t i = 0; i < m_vertexNum; i++) it[i] = m_starts[i];",
			"                while (_Tp flow = dfs(dfs, __source, __infiniteCap)) res += flow;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "dinic"
	},
	"dinic mcmf":{
		"prefix": "DINIC",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct Dinic_mcmf {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"            _Fp cost;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            _Fp cost;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        Dinic_mcmf(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap, _Fp __cost) { m_rawEdges.push_back({__a, __b, __cap, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{to, cursor[to], cap, cost};",
			"                    m_edges[cursor[to]++] = _Edge{from, cursor[from]++, 0, -cost};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        std::pair<_Tp, _Fp> calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2, _Fp __infiniteCost = std::numeric_limits<_Fp>::max() / 2) {",
			"            uint32_t queue[m_vertexNum + 1], it[m_vertexNum], end[m_vertexNum], head = 0, tail = 0;",
			"            _Tp totalFlow = 0;",
			"            _Fp costs[m_vertexNum], totalCost = 0;",
			"            std::vector<bool> inQueue(m_vertexNum, false);",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) end[i] = m_starts[i + 1];",
			"            auto dfs = [&](auto self, uint32_t i, _Tp _cap) {",
			"                if (i == __target || !_cap) return _cap;",
			"                inQueue[i] = true;",
			"                _Tp flow = 0, f;",
			"                for (uint32_t &cur = it[i]; cur != end[i]; cur++)",
			"                    if (auto &[to, rev, cap, cost] = m_edges[cur]; !inQueue[to] && costs[i] + cost == costs[to] && (f = self(self, to, std::min(_cap, cap))))",
			"                        if (flow += f, _cap -= f, cap -= f, m_edges[rev].cap += f; !_cap) break;",
			"                inQueue[i] = false;",
			"                return flow;",
			"            };",
			"            while (true) {",
			"                std::fill(costs, costs + m_vertexNum, __infiniteCost);",
			"                costs[__source] = 0;",
			"                queue[tail++] = __source;",
			"                if (tail == m_vertexNum + 1) tail = 0;",
			"                inQueue[__source] = true;",
			"                while (head != tail) {",
			"                    uint32_t from = queue[head++];",
			"                    if (head == m_vertexNum + 1) head = 0;",
			"                    inQueue[from] = false;",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap, cost] = m_edges[cur]; cap && chmin(costs[to], costs[from] + cost) && !inQueue[to]) {",
			"                            queue[tail++] = to;",
			"                            if (tail == m_vertexNum + 1) tail = 0;",
			"                            inQueue[to] = true;",
			"                        }",
			"                }",
			"                if (costs[__target] == __infiniteCost) break;",
			"                for (uint32_t i = 0; i < m_vertexNum; i++) it[i] = m_starts[i];",
			"                _Tp flow = 0;",
			"                while (_Tp f = dfs(dfs, __source, __infiniteCap)) flow += f;",
			"                totalFlow += flow;",
			"                totalCost += flow * costs[__target];",
			"            }",
			"            return {totalFlow, totalCost};",
			"        }",
			"    };",
			"}",
		],
		"description": "dinic mcmf"
	},
	"edmonds":{
		"prefix": "EDMONDS",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Edmonds {",
			"        struct _Edge {",
			"            uint32_t from, to;",
			"            _Tp cost;",
			"        };",
			"        std::vector<_Edge> m_edges;",
			"        uint32_t m_vertexNum;",
			"        _Tp m_totalCost;",
			"        std::vector<int> m_useCount;",
			"        Edmonds(uint32_t __vertexNum, uint32_t __edgeNum) : m_vertexNum(__vertexNum), m_totalCost(0) { m_edges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_edges.push_back({__a, __b, __cost}); }",
			"        template <bool _GetPath = false>",
			"        bool calc(uint32_t __root, _Tp __infiniteCost = std::numeric_limits<_Tp>::max() / 2) {",
			"            struct _relate {",
			"                uint32_t add, remove;",
			"            };",
			"            std::vector<_relate> relates;",
			"            uint32_t n = m_vertexNum, m = m_edges.size(), begin = 0, end = m, fromEdge[n], visit[n], id[n], loopCount;",
			"            m_edges.reserve(n * m);",
			"            _Tp in[n];",
			"            if constexpr (_GetPath) {",
			"                relates.reserve(n * m);",
			"                relates.resize(m);",
			"                m_useCount.reserve(n * m);",
			"                m_useCount.resize(m, 0);",
			"            }",
			"            while (true) {",
			"                std::fill(in, in + n, __infiniteCost);",
			"                std::fill(visit, visit + n, -1);",
			"                std::fill(id, id + n, -1);",
			"                loopCount = 0;",
			"                for (uint32_t i = begin; i < end; i++)",
			"                    if (auto &[from, to, cost] = m_edges[i]; chmin(in[to], cost)) fromEdge[to] = i;",
			"                visit[__root] = __root;",
			"                for (uint32_t i = 0; i < n; i++)",
			"                    if (i != __root) {",
			"                        if (in[i] == __infiniteCost) return false;",
			"                        if constexpr (_GetPath) m_useCount[fromEdge[i]]++;",
			"                        m_totalCost += in[i];",
			"                        uint32_t cur;",
			"                        for (cur = i; ~cur && !~visit[cur]; cur = m_edges[fromEdge[cur]].from) visit[cur] = i;",
			"                        if (~cur && visit[cur] == i) {",
			"                            for (; !~id[cur]; cur = m_edges[fromEdge[cur]].from) id[cur] = loopCount;",
			"                            loopCount++;",
			"                        }",
			"                    }",
			"                if (!loopCount) break;",
			"                for (uint32_t i = 0; i < n; i++)",
			"                    if (!~id[i]) id[i] = loopCount++;",
			"                for (uint32_t i = begin; i < end; i++)",
			"                    if (auto &[from, to, cost] = m_edges[i]; id[from] != id[to]) {",
			"                        m_edges.push_back({id[from], id[to], cost - in[to]});",
			"                        if constexpr (_GetPath) relates.push_back({i, fromEdge[to]});",
			"                    }",
			"                begin = end;",
			"                end = m_edges.size();",
			"                n = loopCount;",
			"                __root = id[__root];",
			"            };",
			"            if constexpr (_GetPath)",
			"                for (uint32_t i = end - 1; i >= m; i--) {",
			"                    m_useCount[relates[i].add] += m_useCount[i];",
			"                    m_useCount[relates[i].remove] -= m_useCount[i];",
			"                    m_useCount.pop_back();",
			"                }",
			"            return true;",
			"        }",
			"    };",
			"}",
		],
		"description": "edmonds"
	},
	"Edmonds Karp":{
		"prefix": "EK",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct EdmondsKarp {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        EdmondsKarp(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap) { m_rawEdges.push_back({__a, __b, __cap}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{to, cursor[to], cap};",
			"                    m_edges[cursor[to]++] = _Edge{from, cursor[from]++, 0};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        _Tp calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            uint32_t queue[m_vertexNum], fromEdge[m_vertexNum], prev[m_vertexNum];",
			"            _Tp res = 0, flow[m_vertexNum], f;",
			"            while (true) {",
			"                std::fill(flow, flow + m_vertexNum, 0);",
			"                uint32_t head = 0, tail = 0;",
			"                flow[__source] = __infiniteCap;",
			"                queue[tail++] = __source;",
			"                while (head < tail)",
			"                    for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap] = m_edges[cur]; cap && !flow[to]) {",
			"                            flow[to] = std::min(flow[from], cap);",
			"                            fromEdge[to] = cur;",
			"                            prev[to] = from;",
			"                            queue[tail++] = to;",
			"                        }",
			"                if (!flow[__target]) break;",
			"                res += f = flow[__target];",
			"                for (uint32_t cur = __target; cur != __source; cur = prev[cur]) {",
			"                    auto &[to, rev, cap] = m_edges[fromEdge[cur]];",
			"                    cap -= f;",
			"                    m_edges[rev].cap += f;",
			"                }",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Edmonds Karp"
	},
	"Edmonds Karp mcmf":{
		"prefix": "EK",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct EdmondsKarp_mcmf {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"            _Fp cost;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            _Fp cost;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        EdmondsKarp_mcmf(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap, _Fp __cost) { m_rawEdges.push_back({__a, __b, __cap, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{to, cursor[to], cap, cost};",
			"                    m_edges[cursor[to]++] = _Edge{from, cursor[from]++, 0, -cost};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        std::pair<_Tp, _Fp> calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2, _Fp __infiniteCost = std::numeric_limits<_Fp>::max() / 2) {",
			"            uint32_t queue[m_vertexNum + 1], fromEdge[m_vertexNum], prev[m_vertexNum], head = 0, tail = 0;",
			"            _Tp flow[m_vertexNum], f, totalFlow = 0;",
			"            _Fp costs[m_vertexNum], totalCost = 0;",
			"            std::vector<bool> inQueue(m_vertexNum, false);",
			"            while (true) {",
			"                while (head != tail) {",
			"                    inQueue[queue[head++]] = false;",
			"                    if (head == m_vertexNum + 1) head = 0;",
			"                }",
			"                std::fill(costs, costs + m_vertexNum, __infiniteCost);",
			"                costs[__source] = 0;",
			"                flow[__source] = __infiniteCap;",
			"                queue[tail++] = __source;",
			"                if (tail == m_vertexNum + 1) tail = 0;",
			"                inQueue[__source] = true;",
			"                while (head != tail) {",
			"                    uint32_t from = queue[head++];",
			"                    if (head == m_vertexNum + 1) head = 0;",
			"                    inQueue[from] = false;",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap, cost] = m_edges[cur]; cap && chmin(costs[to], costs[from] + cost)) {",
			"                            flow[to] = std::min(flow[from], cap);",
			"                            fromEdge[to] = cur;",
			"                            prev[to] = from;",
			"                            if (!inQueue[to]) {",
			"                                queue[tail++] = to;",
			"                                if (tail == m_vertexNum + 1) tail = 0;",
			"                                inQueue[to] = true;",
			"                            }",
			"                        }",
			"                }",
			"                if (costs[__target] == __infiniteCost) break;",
			"                totalFlow += f = flow[__target];",
			"                totalCost += f * costs[__target];",
			"                for (uint32_t cur = __target; cur != __source; cur = prev[cur]) {",
			"                    auto &[to, rev, cap, cost] = m_edges[fromEdge[cur]];",
			"                    cap -= f;",
			"                    m_edges[rev].cap += f;",
			"                }",
			"            }",
			"            return {totalFlow, totalCost};",
			"        }",
			"    };",
			"}",
		],
		"description": "Edmonds Karp mcmf"
	},
	"edmonds-tarjan":{
		"prefix": "EDMONDS",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Edmonds_tarjan {",
			"        struct _Edge {",
			"            uint32_t from, to;",
			"            _Tp cost;",
			"        };",
			"        std::vector<_Edge> m_edges;",
			"        uint32_t m_vertexNum;",
			"        _Tp m_totalCost;",
			"        std::vector<int> m_useCount;",
			"        Edmonds_tarjan(uint32_t __vertexNum, uint32_t __edgeNum) : m_vertexNum(__vertexNum), m_totalCost(0) { m_edges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_edges.push_back({__a, __b, __cost}); }",
			"        template <bool _GetPath = false>",
			"        bool calc(uint32_t __root, _Tp __infiniteCost = std::numeric_limits<_Tp>::max() / 2) {",
			"            struct _edge {",
			"                _Tp cost;",
			"                uint32_t index;",
			"                bool operator>(const _edge &other) const { return cost > other.cost; }",
			"            };",
			"            struct _heap {",
			"                std::vector<_edge> in_edges;",
			"                _Tp inc;",
			"                void push(const _edge &e) {",
			"                    in_edges.push_back(e);",
			"                    std::push_heap(in_edges.begin(), in_edges.end(), std::greater<_edge>());",
			"                }",
			"                void pop() {",
			"                    std::pop_heap(in_edges.begin(), in_edges.end(), std::greater<_edge>());",
			"                    in_edges.pop_back();",
			"                }",
			"                void join(_heap &other) {",
			"                    if (in_edges.size() < other.in_edges.size()) {",
			"                        std::swap(in_edges, other.in_edges);",
			"                        std::swap(inc, other.inc);",
			"                    }",
			"                    for (auto &[cost, from] : other.in_edges) push({cost + other.inc - inc, from});",
			"                }",
			"            } heap[m_vertexNum * 2];",
			"            UnionFind u(m_vertexNum * 2);",
			"            uint32_t parent[m_vertexNum * 2], visit[m_vertexNum * 2], fromEdge[m_vertexNum * 2], cnt;",
			"            for (uint32_t i = 0; i < m_vertexNum * 2; i++) heap[i].inc = 0;",
			"            for (uint32_t index = 0; index < m_edges.size(); index++) {",
			"                auto &[from, to, cost] = m_edges[index];",
			"                heap[to].push({cost, index});",
			"            }",
			"            std::fill(visit, visit + m_vertexNum * 2, -1);",
			"            if constexpr (_GetPath) {",
			"                std::iota(parent, parent + m_vertexNum * 2, 0);",
			"                std::fill(fromEdge, fromEdge + m_vertexNum * 2, -1);",
			"            }",
			"            visit[__root] = __root;",
			"            cnt = m_vertexNum;",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                if (uint32_t cur = i; !~visit[cur])",
			"                    while (true) {",
			"                        do {",
			"                            while (heap[cur].in_edges.size() && u.find(m_edges[heap[cur].in_edges.front().index].from) == cur) heap[cur].pop();",
			"                            if (heap[cur].in_edges.empty()) return false;",
			"                            visit[cur] = i;",
			"                            auto &[cost, index] = heap[cur].in_edges.front();",
			"                            m_totalCost += cost + heap[cur].inc;",
			"                            if constexpr (_GetPath) fromEdge[cur] = index;",
			"                            cur = u.find(m_edges[index].from);",
			"                        } while (!~visit[cur]);",
			"                        if (visit[cur] != i) break;",
			"                        uint32_t it = cur;",
			"                        do {",
			"                            auto [cost, index] = heap[it].in_edges.front();",
			"                            heap[it].pop();",
			"                            heap[it].inc = -cost;",
			"                            heap[cnt].join(heap[it]);",
			"                            u.uniteTo(it, cnt);",
			"                            if constexpr (_GetPath) parent[it] = cnt;",
			"                            it = u.find(m_edges[index].from);",
			"                        } while (it != cnt);",
			"                        cur = cnt++;",
			"                    }",
			"            if constexpr (_GetPath) {",
			"                m_useCount.resize(m_edges.size(), false);",
			"                for (uint32_t i = cnt - 1; ~i; i--)",
			"                    if (visit[i] != __root) {",
			"                        m_useCount[fromEdge[i]] = true;",
			"                        for (uint32_t to = m_edges[fromEdge[i]].to; visit[to] != __root; to = parent[to]) visit[to] = __root;",
			"                    }",
			"            }",
			"            return true;",
			"        }",
			"    };",
			"}",
		],
		"description": "edmonds-tarjan"
	},
	"Euler path for dg":{
		"prefix": "EULER",
		"body": [
			"namespace OY {",
			"    struct EulerPath_dg {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<bool> m_appear;",
			"        std::vector<int> m_deg;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_appearCount;",
			"        uint32_t m_zeroDegCount;",
			"        EulerPath_dg(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum), m_appear(__vertexNum, false), m_deg(__vertexNum, 0) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_rawEdges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[from, to] : m_rawEdges) {",
			"                m_appear[from] = m_appear[to] = true;",
			"                m_starts[from + 1]++;",
			"                m_deg[from]--;",
			"                m_deg[to]++;",
			"            }",
			"            m_appearCount = std::count(m_appear.begin(), m_appear.end(), true);",
			"            m_zeroDegCount = std::count(m_deg.begin(), m_deg.end(), 0);",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++) {",
			"                auto &[from, to] = m_rawEdges[index];",
			"                m_edges[cursor[from]++] = _Edge{index, to};",
			"            }",
			"        }",
			"        bool isEulerGraph() const {",
			"            if (m_zeroDegCount != m_vertexNum) return false;",
			"            uint32_t queue[m_appearCount], head = 0, tail = 0;",
			"            std::vector<bool> visit(m_vertexNum, false);",
			"            uint32_t i = std::find(m_appear.begin(), m_appear.end(), true) - m_appear.begin();",
			"            visit[i] = true;",
			"            queue[tail++] = i;",
			"            while (head < tail)",
			"                for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                    if (auto &[index, to] = m_edges[cur]; !visit[to]) {",
			"                        visit[to] = true;",
			"                        queue[tail++] = to;",
			"                    }",
			"            return tail == m_appearCount;",
			"        }",
			"        uint32_t getHalfEulerSource() const {",
			"            if (m_zeroDegCount + 2 < m_vertexNum) return -1;",
			"            uint32_t i = 0;",
			"            while (i < m_appear.size() && (!m_appear[i] || m_deg[i] == 0)) i++;",
			"            if (i == m_appear.size()) i = std::find(m_appear.begin(), m_appear.end(), true) - m_appear.begin();",
			"            if (m_deg[i] < -1) return -1;",
			"            uint32_t queue[m_appearCount], head = 0, tail = 0;",
			"            std::vector<bool> visit(m_vertexNum, false);",
			"            visit[i] = true;",
			"            queue[tail++] = i;",
			"            while (head < tail)",
			"                for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                    if (auto &[index, to] = m_edges[cur]; !visit[to]) {",
			"                        visit[to] = true;",
			"                        queue[tail++] = to;",
			"                    }",
			"            return tail == m_appearCount ? i : -1;",
			"        }",
			"        template <bool _EdgePath>",
			"        std::vector<uint32_t> getPath(uint32_t __source) const {",
			"            uint32_t it[m_vertexNum], end[m_vertexNum];",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                it[i] = m_starts[i];",
			"                end[i] = m_starts[i + 1];",
			"            }",
			"            std::vector<uint32_t> path;",
			"            path.reserve(_EdgePath ? m_edges.size() : m_edges.size() + 1);",
			"            auto dfs = [&](auto self, uint32_t cur, uint32_t from) -> void {",
			"                while (it[cur] != end[cur]) {",
			"                    auto &[index, to] = m_edges[it[cur]++];",
			"                    self(self, to, index);",
			"                }",
			"                if constexpr (!_EdgePath)",
			"                    path.push_back(cur);",
			"                else {",
			"                    if (~from) path.push_back(from);",
			"                }",
			"            };",
			"            dfs(dfs, __source, -1);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"        std::vector<uint32_t> getPath_edge(uint32_t __source) const { return getPath<true>(__source); }",
			"        std::vector<uint32_t> getPath_vertex(uint32_t __source) const { return getPath<false>(__source); }",
			"    };",
			"}",
		],
		"description": "Euler path for directed graph"
	},
	"Euler path for udg":{
		"prefix": "EULER",
		"body": [
			"namespace OY {",
			"    struct EulerPath_udg {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<bool> m_appear;",
			"        std::vector<int> m_deg;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_appearCount;",
			"        uint32_t m_zeroDegCount;",
			"        EulerPath_udg(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum), m_appear(__vertexNum, false), m_deg(__vertexNum, 0) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_rawEdges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[from, to] : m_rawEdges) {",
			"                m_appear[from] = m_appear[to] = true;",
			"                m_starts[from + 1]++;",
			"                if (from != to) m_starts[to + 1]++;",
			"                m_deg[from] ^= 1;",
			"                m_deg[to] ^= 1;",
			"            }",
			"            m_appearCount = std::count(m_appear.begin(), m_appear.end(), true);",
			"            m_zeroDegCount = std::count(m_deg.begin(), m_deg.end(), 0);",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++) {",
			"                auto &[from, to] = m_rawEdges[index];",
			"                m_edges[cursor[from]++] = _Edge{index, to};",
			"                if (from != to) m_edges[cursor[to]++] = _Edge{index, from};",
			"            }",
			"        }",
			"        bool isEulerGraph() const {",
			"            if (m_zeroDegCount != m_vertexNum) return false;",
			"            uint32_t queue[m_appearCount], head = 0, tail = 0;",
			"            std::vector<bool> visit(m_vertexNum, false);",
			"            uint32_t i = std::find(m_appear.begin(), m_appear.end(), true) - m_appear.begin();",
			"            visit[i] = true;",
			"            queue[tail++] = i;",
			"            while (head < tail)",
			"                for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                    if (auto &[index, to] = m_edges[cur]; !visit[to]) {",
			"                        visit[to] = true;",
			"                        queue[tail++] = to;",
			"                    }",
			"            return tail == m_appearCount;",
			"        }",
			"        uint32_t getHalfEulerSource() const {",
			"            if (m_zeroDegCount + 2 < m_vertexNum) return -1;",
			"            uint32_t i = 0;",
			"            while (i < m_appear.size() && (!m_appear[i] || m_deg[i] == 0)) i++;",
			"            if (i == m_appear.size()) i = std::find(m_appear.begin(), m_appear.end(), true) - m_appear.begin();",
			"            uint32_t queue[m_appearCount], head = 0, tail = 0;",
			"            std::vector<bool> visit(m_vertexNum, false);",
			"            visit[i] = true;",
			"            queue[tail++] = i;",
			"            while (head < tail)",
			"                for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                    if (auto &[index, to] = m_edges[cur]; !visit[to]) {",
			"                        visit[to] = true;",
			"                        queue[tail++] = to;",
			"                    }",
			"            return tail == m_appearCount ? i : -1;",
			"        }",
			"        template <bool _EdgePath>",
			"        std::vector<uint32_t> getPath(uint32_t __source) const {",
			"            uint32_t it[m_vertexNum], end[m_vertexNum];",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                it[i] = m_starts[i];",
			"                end[i] = m_starts[i + 1];",
			"            }",
			"            std::vector<uint32_t> path;",
			"            path.reserve(_EdgePath ? m_edges.size() : m_edges.size() + 1);",
			"            std::vector<bool> visit(m_rawEdges.size(), false);",
			"            auto dfs = [&](auto self, uint32_t cur, uint32_t from) -> void {",
			"                while (it[cur] != end[cur]) {",
			"                    auto &[index, to] = m_edges[it[cur]++];",
			"                    if (!visit[index]) {",
			"                        visit[index] = true;",
			"                        self(self, to, index);",
			"                    }",
			"                }",
			"                if constexpr (!_EdgePath)",
			"                    path.push_back(cur);",
			"                else {",
			"                    if (~from) path.push_back(from);",
			"                }",
			"            };",
			"            dfs(dfs, __source, -1);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"        std::vector<uint32_t> getPath_edge(uint32_t __source) const { return getPath<true>(__source); }",
			"        std::vector<uint32_t> getPath_vertex(uint32_t __source) const { return getPath<false>(__source); }",
			"    };",
			"}",
		],
		"description": "Euler path for undirected graph"
	},
	"Flow Helper":{
		"prefix": "FLOW",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, template <typename...> typename _Solver>",
			"    struct FlowHelper : _Solver<_Tp> {",
			"        using _Solver<_Tp>::m_vertexNum, _Solver<_Tp>::m_starts, _Solver<_Tp>::m_rawEdges, _Solver<_Tp>::m_edges;",
			"        FlowHelper(uint32_t __vertexNum, uint32_t __edgeNum) : _Solver<_Tp>(__vertexNum, __edgeNum) {}",
			"        void recover() {",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    _Tp flow = m_edges[cursor[to]].cap;",
			"                    m_edges[cursor[to]++].cap = 0;",
			"                    m_edges[cursor[from]++].cap += flow;",
			"                }",
			"        }",
			"        std::vector<_Tp> getPath() const {",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            std::vector<_Tp> res;",
			"            res.reserve(m_rawEdges.size());",
			"            for (auto &[from, to, cap] : m_rawEdges) {",
			"                if (from != to) {",
			"                    res.push_back(m_edges[cursor[to]++].cap);",
			"                    cursor[from]++;",
			"                } else",
			"                    res.push_back(0);",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"    template <typename _Tp, template <typename...> typename _Solver>",
			"    struct BoundFlow : FlowHelper<_Tp, _Solver> {",
			"        std::vector<_Tp> m_delta, m_low;",
			"        _Tp m_initFlow, m_infiniteCap;",
			"        uint32_t m_source, m_target;",
			"        BoundFlow(uint32_t __vertexNum, uint32_t __edgeNum) : FlowHelper<_Tp, _Solver>(__vertexNum + 2, __edgeNum + __vertexNum + 1), m_delta(__vertexNum + 2, 0), m_initFlow(0) { m_low.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __lower, _Tp __upper) {",
			"            m_delta[__a] -= __lower;",
			"            m_delta[__b] += __lower;",
			"            m_low.push_back(__lower);",
			"            FlowHelper<_Tp, _Solver>::addEdge(__a, __b, __upper - __lower);",
			"        }",
			"        void setting(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            m_source = __source;",
			"            m_target = __target;",
			"            FlowHelper<_Tp, _Solver>::addEdge(__target, __source, m_infiniteCap = __infiniteCap);",
			"        }",
			"        void prepare() {",
			"            for (uint32_t i = 0; i < m_delta.size(); i++)",
			"                if (m_delta[i] > 0) {",
			"                    FlowHelper<_Tp, _Solver>::addEdge(m_delta.size() - 2, i, m_delta[i]);",
			"                    m_initFlow += m_delta[i];",
			"                } else if (m_delta[i] < 0)",
			"                    FlowHelper<_Tp, _Solver>::addEdge(i, m_delta.size() - 1, -m_delta[i]);",
			"            FlowHelper<_Tp, _Solver>::prepare();",
			"        }",
			"        bool isPossible() { return FlowHelper<_Tp, _Solver>::calc(FlowHelper<_Tp, _Solver>::m_vertexNum - 2, FlowHelper<_Tp, _Solver>::m_vertexNum - 1, m_infiniteCap) == m_initFlow; }",
			"        _Tp minFlow() { return m_infiniteCap - FlowHelper<_Tp, _Solver>::calc(m_target, m_source, m_infiniteCap); }",
			"        _Tp maxFlow() { return FlowHelper<_Tp, _Solver>::calc(m_source, m_target, m_infiniteCap); }",
			"        std::vector<_Tp> getPath() const {",
			"            uint32_t cursor[FlowHelper<_Tp, _Solver>::m_vertexNum];",
			"            std::copy(FlowHelper<_Tp, _Solver>::m_starts.begin(), FlowHelper<_Tp, _Solver>::m_starts.begin() + FlowHelper<_Tp, _Solver>::m_vertexNum, cursor);",
			"            std::vector<_Tp> res(m_low);",
			"            for (uint32_t index = 0; index < res.size(); index++)",
			"                if (auto &[from, to, cap] = FlowHelper<_Tp, _Solver>::m_rawEdges[index]; from != to) {",
			"                    res[index] += FlowHelper<_Tp, _Solver>::m_edges[cursor[to]++].cap;",
			"                    cursor[from]++;",
			"                }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Flow helper"
	},
	"Flow Matcher":{
		"prefix": "FLOW",
		"body": [
			"namespace OY {",
			"    template <template <typename...> typename _Solver = Dinic>",
			"    struct FlowMatcher : _Solver<int> {",
			"        std::vector<uint32_t> m_leftMatch, m_rightMatch;",
			"        uint32_t m_leftNum, m_rightNum;",
			"        FlowMatcher(uint32_t __leftNum, uint32_t __rightNum, uint32_t __edgeNum) : _Solver<int>(__leftNum + __rightNum + 2, __edgeNum + __leftNum + __rightNum), m_leftNum(__leftNum), m_rightNum(__rightNum) {}",
			"        void addEdge(uint32_t __a, uint32_t __b) { _Solver<int>::addEdge(__a, m_leftNum + __b, 1); }",
			"        void prepare() {",
			"            for (uint32_t i = 0; i < m_leftNum; i++) _Solver<int>::addEdge(m_leftNum + m_rightNum, i, 1);",
			"            for (uint32_t i = 0; i < m_rightNum; i++) _Solver<int>::addEdge(m_leftNum + i, m_leftNum + m_rightNum + 1, 1);",
			"            _Solver<int>::prepare();",
			"        }",
			"        template <bool _GetPath = false>",
			"        uint32_t calc() {",
			"            uint32_t res = _Solver<int>::calc(m_leftNum + m_rightNum, m_leftNum + m_rightNum + 1);",
			"            if constexpr (_GetPath) {",
			"                uint32_t cursor[_Solver<int>::m_vertexNum];",
			"                std::copy(_Solver<int>::m_starts.begin(), _Solver<int>::m_starts.begin() + _Solver<int>::m_vertexNum, cursor);",
			"                m_leftMatch.resize(m_leftNum, -1);",
			"                m_rightMatch.resize(m_rightNum, -1);",
			"                for (uint32_t i = 0, iend = _Solver<int>::m_rawEdges.size() - m_leftNum - m_rightNum; i < iend; i++) {",
			"                    auto &[from, to, cap] = _Solver<int>::m_rawEdges[i];",
			"                    if (_Solver<int>::m_edges[cursor[to]++].cap) {",
			"                        m_leftMatch[from] = to - m_leftNum;",
			"                        m_rightMatch[to - m_leftNum] = from;",
			"                    }",
			"                    cursor[from]++;",
			"                }",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
			"",
		],
		"description": "Flow Matcher"
	},
	"Floyd":{
		"prefix": "FLOYD",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Floyd {",
			"        std::vector<std::vector<_Tp>> m_distances;",
			"        uint32_t m_vertexNum;",
			"        Floyd(uint32_t __vertexNum, _Tp __infiniteDistance = std::numeric_limits<_Tp>::max() / 2) : m_distances(__vertexNum, std::vector<_Tp>(__vertexNum, __infiniteDistance)), m_vertexNum(__vertexNum) {",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) m_distances[i][i] = 0;",
			"        }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __distance) { chmin(m_distances[__a][__b], __distance); }",
			"        void calc() {",
			"            for (uint32_t k = 0; k < m_vertexNum; k++)",
			"                for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                    for (uint32_t j = 0; j < m_vertexNum; j++) chmin(m_distances[i][j], m_distances[i][k] + m_distances[k][j]);",
			"        }",
			"    };",
			"}",
		],
		"description": "Floyd"
	},
	"Floyd Warshall":{
		"prefix": "FLOYD",
		"body": [
			"namespace OY {",
			"    template <uint32_t _MAXN>",
			"    struct FloydWarshall {",
			"        std::vector<std::bitset<_MAXN>> m_canReach;",
			"        uint32_t m_vertexNum;",
			"        FloydWarshall(uint32_t __vertexNum) : m_canReach(__vertexNum), m_vertexNum(__vertexNum) {}",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_canReach[__a].set(__b); }",
			"        void calc() {",
			"            for (uint32_t k = 0; k < m_vertexNum; k++)",
			"                for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                    if (m_canReach[i][k]) m_canReach[i] |= m_canReach[k];",
			"        }",
			"    };",
			"}",
		],
		"description": "Floyd Warshall"
	},
	"Ford Fulkerson":{
		"prefix": "FF",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct FordFulkerson {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        FordFulkerson(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap) { m_rawEdges.push_back({__a, __b, __cap}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{to, cursor[to], cap};",
			"                    m_edges[cursor[to]++] = _Edge{from, cursor[from]++, 0};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        _Tp calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            std::vector<bool> visit(m_vertexNum, false);",
			"            _Tp res = 0;",
			"            auto dfs = [&](auto self, uint32_t i, _Tp _cap) {",
			"                if (i == __target || !_cap) return _cap;",
			"                visit[i] = true;",
			"                _Tp flow = 0, f;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (auto &[to, rev, cap] = m_edges[cur]; !visit[to] && (f = self(self, to, std::min(_cap, cap))))",
			"                        if (flow += f, _cap -= f, cap -= f, m_edges[rev].cap += f; !_cap) break;",
			"                return flow;",
			"            };",
			"            while (_Tp flow = dfs(dfs, __source, __infiniteCap)) {",
			"                res += flow;",
			"                std::fill(visit.begin(), visit.end(), false);",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Ford Fulkerson"
	},
	"Garbow":{
		"prefix": "GARBOW",
		"body": [
			"namespace OY {",
			"    struct Garbow {",
			"        struct _Edge {",
			"            uint32_t from, to;",
			"        };",
			"        std::vector<_Edge> m_rawEdges;",
			"        std::vector<uint32_t> m_adj;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<uint32_t> m_dfn;",
			"        std::vector<uint32_t> m_id;",
			"        std::vector<uint32_t> m_stack1;",
			"        std::vector<uint32_t> m_stack2;",
			"        std::vector<uint32_t> m_topo;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_dfnCount;",
			"        uint32_t m_idCount;",
			"        Garbow(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum), m_dfn(__vertexNum, -1), m_id(__vertexNum, -1), m_dfnCount(0), m_idCount(0) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_rawEdges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[from, to] : m_rawEdges) m_starts[from + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_adj.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++) {",
			"                auto &[from, to] = m_rawEdges[index];",
			"                m_adj[cursor[from]++] = to;",
			"            }",
			"        }",
			"        void calc() {",
			"            m_stack1.reserve(m_vertexNum);",
			"            m_stack2.reserve(m_vertexNum);",
			"            m_topo.reserve(m_vertexNum);",
			"            auto dfs = [this](auto self, uint32_t i) -> void {",
			"                m_stack1.push_back(i);",
			"                m_stack2.push_back(i);",
			"                m_dfn[i] = m_dfnCount++;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (uint32_t to = m_adj[cur]; !~m_dfn[to])",
			"                        self(self, to);",
			"                    else if (!~m_id[to])",
			"                        while (m_dfn[m_stack2.back()] > m_dfn[to]) m_stack2.pop_back();",
			"                if (m_stack2.back() == i) {",
			"                    m_stack2.pop_back();",
			"                    while (true) {",
			"                        uint32_t back = m_stack1.back();",
			"                        m_id[back] = m_idCount;",
			"                        m_topo.push_back(back);",
			"                        m_stack1.pop_back();",
			"                        if (back == i) break;",
			"                    }",
			"                    m_idCount++;",
			"                }",
			"            };",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                if (!~m_dfn[i]) dfs(dfs, i);",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) m_id[i] = m_idCount - 1 - m_id[i];",
			"            std::reverse(m_topo.begin(), m_topo.end());",
			"        }",
			"        std::vector<std::basic_string_view<uint32_t>> groups() const {",
			"            std::vector<std::basic_string_view<uint32_t>> res;",
			"            res.reserve(m_idCount);",
			"            for (int prev = 0, id = 0, cursor = 0; cursor < m_vertexNum; prev = cursor, id++) {",
			"                while (cursor < m_vertexNum && m_id[m_topo[cursor]] == id) cursor++;",
			"                res.emplace_back(m_topo.data() + prev, cursor - prev);",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Garbow"
	},
	"HLPP":{
		"prefix": "HLPP",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct HLPP {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        HLPP(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap) { m_rawEdges.push_back({__a, __b, __cap}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = {to, cursor[to], cap};",
			"                    m_edges[cursor[to]++] = {from, cursor[from]++, 0};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        _Tp calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            uint32_t queue[m_vertexNum], height[m_vertexNum], ex_next[m_vertexNum * 2], gap_prev[m_vertexNum * 2], gap_next[m_vertexNum * 2], ex_highest = 0, gap_highest = 0, discharge_count, it[m_vertexNum], end[m_vertexNum];",
			"            _Tp ex[m_vertexNum];",
			"            auto ex_insert = [&](uint32_t i, uint32_t h) {",
			"                ex_next[i] = ex_next[m_vertexNum + h];",
			"                ex_next[m_vertexNum + h] = i;",
			"                chmax(ex_highest, h);",
			"            };",
			"            auto gap_insert = [&](uint32_t i, uint32_t h) {",
			"                gap_prev[i] = m_vertexNum + h;",
			"                gap_next[i] = gap_next[m_vertexNum + h];",
			"                gap_prev[gap_next[i]] = gap_next[gap_prev[i]] = i;",
			"                chmax(gap_highest, h);",
			"            };",
			"            auto gap_erase = [&](uint32_t i) {",
			"                gap_next[gap_prev[i]] = gap_next[i];",
			"                gap_prev[gap_next[i]] = gap_prev[i];",
			"            };",
			"            auto ex_add = [&](uint32_t i, _Tp f) {",
			"                ex[i] += f;",
			"                if (ex[i] == f) ex_insert(i, height[i]);",
			"            };",
			"            auto ex_remove = [&](uint32_t i, _Tp f) { ex[i] -= f; };",
			"            auto update_height = [&](uint32_t i, uint32_t h) {",
			"                if (~height[i]) gap_erase(i);",
			"                height[i] = h;",
			"                if (~h) {",
			"                    gap_insert(i, h);",
			"                    if (ex[i] > 0) ex_insert(i, h);",
			"                }",
			"            };",
			"            auto global_relabel = [&] {",
			"                discharge_count = 0;",
			"                std::iota(ex_next + m_vertexNum, ex_next + m_vertexNum * 2, m_vertexNum);",
			"                std::iota(gap_prev + m_vertexNum, gap_prev + m_vertexNum * 2, m_vertexNum);",
			"                std::iota(gap_next + m_vertexNum, gap_next + m_vertexNum * 2, m_vertexNum);",
			"                std::fill(height, height + m_vertexNum, -1);",
			"                height[__target] = 0;",
			"                uint32_t head = 0, tail = 0;",
			"                queue[tail++] = __target;",
			"                while (head < tail)",
			"                    for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap] = m_edges[cur]; m_edges[rev].cap && height[to] > height[from] + 1) {",
			"                            update_height(to, height[from] + 1);",
			"                            queue[tail++] = to;",
			"                        }",
			"            };",
			"            auto push = [&](uint32_t from, uint32_t to, uint32_t rev, _Tp &cap, _Tp f) {",
			"                ex_remove(from, f);",
			"                ex_add(to, f);",
			"                cap -= f;",
			"                m_edges[rev].cap += f;",
			"            };",
			"            auto discharge = [&](uint32_t i) {",
			"                uint32_t h = m_vertexNum;",
			"                uint32_t pos = it[i];",
			"                for (uint32_t &cur = it[i]; cur < end[i]; cur++)",
			"                    if (auto &[to, rev, cap] = m_edges[cur]; cap) {",
			"                        if (height[i] == height[to] + 1) {",
			"                            push(i, to, rev, cap, std::min(ex[i], cap));",
			"                            if (!ex[i]) return;",
			"                        } else",
			"                            chmin(h, height[to]);",
			"                    }",
			"                it[i] = m_starts[i];",
			"                for (uint32_t &cur = it[i]; cur < pos; cur++)",
			"                    if (auto &[to, rev, cap] = m_edges[cur]; cap) {",
			"                        if (height[i] == height[to] + 1) {",
			"                            push(i, to, rev, cap, std::min(ex[i], cap));",
			"                            if (!ex[i]) return;",
			"                        } else",
			"                            chmin(h, height[to]);",
			"                    }",
			"                discharge_count++;",
			"                if (gap_next[gap_next[m_vertexNum + height[i]]] < m_vertexNum)",
			"                    update_height(i, h == m_vertexNum ? -1 : h + 1);",
			"                else {",
			"                    uint32_t oldh = height[i];",
			"                    for (h = oldh; h <= gap_highest; h++)",
			"                        while (gap_next[m_vertexNum + h] < m_vertexNum) {",
			"                            uint32_t j = gap_next[m_vertexNum + h];",
			"                            height[j] = -1;",
			"                            gap_erase(j);",
			"                        }",
			"                    gap_highest = oldh - 1;",
			"                }",
			"            };",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) it[i] = m_starts[i];",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) end[i] = m_starts[i + 1];",
			"            std::fill(ex, ex + m_vertexNum, 0);",
			"            global_relabel();",
			"            ex_add(__source, __infiniteCap);",
			"            ex_remove(__target, __infiniteCap);",
			"            while (~ex_highest) {",
			"                while (true) {",
			"                    uint32_t i = ex_next[m_vertexNum + ex_highest];",
			"                    if (i >= m_vertexNum) break;",
			"                    ex_next[m_vertexNum + ex_highest] = ex_next[i];",
			"                    if (height[i] != ex_highest) continue;",
			"                    discharge(i);",
			"                    if (discharge_count >= 4 * m_vertexNum) global_relabel();",
			"                }",
			"                ex_highest--;",
			"            }",
			"            return ex[__target] + __infiniteCap;",
			"        }",
			"    };",
			"}",
		],
		"description": "HLPP"
	},
	"HopcroftKarp":{
		"prefix": "HK",
		"body": [
			"namespace OY {",
			"    struct HopcroftKarp {",
			"        struct _Edge {",
			"            uint32_t a, b;",
			"        };",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_adj, m_starts, m_leftMatch, m_rightMatch;",
			"        uint32_t m_leftNum, m_rightNum;",
			"        HopcroftKarp(uint32_t __leftNum, uint32_t __rightNum, uint32_t __edgeNum) : m_starts(__leftNum + 1), m_leftNum(__leftNum), m_rightNum(__rightNum) { m_edges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_edges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[a, b] : m_edges) m_starts[a + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_adj.resize(m_starts.back());",
			"            uint32_t cursor[m_leftNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_leftNum, cursor);",
			"            for (uint32_t index = 0; index < m_edges.size(); index++) {",
			"                auto &[a, b] = m_edges[index];",
			"                m_adj[cursor[a]++] = b;",
			"            }",
			"        }",
			"        uint32_t calc() {",
			"            std::vector<uint32_t> dist(m_leftNum), queue(m_leftNum), visit(m_leftNum, -1);",
			"            uint32_t dfn = 0, res = 0;",
			"            auto bfs = [&] {",
			"                std::fill_n(dist.data(), m_leftNum, -1);",
			"                uint32_t head = 0, tail = 0;",
			"                for (uint32_t a = 0; a < m_leftNum; a++)",
			"                    if (!~m_leftMatch[a]) dist[a] = 0, queue[tail++] = a;",
			"                while (head < tail)",
			"                    for (uint32_t a = queue[head++], cur = m_starts[a], end = m_starts[a + 1]; cur < end; cur++)",
			"                        if (uint32_t a2 = m_rightMatch[m_adj[cur]]; ~a2 && chmin(dist[a2], dist[a] + 1)) queue[tail++] = a2;",
			"            };",
			"            auto dfs = [&](auto &&self, uint32_t a) {",
			"                visit[a] = dfn;",
			"                for (uint32_t cur = m_starts[a], end = m_starts[a + 1]; cur < end; cur++)",
			"                    if (uint32_t b = m_adj[cur]; !~m_rightMatch[b]) {",
			"                        m_rightMatch[b] = a;",
			"                        m_leftMatch[a] = b;",
			"                        return true;",
			"                    }",
			"                for (uint32_t cur = m_starts[a], end = m_starts[a + 1]; cur < end; cur++)",
			"                    if (uint32_t b = m_adj[cur]; visit[m_rightMatch[b]] != dfn && dist[m_rightMatch[b]] == dist[a] + 1 && self(self, m_rightMatch[b])) {",
			"                        m_rightMatch[b] = a;",
			"                        m_leftMatch[a] = b;",
			"                        return true;",
			"                    }",
			"                return false;",
			"            };",
			"            m_leftMatch.resize(m_leftNum, -1);",
			"            m_rightMatch.resize(m_rightNum, -1);",
			"            while (true) {",
			"                bfs();",
			"                uint32_t augument = 0;",
			"                for (uint32_t a = 0; a < m_leftNum; a++)",
			"                    if (!~m_leftMatch[a] && dfs(dfs, a)) augument++;",
			"                if (!augument) break;",
			"                res += augument;",
			"                dfn++;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "HopcroftKarp"
	},
	"Hungarian":{
		"prefix": "HG",
		"body": [
			"namespace OY {",
			"    struct Hungarian {",
			"        struct _Edge {",
			"            uint32_t a, b;",
			"        };",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_adj, m_starts, m_leftMatch, m_rightMatch;",
			"        uint32_t m_leftNum, m_rightNum;",
			"        Hungarian(uint32_t __leftNum, uint32_t __rightNum, uint32_t __edgeNum) : m_starts(__leftNum + 1), m_leftNum(__leftNum), m_rightNum(__rightNum) { m_edges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_edges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[a, b] : m_edges) m_starts[a + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_adj.resize(m_starts.back());",
			"            uint32_t cursor[m_leftNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_leftNum, cursor);",
			"            for (uint32_t index = 0; index < m_edges.size(); index++) {",
			"                auto &[a, b] = m_edges[index];",
			"                m_adj[cursor[a]++] = b;",
			"            }",
			"        }",
			"        uint32_t calc() {",
			"            m_leftMatch.resize(m_leftNum, -1);",
			"            m_rightMatch.resize(m_rightNum, -1);",
			"            std::vector<uint32_t> visit(m_leftNum, -1);",
			"            uint32_t dfn = 0, res = 0;",
			"            auto dfs = [&](auto self, uint32_t a) {",
			"                visit[a] = dfn;",
			"                for (uint32_t cur = m_starts[a], end = m_starts[a + 1]; cur < end; cur++)",
			"                    if (uint32_t b = m_adj[cur]; !~m_rightMatch[b]) {",
			"                        m_rightMatch[b] = a;",
			"                        m_leftMatch[a] = b;",
			"                        return true;",
			"                    }",
			"                for (uint32_t cur = m_starts[a], end = m_starts[a + 1]; cur < end; cur++)",
			"                    if (uint32_t b = m_adj[cur]; visit[m_rightMatch[b]] != dfn && self(self, m_rightMatch[b])) {",
			"                        m_rightMatch[b] = a;",
			"                        m_leftMatch[a] = b;",
			"                        return true;",
			"                    }",
			"                return false;",
			"            };",
			"            while (true) {",
			"                uint32_t augument = 0;",
			"                for (uint32_t a = 0; a < m_leftNum; a++)",
			"                    if (!~m_leftMatch[a] && dfs(dfs, a)) augument++;",
			"                if (!augument) break;",
			"                res += augument;",
			"                dfn++;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Hungarian"
	},
	"ISAP":{
		"prefix": "ISAP",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct ISAP {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        ISAP(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap) { m_rawEdges.push_back({__a, __b, __cap}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{to, cursor[to], cap};",
			"                    m_edges[cursor[to]++] = _Edge{from, cursor[from]++, 0};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        _Tp calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            uint32_t queue[m_vertexNum], depth[m_vertexNum], head = 0, tail = 0, num[m_vertexNum + 1], point[m_vertexNum], prev[m_vertexNum], len = 0, it[m_vertexNum], end[m_vertexNum];",
			"            _Tp res = 0;",
			"            std::fill(depth, depth + m_vertexNum, m_vertexNum);",
			"            depth[__target] = 0;",
			"            queue[tail++] = __target;",
			"            while (head < tail)",
			"                for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                    if (auto &[to, rev, cap] = m_edges[cur]; m_edges[rev].cap && chmin(depth[to], depth[from] + 1)) queue[tail++] = to;",
			"            if (depth[__source] == m_vertexNum) return res;",
			"            std::fill(num, num + m_vertexNum + 1, 0);",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) num[depth[i]]++;",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) it[i] = m_starts[i];",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) end[i] = m_starts[i + 1];",
			"            point[len++] = __source;",
			"            while (depth[__source] < m_vertexNum)",
			"                if (uint32_t x = point[len - 1]; x == __target) {",
			"                    _Tp flow = __infiniteCap;",
			"                    for (uint32_t i = 1; i < len; i++) chmin(flow, m_edges[prev[i]].cap);",
			"                    for (uint32_t i = 1; i < len; i++) {",
			"                        auto &[to, rev, cap] = m_edges[prev[i]];",
			"                        cap -= flow;",
			"                        m_edges[rev].cap += flow;",
			"                    }",
			"                    res += flow;",
			"                    len = 1;",
			"                } else {",
			"                    for (uint32_t &cur = it[x]; cur != end[x]; cur++)",
			"                        if (auto &[to, rev, cap] = m_edges[cur]; cap && depth[x] == depth[to] + 1) {",
			"                            point[len] = to;",
			"                            prev[len++] = cur;",
			"                            break;",
			"                        }",
			"                    if (x == point[len - 1]) {",
			"                        if (!--num[depth[x]]) break;",
			"                        depth[x] = m_vertexNum;",
			"                        for (uint32_t cur = m_starts[x], end = m_starts[x + 1]; cur < end; cur++)",
			"                            if (auto &[to, rev, cap] = m_edges[cur]; cap) chmin(depth[x], depth[to] + 1);",
			"                        num[depth[x]]++;",
			"                        it[x] = m_starts[x];",
			"                        if (len > 1) len--;",
			"                    }",
			"                }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "ISAP"
	},
	"Johnson":{
		"prefix": "JOHNSON",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Johnson {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp distance;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"            _Tp distance;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        _Tp m_infiniteDistance;",
			"        std::vector<std::vector<_Tp>> m_distances;",
			"        Johnson(uint32_t __vertexNum, uint32_t __edgeNum, _Tp __infiniteDistance = std::numeric_limits<_Tp>::max() / 2) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum), m_infiniteDistance(__infiniteDistance) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __distance) { m_rawEdges.push_back({__a, __b, __distance}); }",
			"        void prepare() {",
			"            for (auto &[from, to, distance] : m_rawEdges) m_starts[from + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++) {",
			"                auto &[from, to, distance] = m_rawEdges[index];",
			"                m_edges[cursor[from]++] = _Edge{index, to, distance};",
			"            }",
			"        }",
			"        bool calc() {",
			"            std::vector<_Tp> spfaDistance(m_vertexNum, 0);",
			"            std::queue<uint32_t> spfaQueue;",
			"            std::vector<bool> spfaInQueue(m_vertexNum, true);",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) spfaQueue.push(i);",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                for (uint32_t len = spfaQueue.size(); len--;) {",
			"                    uint32_t from = spfaQueue.front();",
			"                    spfaQueue.pop();",
			"                    spfaInQueue[from] = false;",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[index, to, distance] = m_edges[cur]; chmin(spfaDistance[to], spfaDistance[from] + distance) && !spfaInQueue[to]) {",
			"                            spfaQueue.push(to);",
			"                            spfaInQueue[to] = true;",
			"                        }",
			"                }",
			"            if (spfaQueue.size()) return false;",
			"            for (uint32_t from = 0; from < m_vertexNum; from++)",
			"                for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++) {",
			"                    auto &[index, to, distance] = m_edges[cur];",
			"                    distance += spfaDistance[from] - spfaDistance[to];",
			"                }",
			"            m_distances.reserve(m_vertexNum);",
			"            std::vector<_Tp> distances(m_vertexNum);",
			"            SiftHeap<SiftGetter<std::vector<_Tp>>, std::greater<_Tp>> m_heap(m_vertexNum, distances);",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                std::fill(distances.begin(), distances.end(), m_infiniteDistance);",
			"                distances[i] = 0;",
			"                m_heap.push(i);",
			"                while (m_heap.size()) {",
			"                    uint32_t from = m_heap.top();",
			"                    _Tp curDistance = distances[from];",
			"                    m_heap.pop();",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[index, to, distance] = m_edges[cur]; chmin(distances[to], curDistance + distance)) m_heap.push(to);",
			"                }",
			"                for (uint32_t j = 0; j < m_vertexNum; j++)",
			"                    if (distances[j] < m_infiniteDistance) distances[j] -= spfaDistance[i] - spfaDistance[j];",
			"                m_distances.push_back(distances);",
			"            }",
			"            return true;",
			"        }",
			"    };",
			"}",
		],
		"description": "Johnson"
	},
	"Kosoraju":{
		"prefix": "KOSARAJU",
		"body": [
			"namespace OY {",
			"    struct Kosaraju {",
			"        struct _Edge {",
			"            uint32_t from, to;",
			"        };",
			"        std::vector<_Edge> m_rawEdges;",
			"        std::vector<uint32_t> m_adj;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<uint32_t> m_reversedAdjs;",
			"        std::vector<uint32_t> m_reversedStarts;",
			"        std::vector<uint32_t> m_stack;",
			"        std::vector<uint32_t> m_id;",
			"        std::vector<uint32_t> m_topo;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_idCount;",
			"        Kosaraju(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_reversedStarts(__vertexNum + 1, 0), m_vertexNum(__vertexNum), m_id(__vertexNum, 0), m_idCount(0) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_rawEdges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[from, to] : m_rawEdges) m_starts[from + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_adj.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++) {",
			"                auto &[from, to] = m_rawEdges[index];",
			"                m_adj[cursor[from]++] = to;",
			"            }",
			"            for (auto &[from, to] : m_rawEdges) m_reversedStarts[to + 1]++;",
			"            std::partial_sum(m_reversedStarts.begin(), m_reversedStarts.end(), m_reversedStarts.begin());",
			"            m_reversedAdjs.resize(m_reversedStarts.back());",
			"            std::copy(m_reversedStarts.begin(), m_reversedStarts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++) {",
			"                auto &[from, to] = m_rawEdges[index];",
			"                m_reversedAdjs[cursor[to]++] = from;",
			"            }",
			"        }",
			"        void calc() {",
			"            m_stack.reserve(m_vertexNum);",
			"            auto dfs = [this](auto self, uint32_t i) -> void {",
			"                m_id[i] = -1;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (uint32_t to = m_adj[cur]; !m_id[to]) self(self, to);",
			"                m_stack.push_back(i);",
			"            };",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                if (!m_id[i]) dfs(dfs, i);",
			"            m_topo.reserve(m_vertexNum);",
			"            uint32_t cursor = 0;",
			"            while (m_stack.size()) {",
			"                if (!~m_id[m_stack.back()]) {",
			"                    m_id[m_stack.back()] = m_idCount;",
			"                    m_topo.push_back(m_stack.back());",
			"                    do {",
			"                        for (uint32_t to = m_topo[cursor++], cur = m_reversedStarts[to], end = m_reversedStarts[to + 1]; cur < end; cur++)",
			"                            if (uint32_t from = m_reversedAdjs[cur]; !~m_id[from]) {",
			"                                m_id[from] = m_idCount;",
			"                                m_topo.push_back(from);",
			"                            }",
			"                    } while (cursor < m_topo.size());",
			"                    m_idCount++;",
			"                }",
			"                m_stack.pop_back();",
			"            }",
			"        }",
			"        std::vector<std::basic_string_view<uint32_t>> groups() const {",
			"            std::vector<std::basic_string_view<uint32_t>> res;",
			"            res.reserve(m_idCount);",
			"            for (int prev = 0, id = 0, cursor = 0; cursor < m_vertexNum; prev = cursor, id++) {",
			"                while (cursor < m_vertexNum && m_id[m_topo[cursor]] == id) cursor++;",
			"                res.emplace_back(m_topo.data() + prev, cursor - prev);",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Kosaraju"
	},
	"Kruskal":{
		"prefix": "KRUSKAL",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Kruskal {",
			"        struct _Edge {",
			"            uint32_t index, from, to;",
			"            _Tp cost;",
			"        };",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<bool> m_used;",
			"        UnionFind m_union;",
			"        uint32_t m_vertexNum;",
			"        _Tp m_totalCost;",
			"        Kruskal(uint32_t __vertexNum, uint32_t __edgeNum) : m_union(__vertexNum), m_vertexNum(__vertexNum), m_totalCost(0) { m_edges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_edges.push_back({uint32_t(m_edges.size()), __a, __b, __cost}); }",
			"        bool calc() {",
			"            m_used.resize(m_edges.size(), false);",
			"            std::sort(m_edges.begin(), m_edges.end(), [](const _Edge &x, const _Edge &y) { return x.cost < y.cost; });",
			"            for (auto [index, from, to, cost] : m_edges)",
			"                if (m_union.uniteBySize(from, to)) {",
			"                    m_used[index] = true;",
			"                    m_totalCost += cost;",
			"                    if (m_union.count() == 1) break;",
			"                }",
			"            return m_union.count() == 1;",
			"        }",
			"        _Tp totalCost() const { return m_totalCost; }",
			"    };",
			"}",
		],
		"description": "Kruskal"
	},
	"KuhnMunkres":{
		"prefix": "KM",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, uint32_t _MAXN>",
			"    struct KuhnMunkres {",
			"        _Tp m_values[_MAXN][_MAXN];",
			"        _Tp m_leftLabel[_MAXN];",
			"        _Tp m_rightLabel[_MAXN];",
			"        _Tp m_slack[_MAXN];",
			"        uint32_t m_leftMatch[_MAXN];",
			"        uint32_t m_rightMatch[_MAXN];",
			"        uint32_t m_leftNum;",
			"        uint32_t m_rightNum;",
			"        uint32_t m_maxNum;",
			"        _Tp m_infiniteValue;",
			"        KuhnMunkres(uint32_t __leftNum, uint32_t __rightNum, _Tp __initValue = 0, _Tp __infiniteValue = std::numeric_limits<_Tp>::max() / 2) : m_leftNum(__leftNum), m_rightNum(__rightNum), m_maxNum(std::max(__leftNum, __rightNum)), m_infiniteValue(__infiniteValue) {",
			"            for (uint32_t a = 0; a < m_maxNum; a++)",
			"                for (uint32_t b = 0; b < m_maxNum; b++) m_values[a][b] = __initValue;",
			"        }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __value) { chmax(m_values[__a][__b], __value); }",
			"        _Tp calc() {",
			"            static uint32_t s_from[_MAXN], s_queue[_MAXN], s_head, s_tail;",
			"            static bool s_leftVisit[_MAXN], s_rightVisit[_MAXN];",
			"            auto aug = [&](uint32_t a) {",
			"                if (~m_leftMatch[a]) {",
			"                    s_leftVisit[a] = true;",
			"                    s_queue[s_tail++] = m_leftMatch[a];",
			"                    s_rightVisit[m_leftMatch[a]] = true;",
			"                    return false;",
			"                }",
			"                while (~a) std::swap(a, m_rightMatch[m_leftMatch[a] = s_from[a]]);",
			"                return true;",
			"            };",
			"            auto bfs = [&](uint32_t start) {",
			"                _Tp tmp;",
			"                std::fill(m_slack, m_slack + m_maxNum, m_infiniteValue);",
			"                std::fill(s_leftVisit, s_leftVisit + m_maxNum, 0);",
			"                std::fill(s_rightVisit, s_rightVisit + m_maxNum, 0);",
			"                s_head = s_tail = 0;",
			"                s_queue[s_tail++] = start;",
			"                s_rightVisit[start] = true;",
			"                while (true) {",
			"                    while (s_head < s_tail)",
			"                        for (uint32_t a = 0, b = s_queue[s_head++]; a < m_maxNum; a++)",
			"                            if (!s_leftVisit[a] && m_slack[a] >= (tmp = m_leftLabel[a] + m_rightLabel[b] - m_values[a][b])) {",
			"                                if (s_from[a] = b; tmp)",
			"                                    m_slack[a] = tmp;",
			"                                else if (aug(a))",
			"                                    return;",
			"                            }",
			"                    tmp = m_infiniteValue;",
			"                    for (uint32_t a = 0; a < m_maxNum; a++)",
			"                        if (!s_leftVisit[a]) chmin(tmp, m_slack[a]);",
			"                    for (uint32_t a = 0; a < m_maxNum; a++) {",
			"                        if (s_leftVisit[a])",
			"                            m_leftLabel[a] += tmp;",
			"                        else",
			"                            m_slack[a] -= tmp;",
			"                        if (s_rightVisit[a]) m_rightLabel[a] -= tmp;",
			"                    }",
			"                    for (uint32_t a = 0; a < m_maxNum; a++)",
			"                        if (!s_leftVisit[a] && !m_slack[a] && aug(a)) return;",
			"                }",
			"            };",
			"            std::fill(m_leftMatch, m_leftMatch + m_maxNum, -1);",
			"            std::fill(m_rightMatch, m_rightMatch + m_maxNum, -1);",
			"            std::fill(m_rightLabel, m_rightLabel + m_maxNum, 0);",
			"            for (uint32_t a = 0; a < m_maxNum; a++) m_leftLabel[a] = *std::max_element(m_values[a], m_values[a] + m_maxNum);",
			"            for (uint32_t b = 0; b < m_maxNum; b++) bfs(b);",
			"            _Tp res = 0;",
			"            for (uint32_t a = 0; a < m_maxNum; a++) res += m_values[a][m_leftMatch[a]];",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "KM"
	},
	"MPM":{
		"prefix": "MPM",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct MPM {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"        };",
			"        struct _Edge {",
			"            uint32_t from, to, rev;",
			"            _Tp cap;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        MPM(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap) { m_rawEdges.push_back({__a, __b, __cap}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{from, to, cursor[to], cap};",
			"                    m_edges[cursor[to]++] = _Edge{to, from, cursor[from]++, 0};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        _Tp calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            _Tp res = 0, in_flow[m_vertexNum], out_flow[m_vertexNum], flow[m_vertexNum], ex[m_vertexNum];",
			"            uint32_t queue[m_vertexNum], depth[m_vertexNum], head, tail, in_prev[m_edges.size() + m_vertexNum], in_next[m_edges.size() + m_vertexNum], out_prev[m_edges.size() + m_vertexNum], out_next[m_edges.size() + m_vertexNum];",
			"            auto mapping = [&](uint32_t i) { return flow[i]; };",
			"            SiftHeap heap(m_vertexNum, mapping, std::greater<_Tp>{});",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) heap.m_heap.push_back(heap.m_pos[i] = i);",
			"            auto insert = [&](uint32_t e, uint32_t i, uint32_t prev[], uint32_t next[]) {",
			"                prev[e] = m_edges.size() + i;",
			"                next[e] = next[m_edges.size() + i];",
			"                prev[next[e]] = next[prev[e]] = e;",
			"            };",
			"            auto erase = [&](uint32_t e, uint32_t prev[], uint32_t next[]) {",
			"                next[prev[e]] = next[e];",
			"                prev[next[e]] = prev[e];",
			"            };",
			"            auto update_flow = [&](uint32_t i) {if (chmin(flow[i], std::min(in_flow[i], out_flow[i]))) heap.siftUp(i); };",
			"            auto remove_node = [&](uint32_t i) {",
			"                for (uint32_t index = in_next[m_edges.size() + i]; index < m_edges.size(); index = in_next[index]) {",
			"                    auto &[from, to, rev, cap] = m_edges[index];",
			"                    erase(index, out_prev, out_next);",
			"                    out_flow[from] -= cap;",
			"                    update_flow(from);",
			"                }",
			"                for (uint32_t index = out_next[m_edges.size() + i]; index < m_edges.size(); index = out_next[index]) {",
			"                    auto &[from, to, rev, cap] = m_edges[index];",
			"                    erase(index, in_prev, in_next);",
			"                    in_flow[to] -= cap;",
			"                    update_flow(to);",
			"                }",
			"            };",
			"            auto push = [&](uint32_t i, _Tp f, uint32_t end, bool forward) {",
			"                std::fill(ex, ex + m_vertexNum, 0);",
			"                ex[i] = f;",
			"                head = tail = 0;",
			"                queue[tail++] = i;",
			"                while (head < tail) {",
			"                    uint32_t cur = queue[head++];",
			"                    if (cur == end) break;",
			"                    auto &index = forward ? out_next[m_edges.size() + cur] : in_next[m_edges.size() + cur];",
			"                    for (_Tp must = ex[cur]; must;) {",
			"                        auto &[from, to, rev, cap] = m_edges[index];",
			"                        _Tp pushed = std::min(must, cap);",
			"                        out_flow[from] -= pushed;",
			"                        in_flow[to] -= pushed;",
			"                        update_flow(from);",
			"                        update_flow(to);",
			"                        uint32_t other = forward ? to : from;",
			"                        if (!ex[other]) queue[tail++] = other;",
			"                        ex[other] += pushed;",
			"                        cap -= pushed;",
			"                        m_edges[rev].cap += pushed;",
			"                        must -= pushed;",
			"                        if (cap) break;",
			"                        if (forward) {",
			"                            erase(index, in_prev, in_next);",
			"                            erase(index, out_prev, out_next);",
			"                        } else {",
			"                            erase(index, out_prev, out_next);",
			"                            erase(index, in_prev, in_next);",
			"                        }",
			"                    }",
			"                }",
			"            };",
			"            while (true) {",
			"                std::fill(depth, depth + m_vertexNum, -1);",
			"                head = tail = 0;",
			"                depth[__source] = 0;",
			"                queue[tail++] = __source;",
			"                while (head < tail && !~depth[__target])",
			"                    for (uint32_t from = queue[head++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[from, to, rev, cap] = m_edges[cur]; cap && chmin(depth[to], depth[from] + 1)) queue[tail++] = to;",
			"                if (!~depth[__target]) break;",
			"                std::fill(in_flow, in_flow + m_vertexNum, 0);",
			"                std::fill(out_flow, out_flow + m_vertexNum, 0);",
			"                for (uint32_t i = 0; i < m_vertexNum; i++) in_prev[m_edges.size() + i] = in_next[m_edges.size() + i] = out_prev[m_edges.size() + i] = out_next[m_edges.size() + i] = m_edges.size() + i;",
			"                for (uint32_t index = 0; index < m_edges.size(); index++)",
			"                    if (auto &[from, to, rev, cap] = m_edges[index]; cap && depth[from] + 1 == depth[to] && (depth[to] < depth[__target] || to == __target)) {",
			"                        insert(index, to, in_prev, in_next);",
			"                        insert(index, from, out_prev, out_next);",
			"                        in_flow[to] += cap;",
			"                        out_flow[from] += cap;",
			"                    }",
			"                in_flow[__source] = out_flow[__target] = __infiniteCap;",
			"                std::fill(flow, flow + m_vertexNum, __infiniteCap);",
			"                for (uint32_t i = 0; i < m_vertexNum; i++) update_flow(i);",
			"                while (true) {",
			"                    uint32_t critical = heap.top();",
			"                    if (flow[critical] == __infiniteCap) break;",
			"                    if (_Tp f = flow[critical]) {",
			"                        res += f;",
			"                        push(critical, f, __source, false);",
			"                        push(critical, f, __target, true);",
			"                    }",
			"                    flow[critical] = __infiniteCap;",
			"                    heap.siftDown(critical);",
			"                    remove_node(critical);",
			"                }",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "MPM"
	},
	"PP bucket":{
		"prefix": "PP",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct PP_bucket {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        PP_bucket(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap) { m_rawEdges.push_back({__a, __b, __cap}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = {to, cursor[to], cap};",
			"                    m_edges[cursor[to]++] = {from, cursor[from]++, 0};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        _Tp calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            uint32_t depth[m_vertexNum], prev[m_vertexNum * 2], next[m_vertexNum * 2], highest = 0;",
			"            _Tp ex[m_vertexNum];",
			"            auto insert = [&](uint32_t i, uint32_t d) {",
			"                prev[i] = m_vertexNum + d;",
			"                next[i] = next[m_vertexNum + d];",
			"                prev[next[i]] = next[prev[i]] = i;",
			"                chmax(highest, d);",
			"            };",
			"            auto erase = [&](uint32_t i) {",
			"                next[prev[i]] = next[i];",
			"                prev[next[i]] = prev[i];",
			"            };",
			"            auto ex_add = [&](uint32_t i, _Tp flow) {",
			"                ex[i] += flow;",
			"                if (ex[i] == flow) insert(i, depth[i]);",
			"            };",
			"            auto ex_remove = [&](uint32_t i, _Tp flow) {",
			"                ex[i] -= flow;",
			"                if (!ex[i]) erase(i);",
			"            };",
			"            auto relabel = [&](uint32_t i) {",
			"                erase(i);",
			"                depth[i] = m_vertexNum;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (auto &[to, rev, cap] = m_edges[cur]; cap) chmin(depth[i], depth[to] + 1);",
			"                if (depth[i] == m_vertexNum)",
			"                    ex[i] = 0;",
			"                else",
			"                    insert(i, depth[i]);",
			"            };",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) prev[m_vertexNum + i] = next[m_vertexNum + i] = m_vertexNum + i;",
			"            std::fill(depth, depth + m_vertexNum, 0);",
			"            depth[__source] = m_vertexNum - 1;",
			"            insert(__source, depth[__source]);",
			"            std::fill(ex, ex + m_vertexNum, 0);",
			"            ex[__source] = __infiniteCap;",
			"            ex[__target] = -__infiniteCap;",
			"            for (uint32_t height = highest; ~height;) {",
			"                while (true) {",
			"                    uint32_t first = next[m_vertexNum + height];",
			"                    if (first >= m_vertexNum || height != highest) break;",
			"                    _Tp &rest = ex[first], flow;",
			"                    for (uint32_t cur = m_starts[first], end = m_starts[first + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap] = m_edges[cur]; depth[first] == depth[to] + 1 && (flow = std::min(rest, cap))) {",
			"                            ex_remove(first, flow);",
			"                            ex_add(to, flow);",
			"                            cap -= flow;",
			"                            m_edges[rev].cap += flow;",
			"                        }",
			"                    if (rest > 0) relabel(first);",
			"                }",
			"                if (!chmax(height, highest)) height = --highest;",
			"            }",
			"            return ex[__target] + __infiniteCap;",
			"        }",
			"    };",
			"}",
		],
		"description": "PP bucket"
	},
	"PP heap":{
		"prefix": "PP",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct PP_heap {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        PP_heap(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap) { m_rawEdges.push_back({__a, __b, __cap}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = {to, cursor[to], cap};",
			"                    m_edges[cursor[to]++] = {from, cursor[from]++, 0};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        _Tp calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2) {",
			"            uint32_t depth[m_vertexNum];",
			"            _Tp ex[m_vertexNum];",
			"            auto self = [](uint32_t x) { return x; };",
			"            auto comp = [&](uint32_t x, uint32_t y) { return ex[y] > 0 && (ex[x] <= 0 || depth[x] < depth[y]); };",
			"            SiftHeap heap(m_vertexNum, self, comp);",
			"            auto ex_add = [&](uint32_t i, _Tp f) {",
			"                ex[i] += f;",
			"                if (ex[i] == f) heap.siftUp(i);",
			"            };",
			"            auto ex_remove = [&](uint32_t i, _Tp f) {",
			"                ex[i] -= f;",
			"                if (!ex[i]) heap.siftDown(i);",
			"            };",
			"            auto relabel = [&](uint32_t i) {",
			"                uint32_t old = depth[i];",
			"                depth[i] = m_vertexNum;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (auto &[to, rev, cap] = m_edges[cur]; cap) chmin(depth[i], depth[to] + 1);",
			"                if (depth[i] == m_vertexNum) {",
			"                    ex[i] = 0;",
			"                    heap.siftDown(i);",
			"                } else if (depth[i] < old)",
			"                    heap.siftDown(i);",
			"                else",
			"                    heap.siftUp(i);",
			"            };",
			"            std::fill(depth, depth + m_vertexNum, 0);",
			"            depth[__source] = m_vertexNum - 1;",
			"            std::fill(ex, ex + m_vertexNum, 0);",
			"            ex[__source] = __infiniteCap;",
			"            ex[__target] = -__infiniteCap;",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) heap.m_heap.push_back(heap.m_pos[i] = i);",
			"            heap.siftUp(__source);",
			"            heap.siftDown(__target);",
			"            while (ex[heap.top()] > 0) {",
			"                uint32_t i = heap.top();",
			"                _Tp &rest = ex[i], f;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (auto &[to, rev, cap] = m_edges[cur]; depth[i] == depth[to] + 1 && (f = std::min(rest, cap))) {",
			"                        ex_remove(i, f);",
			"                        ex_add(to, f);",
			"                        cap -= f;",
			"                        m_edges[rev].cap += f;",
			"                    }",
			"                if (rest > 0) relabel(i);",
			"            }",
			"            return ex[__target] + __infiniteCap;",
			"        }",
			"    };",
			"}",
		],
		"description": "PP heap"
	},
	"Primal Dual":{
		"prefix": "PD",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct PrimalDual_mcmf {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"            _Fp cost;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            _Fp cost;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        PrimalDual_mcmf(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap, _Fp __cost) { m_rawEdges.push_back({__a, __b, __cap, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{to, cursor[to], cap, cost};",
			"                    m_edges[cursor[to]++] = _Edge{from, cursor[from]++, 0, -cost};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        std::pair<_Tp, _Fp> calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2, _Fp __infiniteCost = std::numeric_limits<_Fp>::max() / 2) {",
			"            uint32_t spfaQueue[m_vertexNum + 1], fromEdge[m_vertexNum], prev[m_vertexNum], head = 0, tail = 0;",
			"            std::vector<bool> spfaInQueue(m_vertexNum, false);",
			"            _Tp flow[m_vertexNum], totalFlow = 0;",
			"            _Fp costs[m_vertexNum], spfaCosts[m_vertexNum], f, totalCost = 0;",
			"            std::fill(spfaCosts, spfaCosts + m_vertexNum, __infiniteCost);",
			"            spfaCosts[__source] = 0;",
			"            spfaQueue[tail++] = __source;",
			"            spfaInQueue[__source] = true;",
			"            while (head != tail) {",
			"                uint32_t from = spfaQueue[head++];",
			"                if (head == m_vertexNum + 1) head = 0;",
			"                spfaInQueue[from] = false;",
			"                for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                    if (auto &[to, rev, cap, cost] = m_edges[cur]; cap && chmin(spfaCosts[to], spfaCosts[from] + cost) && !spfaInQueue[to]) {",
			"                        spfaQueue[tail++] = to;",
			"                        if (tail == m_vertexNum + 1) tail = 0;",
			"                        spfaInQueue[to] = true;",
			"                    }",
			"            }",
			"            auto mapping = [&](uint32_t i) { return costs[i]; };",
			"            SiftHeap heap(m_vertexNum, mapping, std::greater<_Fp>{});",
			"            while (true) {",
			"                std::fill(costs, costs + m_vertexNum, __infiniteCost);",
			"                costs[__source] = 0;",
			"                flow[__source] = __infiniteCap;",
			"                heap.push(__source);",
			"                while (heap.size()) {",
			"                    uint32_t from = heap.top();",
			"                    heap.pop();",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap, cost] = m_edges[cur]; cap && chmin(costs[to], costs[from] + cost + spfaCosts[from] - spfaCosts[to])) {",
			"                            flow[to] = std::min(flow[from], cap);",
			"                            fromEdge[to] = cur;",
			"                            prev[to] = from;",
			"                            heap.push(to);",
			"                        }",
			"                }",
			"                if (costs[__target] == __infiniteCost) break;",
			"                for (uint32_t i = 0; i < m_vertexNum; i++) spfaCosts[i] += costs[i];",
			"                totalFlow += f = flow[__target];",
			"                totalCost += f * spfaCosts[__target];",
			"                for (uint32_t cur = __target; cur != __source; cur = prev[cur]) {",
			"                    auto &[to, rev, cap, cost] = m_edges[fromEdge[cur]];",
			"                    cap -= f;",
			"                    m_edges[rev].cap += f;",
			"                }",
			"            }",
			"            return {totalFlow, totalCost};",
			"        }",
			"    };",
			"}",
		],
		"description": "Primal dual"
	},
	"Prim heap":{
		"prefix": "PRIM",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Prim_heap {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cost;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"            _Tp cost;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<bool> m_used;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        Prim_heap(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_rawEdges.push_back({__a, __b, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++)",
			"                if (auto &[from, to, cost] = m_rawEdges[index]; from != to) {",
			"                    m_edges[cursor[from]++] = _Edge{index, to, cost};",
			"                    m_edges[cursor[to]++] = _Edge{index, from, cost};",
			"                }",
			"        }",
			"        bool calc(_Tp __infiniteCost = std::numeric_limits<_Tp>::max() / 2) {",
			"            m_used.resize(m_rawEdges.size(), false);",
			"            struct _edge {",
			"                uint32_t index;",
			"                _Tp cost;",
			"                bool operator<(const _edge &other) const { return cost < other.cost; }",
			"                bool operator>(const _edge &other) const { return cost > other.cost; }",
			"            } closest[m_vertexNum];",
			"            std::fill(closest, closest + m_vertexNum, _edge{uint32_t(-1), __infiniteCost});",
			"            auto mapping = [&](uint32_t i) { return closest[i]; };",
			"            SiftHeap heap(m_vertexNum, mapping, std::greater<_edge>{});",
			"            std::vector<bool> visit(m_vertexNum, false);",
			"            uint32_t lastUpdate = 0;",
			"            while (~lastUpdate) {",
			"                visit[lastUpdate] = true;",
			"                for (uint32_t cur = m_starts[lastUpdate], end = m_starts[lastUpdate + 1]; cur < end; cur++)",
			"                    if (auto [index, to, cost] = m_edges[cur]; !visit[to] && chmin(closest[to], _edge{index, cost})) heap.push(to);",
			"                if (heap.empty()) break;",
			"                m_used[closest[lastUpdate = heap.top()].index] = true;",
			"                heap.pop();",
			"            }",
			"            return !std::count(visit.begin(), visit.end(), false);",
			"        }",
			"        _Tp totalCost() const {",
			"            _Tp res = 0;",
			"            for (uint32_t index = 0; index < m_used.size(); index++)",
			"                if (m_used[index]) res += m_rawEdges[index].cost;",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Prim heap"
	},
	"Prim naive":{
		"prefix": "PRIM",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Prim_naive {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cost;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"            _Tp cost;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<bool> m_used;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        Prim_naive(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_rawEdges.push_back({__a, __b, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++)",
			"                if (auto &[from, to, cost] = m_rawEdges[index]; from != to) {",
			"                    m_edges[cursor[from]++] = _Edge{index, to, cost};",
			"                    m_edges[cursor[to]++] = _Edge{index, from, cost};",
			"                }",
			"        }",
			"        bool calc(_Tp __infiniteCost = std::numeric_limits<_Tp>::max() / 2) {",
			"            m_used.resize(m_rawEdges.size(), false);",
			"            struct _edge {",
			"                uint32_t index;",
			"                _Tp cost;",
			"                bool operator<(const _edge &other) const { return cost < other.cost; }",
			"            } closest[m_vertexNum];",
			"            std::fill(closest, closest + m_vertexNum, _edge{uint32_t(-1), __infiniteCost});",
			"            std::vector<bool> visit(m_vertexNum, false);",
			"            uint32_t lastUpdate = 0;",
			"            while (true) {",
			"                visit[lastUpdate] = true;",
			"                closest[lastUpdate] = _edge{uint32_t(-1), __infiniteCost};",
			"                for (uint32_t cur = m_starts[lastUpdate], end = m_starts[lastUpdate + 1]; cur < end; cur++) {",
			"                    auto &[index, to, cost] = m_edges[cur];",
			"                    if (!visit[to]) chmin(closest[to], _edge{index, cost});",
			"                }",
			"                lastUpdate = std::min_element(closest, closest + m_vertexNum) - closest;",
			"                if (!~closest[lastUpdate].index) break;",
			"                m_used[closest[lastUpdate].index] = true;",
			"            }",
			"            return !std::count(visit.begin(), visit.end(), false);",
			"        }",
			"        _Tp totalCost() const {",
			"            _Tp res = 0;",
			"            for (uint32_t index = 0; index < m_used.size(); index++)",
			"                if (m_used[index]) res += m_rawEdges[index].cost;",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Prim naive"
	},
	"Shrink scc":{
		"prefix": "SHRINK",
		"body": [
			"namespace OY {",
			"    template <typename _DG, template <typename...> typename _Solver = Tarjan_scc>",
			"    struct Shrink_scc {",
			"        _Solver<_DG> m_sol;",
			"        _DG m_newGraph;",
			"        Shrink_scc(_DG &__graph) : m_sol(__graph), m_newGraph(__graph.m_vertexNum, __graph.m_edgeNum) {",
			"            for (auto [index, from, to, value] : __graph.getEdgesInfo()) m_newGraph.addEdge(m_sol.m_id[from], m_sol.m_id[to], value);",
			"            m_newGraph.prepare();",
			"        }",
			"    };",
			"}",
		],
		"description": "Shrink scc"
	},
	"SPFA":{
		"prefix": "SPFA",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct SPFA {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp distance;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"            _Tp distance;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<_Tp> m_distances;",
			"        std::vector<uint32_t> m_from;",
			"        std::queue<uint32_t> m_queue;",
			"        std::vector<bool> m_inQueue;",
			"        uint32_t m_vertexNum;",
			"        _Tp m_infiniteDistance;",
			"        SPFA(uint32_t __vertexNum, uint32_t __edgeNum, _Tp __infiniteDistance = std::numeric_limits<_Tp>::max() / 2) : m_starts(__vertexNum + 1, 0), m_distances(__vertexNum, __infiniteDistance), m_inQueue(__vertexNum, false), m_vertexNum(__vertexNum), m_infiniteDistance(__infiniteDistance) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_rawEdges.push_back({__a, __b, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, distance] : m_rawEdges)m_starts[from + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++){",
			"                auto &[from, to, distance] = m_rawEdges[index];",
			"                m_edges[cursor[from]++] = _Edge{index, to, distance};",
			"            }",
			"        }",
			"        void setDistance(uint32_t __i, _Tp __distance = 0) {",
			"            m_distances[__i] = __distance;",
			"            m_queue.push(__i);",
			"            m_inQueue[__i] = true;",
			"        }",
			"        template <bool _GetPath = false>",
			"        bool calc() {",
			"            if constexpr (_GetPath) m_from.resize(m_vertexNum, -1);",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                for (uint32_t len = m_queue.size(); len--;) {",
			"                    uint32_t from = m_queue.front();",
			"                    m_queue.pop();",
			"                    m_inQueue[from] = false;",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[index, to, distance] = m_edges[cur]; chmin(m_distances[to], m_distances[from] + distance)) {",
			"                            if constexpr (_GetPath) m_from[to] = index;",
			"                            if (!m_inQueue[to]) {",
			"                                m_queue.push(to);",
			"                                m_inQueue[to] = true;",
			"                            }",
			"                        }",
			"                }",
			"            return m_queue.empty();",
			"        }",
			"        std::vector<uint32_t> getPath_edge(uint32_t __target) const {",
			"            std::vector<uint32_t> path;",
			"            for (uint32_t cur = __target; ~m_from[cur]; cur = m_rawEdges[m_from[cur]].from) path.push_back(m_from[cur]);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"        std::vector<uint32_t> getPath_vertex(uint32_t __target) const {",
			"            std::vector<uint32_t> path;",
			"            path.push_back(__target);",
			"            for (uint32_t cur = __target; ~m_from[cur];) path.push_back(cur = m_rawEdges[m_from[cur]].from);",
			"            std::reverse(path.begin(), path.end());",
			"            return path;",
			"        }",
			"    };",
			"}",
		],
		"description": "SPFA"
	},
	"steiner":{
		"prefix": "STEINER",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    struct Steiner {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cost;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"            _Tp cost;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<std::vector<_Tp>> m_trees;",
			"        std::vector<std::vector<uint32_t>> m_from;",
			"        uint32_t m_vertexNum;",
			"        _Tp m_infiniteCost;",
			"        _Tp m_minCost;",
			"        Steiner(uint32_t __vertexNum, uint32_t __edgeNum, _Tp __infiniteCost = std::numeric_limits<_Tp>::max() / 2) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum), m_infiniteCost(__infiniteCost) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) { m_rawEdges.push_back({__a, __b, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++)",
			"                if (auto &[from, to, cost] = m_rawEdges[index]; from != to) {",
			"                    m_edges[cursor[from]++] = _Edge{index, to, cost};",
			"                    m_edges[cursor[to]++] = _Edge{index, from, cost};",
			"                }",
			"        }",
			"        template <bool _GetPath = false>",
			"        bool calc_dijk(const std::vector<uint32_t> &__keys) {",
			"            m_trees.reserve(1 << __keys.size());",
			"            std::vector<_Tp> costs(m_vertexNum);",
			"            std::vector<uint32_t> froms;",
			"            if constexpr (_GetPath) {",
			"                m_from.reserve(1 << __keys.size());",
			"                froms.resize(m_vertexNum);",
			"            }",
			"            SiftHeap dijkstraHeap(m_vertexNum, costs, std::greater<_Tp>{});",
			"            for (uint32_t mask = 0; mask < 1 << __keys.size(); mask++) {",
			"                std::fill(costs.begin(), costs.end(), m_infiniteCost);",
			"                if constexpr (_GetPath) std::fill(froms.begin(), froms.end(), -1);",
			"                if (uint32_t i = std::__countr_zero(mask); std::__popcount(mask) == 1) costs[__keys[i]] = 0;",
			"                if (uint32_t sub = (mask - 1) & mask, half = mask >> 1; sub) do",
			"                        for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                            if (chmin(costs[i], m_trees[sub][i] + m_trees[mask - sub][i])) {",
			"                                if constexpr (_GetPath) froms[i] = 0x80000000 | sub;",
			"                            }",
			"                    while ((sub = (sub - 1) & mask) >= half);",
			"                for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                    if (costs[i] < m_infiniteCost) dijkstraHeap.push(i);",
			"                while (dijkstraHeap.size()) {",
			"                    uint32_t from = dijkstraHeap.top();",
			"                    _Tp curCost = costs[from];",
			"                    dijkstraHeap.pop();",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[index, to, cost] = m_edges[cur]; chmin(costs[to], curCost + cost)) {",
			"                            dijkstraHeap.push(to);",
			"                            if constexpr (_GetPath) froms[to] = index;",
			"                        }",
			"                }",
			"                m_trees.push_back(costs);",
			"                if constexpr (_GetPath) m_from.push_back(froms);",
			"            }",
			"            m_minCost = *std::min_element(m_trees.back().begin(), m_trees.back().end());",
			"            return m_minCost < m_infiniteCost;",
			"        }",
			"        template <bool _GetPath = false>",
			"        bool calc_spfa(const std::vector<uint32_t> &__keys) {",
			"            m_trees.reserve(1 << __keys.size());",
			"            std::vector<_Tp> costs(m_vertexNum);",
			"            std::vector<uint32_t> froms;",
			"            if constexpr (_GetPath) {",
			"                m_from.reserve(1 << __keys.size());",
			"                froms.resize(m_vertexNum);",
			"            }",
			"            std::queue<uint32_t> spfaQueue;",
			"            std::vector<bool> spfaInQueue(m_vertexNum, false);",
			"            for (uint32_t mask = 0; mask < 1 << __keys.size(); mask++) {",
			"                std::fill(costs.begin(), costs.end(), m_infiniteCost);",
			"                if constexpr (_GetPath) std::fill(froms.begin(), froms.end(), -1);",
			"                if (uint32_t i = std::__countr_zero(mask); std::__popcount(mask) == 1) costs[__keys[i]] = 0;",
			"                if (uint32_t sub = (mask - 1) & mask, half = mask >> 1; sub) do",
			"                        for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                            if (chmin(costs[i], m_trees[sub][i] + m_trees[mask - sub][i])) {",
			"                                if constexpr (_GetPath) froms[i] = 0x80000000 | sub;",
			"                            }",
			"                    while ((sub = (sub - 1) & mask) >= half);",
			"                for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                    if (costs[i] < m_infiniteCost) {",
			"                        spfaQueue.push(i);",
			"                        spfaInQueue[i] = true;",
			"                    }",
			"                while (spfaQueue.size()) {",
			"                    uint32_t from = spfaQueue.front();",
			"                    spfaQueue.pop();",
			"                    spfaInQueue[from] = false;",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[index, to, cost] = m_edges[cur]; chmin(costs[to], costs[from] + cost)) {",
			"                            if constexpr (_GetPath) froms[to] = index;",
			"                            if (!spfaInQueue[to]) {",
			"                                spfaQueue.push(to);",
			"                                spfaInQueue[to] = true;",
			"                            }",
			"                        }",
			"                }",
			"                m_trees.push_back(costs);",
			"                if constexpr (_GetPath) m_from.push_back(froms);",
			"            }",
			"            m_minCost = *std::min_element(m_trees.back().begin(), m_trees.back().end());",
			"            return m_minCost < m_infiniteCost;",
			"        }",
			"        std::vector<uint32_t> getEdges() const {",
			"            std::vector<uint32_t> path;",
			"            struct node {",
			"                uint32_t mask, root;",
			"            };",
			"            std::queue<node> Q;",
			"            Q.push({uint32_t(m_trees.size() - 1), uint32_t(std::min_element(m_trees.back().begin(), m_trees.back().end()) - m_trees.back().begin())});",
			"            while (Q.size()) {",
			"                auto [mask, root] = Q.front();",
			"                Q.pop();",
			"                if (uint32_t state = m_from[mask][root]; state == -1)",
			"                    continue;",
			"                else if (!(state & 0x80000000)) {",
			"                    path.push_back(state);",
			"                    Q.push({mask, m_rawEdges[state].from ^ m_rawEdges[state].to ^ root});",
			"                } else {",
			"                    Q.push({state ^ 0x80000000, root});",
			"                    Q.push({mask - (state ^ 0x80000000), root});",
			"                }",
			"            }",
			"            return path;",
			"        }",
			"    };",
			"};",
		],
		"description": "steiner"
	},
	"StoerWagner":{
		"prefix": "SW",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, uint32_t _MAXN>",
			"    struct StoerWagner {",
			"        std::vector<std::vector<_Tp>> m_costs;",
			"        std::vector<std::bitset<_MAXN>> m_behalf;",
			"        std::bitset<_MAXN> m_rest;",
			"        uint32_t m_vertexNum;",
			"        StoerWagner(uint32_t __vertexNum) : m_costs(__vertexNum, std::vector<_Tp>(__vertexNum, 0)), m_vertexNum(__vertexNum) {}",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cost) {",
			"            m_costs[__a][__b] += __cost;",
			"            m_costs[__b][__a] += __cost;",
			"        }",
			"        template <bool _GetPath>",
			"        _Tp calc(_Tp __infiniteCost = std::numeric_limits<_Tp>::max() / 2) {",
			"            if constexpr (_GetPath) {",
			"                m_behalf.resize(m_vertexNum);",
			"                for (uint32_t i = 0; i < m_vertexNum; i++) m_behalf[i].set(i);",
			"            }",
			"            std::bitset<_MAXN> canChoose;",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) canChoose.set(i);",
			"            _Tp w[m_vertexNum], ans = __infiniteCost;",
			"            while (canChoose.count() > 1) {",
			"                std::bitset<_MAXN> canVisit(canChoose);",
			"                uint32_t source = -1, target = canVisit._Find_first();",
			"                std::fill(w, w + m_vertexNum, 0);",
			"                while (canVisit.count() > 1) {",
			"                    canVisit.reset(target);",
			"                    source = target;",
			"                    _Tp mxCost = 0;",
			"                    for (uint32_t to = canVisit._Find_first(); to < m_vertexNum; to = canVisit._Find_next(to))",
			"                        if (chmax(mxCost, w[to] += m_costs[source][to])) target = to;",
			"                }",
			"                if (chmin(ans, w[target]) && _GetPath) m_rest = m_behalf[target];",
			"                canChoose.reset(target);",
			"                for (uint32_t to = canChoose._Find_first(); to < m_vertexNum; to = canChoose._Find_next(to))",
			"                    if (_Tp cost = m_costs[target][to]) addEdge(source, to, cost);",
			"                if constexpr (_GetPath) m_behalf[source] |= m_behalf[target];",
			"            }",
			"            return ans;",
			"        }",
			"    };",
			"}",
		],
		"description": "Stoer Wagner"
	},
	"Tarjan bridge":{
		"prefix": "TARJAN",
		"body": [
			"namespace OY {",
			"    struct Tarjan_bridge {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<uint32_t> m_dfn;",
			"        std::vector<uint32_t> m_low;",
			"        std::vector<bool> m_isBridge;",
			"        std::vector<uint32_t> m_ebccBuffer;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_dfnCount;",
			"        uint32_t m_bridgeCount;",
			"        uint32_t m_ebccCount;",
			"        Tarjan_bridge(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_dfn(__vertexNum, -1), m_low(__vertexNum, -1), m_isBridge(__edgeNum, false), m_dfnCount(0), m_vertexNum(__vertexNum), m_bridgeCount(0), m_ebccCount(0) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_rawEdges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[from, to] : m_rawEdges) {",
			"                m_starts[from + 1]++;",
			"                if (from != to) m_starts[to + 1]++;",
			"            }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++) {",
			"                auto &[from, to] = m_rawEdges[index];",
			"                m_edges[cursor[from]++] = _Edge{index, to};",
			"                if (from != to) m_edges[cursor[to]++] = _Edge{index, from};",
			"            }",
			"        }",
			"        void calc() {",
			"            auto dfs = [this](auto self, uint32_t i, uint32_t fromIndex) -> void {",
			"                m_dfn[i] = m_low[i] = m_dfnCount++;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (auto &[index, to] = m_edges[cur]; !~m_dfn[to]) {",
			"                        self(self, to, index);",
			"                        chmin(m_low[i], m_low[to]);",
			"                    } else if (index != fromIndex)",
			"                        chmin(m_low[i], m_dfn[to]);",
			"                if (m_low[i] == m_dfn[i] && ~fromIndex) {",
			"                    m_isBridge[fromIndex] = true;",
			"                    m_bridgeCount++;",
			"                }",
			"            };",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                if (!~m_dfn[i]) {",
			"                    dfs(dfs, i, -1);",
			"                    m_ebccCount++;",
			"                }",
			"            m_ebccCount += m_bridgeCount;",
			"        }",
			"        bool isBridge(uint32_t __from, uint32_t __to) const { return m_low[__from] > m_dfn[__to] || m_low[__to] > m_dfn[__from]; }",
			"        std::vector<uint32_t> getBridges() const {",
			"            std::vector<uint32_t> bridges;",
			"            bridges.reserve(m_bridgeCount);",
			"            for (uint32_t i = 0; i < m_isBridge.size(); i++)",
			"                if (m_isBridge[i]) bridges.push_back(i);",
			"            return bridges;",
			"        }",
			"        std::vector<std::basic_string_view<uint32_t>> getEBCC() {",
			"            std::vector<std::basic_string_view<uint32_t>> res;",
			"            res.reserve(m_ebccCount);",
			"            m_ebccBuffer.reserve(m_vertexNum);",
			"            uint32_t cursor = 0;",
			"            std::vector<bool> visit(m_vertexNum, false);",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                if (!visit[i]) {",
			"                    uint32_t start = cursor;",
			"                    visit[i] = true;",
			"                    m_ebccBuffer.push_back(i);",
			"                    while (cursor < m_ebccBuffer.size())",
			"                        for (uint32_t from = m_ebccBuffer[cursor++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                            if (auto &[index, to] = m_edges[cur]; !m_isBridge[index] && !visit[to]) {",
			"                                visit[to] = true;",
			"                                m_ebccBuffer.push_back(to);",
			"                            }",
			"                    res.emplace_back(m_ebccBuffer.data() + start, cursor - start);",
			"                }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "tarjan bridge"
	},
	"Tarjan cut":{
		"prefix": "TARJAN",
		"body": [
			"namespace OY {",
			"    struct Tarjan_cut {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"        };",
			"        struct _Edge {",
			"            uint32_t index, to;",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<uint32_t> m_dfn;",
			"        std::vector<uint32_t> m_low;",
			"        std::vector<uint32_t> m_adj;",
			"        std::vector<uint32_t> m_stack;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_dfnCount;",
			"        uint32_t m_cutCount;",
			"        std::basic_string<uint32_t> m_vbccBuffer;",
			"        std::vector<std::basic_string_view<uint32_t>> m_vbcc;",
			"        Tarjan_cut(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_dfn(__vertexNum, -1), m_low(__vertexNum, -1), m_adj(__vertexNum, 0), m_dfnCount(0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_rawEdges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[from, to] : m_rawEdges) {",
			"                m_starts[from + 1]++;",
			"                if (from != to) m_starts[to + 1]++;",
			"            }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++) {",
			"                auto &[from, to] = m_rawEdges[index];",
			"                m_edges[cursor[from]++] = _Edge{index, to};",
			"                if (from != to) m_edges[cursor[to]++] = _Edge{index, from};",
			"            }",
			"        }",
			"        template <bool _GetVbcc = false>",
			"        void calc() {",
			"            if constexpr (_GetVbcc) {",
			"                m_vbccBuffer.reserve(m_edges.size() + m_vertexNum);",
			"                m_vbcc.reserve(m_vertexNum);",
			"                m_stack.reserve(m_vertexNum);",
			"            }",
			"            auto dfs=[this](auto self,uint32_t i, uint32_t fromIndex)->void{",
			"                m_dfn[i] = m_low[i] = m_dfnCount++;",
			"                uint32_t stackLength = m_stack.size();",
			"                if constexpr (_GetVbcc) m_stack.push_back(i);",
			"                if (~fromIndex) m_adj[i]++;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (auto &[index, to] = m_edges[cur]; !~m_dfn[to]) {",
			"                        self(self,to, index);",
			"                        if (m_low[to] < m_dfn[i])",
			"                            chmin(m_low[i], m_low[to]);",
			"                        else",
			"                            m_adj[i]++;",
			"                    } else if (index != fromIndex)",
			"                        chmin(m_low[i], m_dfn[to]);",
			"                if constexpr (_GetVbcc) {",
			"                    if (!~fromIndex) {",
			"                        if (!m_adj[i]) {",
			"                            uint32_t len = m_stack.size() - stackLength;",
			"                            m_vbcc.emplace_back(m_vbccBuffer.data() + m_vbccBuffer.size(), len);",
			"                            m_vbccBuffer.insert(m_vbccBuffer.end(), m_stack.data() + stackLength, m_stack.data() + m_stack.size());",
			"                        }",
			"                        m_stack.resize(stackLength);",
			"                    } else if (uint32_t parent = m_rawEdges[fromIndex].from ^ m_rawEdges[fromIndex].to ^ i; m_low[i] >= m_dfn[parent]) {",
			"                        std::swap(m_stack[stackLength - 1], parent);",
			"                        uint32_t len = m_stack.size() - stackLength + 1;",
			"                        m_vbcc.emplace_back(m_vbccBuffer.data() + m_vbccBuffer.size(), len);",
			"                        m_vbccBuffer.insert(m_vbccBuffer.end(), m_stack.data() + stackLength - 1, m_stack.data() + m_stack.size());",
			"                        std::swap(m_stack[stackLength - 1], parent);",
			"                        m_stack.resize(stackLength);",
			"                    }",
			"                }",
			"            };",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                if (!~m_dfn[i]) dfs(dfs, i, -1);",
			"            m_cutCount = std::count_if(m_adj.begin(), m_adj.end(), [](uint32_t x) { return x > 1; });",
			"        }",
			"        bool isCut(uint32_t __i) const { return m_adj[__i] > 1; }",
			"        std::vector<uint32_t> getCuts() const {",
			"            std::vector<uint32_t> cuts;",
			"            cuts.reserve(m_cutCount);",
			"            for (uint32_t i = 0; i < m_adj.size(); i++)",
			"                if (m_adj[i] > 1) cuts.push_back(i);",
			"            return cuts;",
			"        }",
			"    };",
			"}",
		],
		"description": "tarjan cut"
	},
	"Tarjan scc":{
		"prefix": "TARJAN",
		"body": [
			"namespace OY {",
			"    struct Tarjan_scc {",
			"        struct _Edge {",
			"            uint32_t from, to;",
			"        };",
			"        std::vector<_Edge> m_rawEdges;",
			"        std::vector<uint32_t> m_adj;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<uint32_t> m_dfn;",
			"        std::vector<uint32_t> m_low;",
			"        std::vector<uint32_t> m_id;",
			"        std::vector<uint32_t> m_stack;",
			"        std::vector<uint32_t> m_topo;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_dfnCount;",
			"        uint32_t m_idCount;",
			"        Tarjan_scc(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum), m_dfn(__vertexNum, -1), m_low(__vertexNum, -1), m_id(__vertexNum, -1), m_dfnCount(0), m_idCount(0) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_rawEdges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[from, to] : m_rawEdges) m_starts[from + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_adj.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_rawEdges.size(); index++) {",
			"                auto &[from, to] = m_rawEdges[index];",
			"                m_adj[cursor[from]++] = to;",
			"            }",
			"        }",
			"        void calc() {",
			"            m_stack.reserve(m_vertexNum);",
			"            m_topo.reserve(m_vertexNum);",
			"            auto dfs = [this](auto self, uint32_t i) -> uint32_t {",
			"                m_dfn[i] = m_low[i] = m_dfnCount++;",
			"                m_stack.push_back(i);",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (uint32_t to = m_adj[cur]; !~m_dfn[to])",
			"                        chmin(m_low[i], self(self, to));",
			"                    else if (!~m_id[to])",
			"                        chmin(m_low[i], m_dfn[to]);",
			"                if (m_dfn[i] == m_low[i]) {",
			"                    while (true) {",
			"                        uint32_t back = m_stack.back();",
			"                        m_stack.pop_back();",
			"                        m_id[back] = m_idCount;",
			"                        m_topo.push_back(back);",
			"                        if (back == i) break;",
			"                    }",
			"                    m_idCount++;",
			"                }",
			"                return m_low[i];",
			"            };",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                if (!~m_dfn[i]) dfs(dfs, i);",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) m_id[i] = m_idCount - 1 - m_id[i];",
			"            std::reverse(m_topo.begin(), m_topo.end());",
			"        }",
			"        std::vector<std::basic_string_view<uint32_t>> groups() const {",
			"            std::vector<std::basic_string_view<uint32_t>> res;",
			"            res.reserve(m_idCount);",
			"            for (int prev = 0, id = 0, cursor = 0; cursor < m_vertexNum; prev = cursor, id++) {",
			"                while (cursor < m_vertexNum && m_id[m_topo[cursor]] == id) cursor++;",
			"                res.emplace_back(m_topo.data() + prev, cursor - prev);",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Tarjan scc"
	},
	"topological sort":{
		"prefix": "TOPO",
		"body": [
			"namespace OY {",
			"    struct TopologicalSort {",
			"        struct _Edge {",
			"            uint32_t from, to;",
			"        };",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_adj;",
			"        std::vector<uint32_t> m_starts;",
			"        std::vector<uint32_t> m_queue;",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_sourceCount;",
			"        uint32_t m_levelCount;",
			"        TopologicalSort(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_edges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_edges.push_back({__a, __b}); }",
			"        void prepare() {",
			"            for (auto &[from, to] : m_edges) m_starts[from + 1]++;",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_adj.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (uint32_t index = 0; index < m_edges.size(); index++) {",
			"                auto &[from, to] = m_edges[index];",
			"                m_adj[cursor[from]++] = to;",
			"            }",
			"        }",
			"        bool calc() {",
			"            uint32_t deg[m_vertexNum];",
			"            std::fill(deg, deg + m_vertexNum, 0);",
			"            for (uint32_t to : m_adj) deg[to]++;",
			"            m_queue.reserve(m_vertexNum);",
			"            uint32_t cursor = 0;",
			"            for (uint32_t i = 0; i < m_vertexNum; i++)",
			"                if (!deg[i]) m_queue.push_back(i);",
			"            m_sourceCount = m_queue.size();",
			"            m_levelCount = 0;",
			"            while (uint32_t levelNum = m_queue.size() - cursor) {",
			"                while (levelNum--)",
			"                    for (uint32_t from = m_queue[cursor++], cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (uint32_t to = m_adj[cur]; !--deg[to]) m_queue.push_back(to);",
			"                m_levelCount++;",
			"            }",
			"            return m_queue.size() == m_vertexNum;",
			"        }",
			"        std::basic_string_view<uint32_t> getSources() const { return std::basic_string_view<uint32_t>(m_queue.data(), m_sourceCount); }",
			"    };",
			"};",
		],
		"description": "topological sort"
	},
	"two sat":{
		"prefix": "TWOSAT",
		"body": [
			"namespace OY {",
			"    template <typename _Solver = Tarjan_scc>",
			"    struct TwoSat {",
			"        _Solver m_sol;",
			"        std::vector<bool> m_choose;",
			"        TwoSat(uint32_t __variableNum, uint32_t __clauseNum) : m_sol(__variableNum * 2, __clauseNum * 2), m_choose(__variableNum) {}",
			"        void addClause(uint32_t __i, bool __iVal, uint32_t __j, bool __jVal) {",
			"            m_sol.addEdge(__i * 2 + !__iVal, __j * 2 + __jVal);",
			"            m_sol.addEdge(__j * 2 + !__jVal, __i * 2 + __iVal);",
			"        }",
			"        bool calc() {",
			"            m_sol.prepare();",
			"            m_sol.calc();",
			"            for (uint32_t i = 0; i < m_sol.m_vertexNum; i += 2) {",
			"                if (m_sol.m_id[i] == m_sol.m_id[i + 1]) return false;",
			"                m_choose[i >> 1] = m_sol.m_id[i] < m_sol.m_id[i + 1];",
			"            }",
			"            return true;",
			"        }",
			"    };",
			"};",
		],
		"description": "two sat"
	},
	"zkw mcmf":{
		"prefix": "ZKW",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct ZKW_mcmf {",
			"        struct _RawEdge {",
			"            uint32_t from, to;",
			"            _Tp cap;",
			"            _Fp cost;",
			"        };",
			"        struct _Edge {",
			"            uint32_t to, rev;",
			"            _Tp cap;",
			"            _Fp cost;",
			"            bool operator>(const _Edge &other) const { return cap > other.cap; }",
			"        };",
			"        std::vector<_RawEdge> m_rawEdges;",
			"        std::vector<_Edge> m_edges;",
			"        std::vector<uint32_t> m_starts;",
			"        uint32_t m_vertexNum;",
			"        ZKW_mcmf(uint32_t __vertexNum, uint32_t __edgeNum) : m_starts(__vertexNum + 1, 0), m_vertexNum(__vertexNum) { m_rawEdges.reserve(__edgeNum); }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __cap, _Fp __cost) { m_rawEdges.push_back({__a, __b, __cap, __cost}); }",
			"        void prepare() {",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_starts[from + 1]++;",
			"                    m_starts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_starts.begin(), m_starts.end(), m_starts.begin());",
			"            m_edges.resize(m_starts.back());",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts.begin(), m_starts.begin() + m_vertexNum, cursor);",
			"            for (auto &[from, to, cap, cost] : m_rawEdges)",
			"                if (from != to) {",
			"                    m_edges[cursor[from]] = _Edge{to, cursor[to], cap, cost};",
			"                    m_edges[cursor[to]++] = _Edge{from, cursor[from]++, 0, -cost};",
			"                }",
			"        }",
			"        template <typename _Compare = std::greater<_Edge>>",
			"        void prepareSorted(_Compare __comp = _Compare()) {",
			"            prepare();",
			"            for (uint32_t i = 0; i < m_vertexNum; i++) {",
			"                uint32_t start = m_starts[i], end = m_starts[i + 1];",
			"                std::sort(m_edges.begin() + start, m_edges.begin() + end, __comp);",
			"                for (uint32_t j = start; j < end; j++) m_edges[m_edges[j].rev].rev = j;",
			"            }",
			"        }",
			"        std::pair<_Tp, _Fp> calc(uint32_t __source, uint32_t __target, _Tp __infiniteCap = std::numeric_limits<_Tp>::max() / 2, _Fp __infiniteCost = std::numeric_limits<_Fp>::max() / 2) {",
			"            uint32_t queue[m_vertexNum + 1], head = 0, tail = 0;",
			"            _Tp totalFlow = 0;",
			"            _Fp costs[m_vertexNum], totalCost = 0;",
			"            std::vector<bool> inQueue(m_vertexNum, false);",
			"            auto dfs = [&](auto self, uint32_t i, _Tp _cap) {",
			"                if (i == __target || !_cap) return _cap;",
			"                inQueue[i] = true;",
			"                _Tp flow = 0, f;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur < end; cur++)",
			"                    if (auto &[to, rev, cap, cost] = m_edges[cur]; !inQueue[to] && costs[i] - cost == costs[to] && (f = self(self, to, std::min(_cap, cap))))",
			"                        if (flow += f, _cap -= f, cap -= f, m_edges[rev].cap += f; !_cap) break;",
			"                return flow;",
			"            };",
			"            while (true) {",
			"                std::fill(costs, costs + m_vertexNum, __infiniteCost);",
			"                costs[__target] = 0;",
			"                queue[tail++] = __target;",
			"                if (tail == m_vertexNum + 1) tail = 0;",
			"                inQueue[__target] = true;",
			"                while (head != tail) {",
			"                    uint32_t from = queue[head++];",
			"                    if (head == m_vertexNum + 1) head = 0;",
			"                    inQueue[from] = false;",
			"                    for (uint32_t cur = m_starts[from], end = m_starts[from + 1]; cur < end; cur++)",
			"                        if (auto &[to, rev, cap, cost] = m_edges[cur]; m_edges[rev].cap && chmin(costs[to], costs[from] - cost) && !inQueue[to]) {",
			"                            queue[tail++] = to;",
			"                            if (tail == m_vertexNum + 1) tail = 0;",
			"                            inQueue[to] = true;",
			"                        }",
			"                }",
			"                if (costs[__source] == __infiniteCost) break;",
			"                _Tp flow = 0;",
			"                while (true) {",
			"                    _Tp f = dfs(dfs, __source, __infiniteCap);",
			"                    std::fill(inQueue.begin(), inQueue.end(), false);",
			"                    if (!f) break;",
			"                    flow += f;",
			"                }",
			"                totalFlow += flow;",
			"                totalCost += flow * costs[__source];",
			"            }",
			"            return {totalFlow, totalCost};",
			"        }",
			"    };",
			"}",
		],
		"description": "ZKW mcmf"
	},

	"Divided Tree":{
		"prefix": "DT",
		"body": [
			"namespace OY {",
			"    template <typename _Tree>",
			"    auto getDivideTree(_Tree &__tree) {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        Tree<_MAXN> res(__tree.m_vertexNum);",
			"        std::bitset<_MAXN> banList;",
			"        uint32_t queue[_MAXN];",
			"        auto dfs = [&](auto self, uint32_t i) -> uint32_t {",
			"            uint32_t head = 0, tail = 0;",
			"            banList[i] = true;",
			"            queue[tail++] = i;",
			"            while (head < tail)",
			"                for (uint32_t j = queue[head++], cur = __tree.m_starts[j], end = __tree.m_starts[j + 1]; cur != end; cur++)",
			"                    if (uint32_t to = __tree.m_to[cur]; !banList[to]) {",
			"                        banList[to] = true;",
			"                        queue[tail++] = to;",
			"                    }",
			"            for (uint32_t i = 0; i < tail; i++) banList[queue[i]] = false;",
			"            uint32_t centroid;",
			"            auto traverse = [&](auto self, uint32_t i, uint32_t p) -> uint32_t {",
			"                uint32_t size = 1, maxAdj = 0;",
			"                for (uint32_t cur = __tree.m_starts[i], end = __tree.m_starts[i + 1]; cur != end; cur++)",
			"                    if (uint32_t to = __tree.m_to[cur]; to != p && !banList[to]) {",
			"                        uint32_t subSize = self(self, to, i);",
			"                        size += subSize;",
			"                        chmax(maxAdj, subSize);",
			"                    }",
			"                chmax(maxAdj, tail - size);",
			"                if (maxAdj <= tail / 2) centroid = i;",
			"                return size;",
			"            };",
			"            traverse(traverse, i, -1);",
			"            banList[centroid] = true;",
			"            for (uint32_t cur = __tree.m_starts[centroid], end = __tree.m_starts[centroid + 1]; cur != end; cur++)",
			"                if (uint32_t to = __tree.m_to[cur]; !banList[to]) res.addEdge(centroid, self(self, to));",
			"            banList[centroid] = false;",
			"            return centroid;",
			"        };",
			"        uint32_t root = dfs(dfs, 0);",
			"        res.prepare();",
			"        res.setRoot(root);",
			"        return res;",
			"    };",
			"}",
		],
		"description": "Divided Tree"
	},
	"Doubling LCA":{
		"prefix": "LCA",
		"body": [
			"namespace OY {",
			"    template <typename _Tree>",
			"    struct DoublingLCA {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        _Tree &m_tree;",
			"        uint32_t m_level;",
			"        uint32_t m_depth[_MAXN];",
			"        uint32_t m_fa[32 - std::__countl_zero(_MAXN - 1)][_MAXN];",
			"        DoublingLCA(_Tree &__tree) : m_tree(__tree) {",
			"            uint32_t maxDepth = 0;",
			"            auto dfs = [&](auto self, uint32_t i, uint32_t depth, uint32_t p) -> void {",
			"                chmax(maxDepth, depth);",
			"                m_depth[i] = depth;",
			"                m_fa[0][i] = p;",
			"                for (uint32_t cur = m_tree.m_starts[i] + (i != m_tree.m_root), end = m_tree.m_starts[i + 1]; cur != end; cur++) self(self, m_tree.m_to[cur], depth + 1, i);",
			"            };",
			"            dfs(dfs, m_tree.m_root, 0, -1);",
			"            m_level = 32 - std::__countl_zero(maxDepth);",
			"            for (uint32_t j = 1; j < m_level; j++)",
			"                for (uint32_t i = 0; i < m_tree.m_vertexNum; i++) m_fa[j][i] = ~m_fa[j - 1][i] ? m_fa[j - 1][m_fa[j - 1][i]] : -1;",
			"        }",
			"        uint32_t getAncestor(uint32_t __a, uint32_t __n) const {",
			"            if (__n > m_depth[__a]) return -1;",
			"            while (__n) {",
			"                uint32_t k = std::__countr_zero(__n);",
			"                __a = m_fa[k][__a];",
			"                __n -= uint32_t(1) << k;",
			"            }",
			"            return __a;",
			"        }",
			"        uint32_t calc(uint32_t __a, uint32_t __b) {",
			"            if (m_depth[__a] > m_depth[__b]) std::swap(__a, __b);",
			"            if (uint32_t x = m_depth[__b] - m_depth[__a]; x)",
			"                for (uint32_t j = 0; x; j++, x >>= 1)",
			"                    if (x & 1) __b = m_fa[j][__b];",
			"            if (__a == __b) return __a;",
			"            for (uint32_t j = m_level - 1; ~j; j--)",
			"                if (m_fa[j][__a] != m_fa[j][__b]) {",
			"                    __a = m_fa[j][__a];",
			"                    __b = m_fa[j][__b];",
			"                }",
			"            return m_fa[0][__a];",
			"        }",
			"    };",
			"}",
		],
		"description": "Doubling LCA"
	},
	"HeavyLightDecomposition LCA":{
		"prefix": "LCA",
		"body": [
			"namespace OY {",
			"    template<typename _Tree>",
			"    struct HeavyLightDecompositionLCA {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        _Tree &m_tree;",
			"        uint32_t m_size[_MAXN];",
			"        uint32_t m_heavySon[_MAXN];",
			"        uint32_t m_linkId[_MAXN];",
			"        uint32_t m_linkDepth[_MAXN];",
			"        uint32_t m_linkParent[_MAXN];",
			"        HeavyLightDecompositionLCA(_Tree &__tree) : m_tree(__tree) {",
			"            auto dfs = [&](auto self, uint32_t i) -> void {",
			"                m_size[i] = 1;",
			"                m_heavySon[i] = -1;",
			"                uint32_t heavy = 0;",
			"                for (uint32_t cur = m_tree.m_starts[i] + (i != m_tree.m_root), end = m_tree.m_starts[i + 1]; cur != end; cur++) {",
			"                    uint32_t to = m_tree.m_to[cur];",
			"                    self(self, to);",
			"                    m_size[i] += m_size[to];",
			"                    if (chmax(heavy, m_size[to])) m_heavySon[i] = to;",
			"                }",
			"            };",
			"            dfs(dfs, m_tree.m_root);",
			"            uint32_t cursor = 0;",
			"            std::bitset<_MAXN> visit;",
			"            auto dfs2 = [&](auto self, uint32_t i, uint32_t d, uint32_t ld, uint32_t p) -> void {",
			"                visit.set(i);",
			"                m_linkId[i] = cursor;",
			"                m_linkDepth[i] = ld;",
			"                m_linkParent[i] = p;",
			"                if (!~m_heavySon[i]) {",
			"                    cursor++;",
			"                    return;",
			"                }",
			"                self(self, m_heavySon[i], d++, ld, p);",
			"                for (uint32_t cur = m_tree.m_starts[i], end = m_tree.m_starts[i + 1]; cur != end; cur++)",
			"                    if (uint32_t to = m_tree.m_to[cur]; !visit[to]) self(self, to, d, d, i);",
			"            };",
			"            dfs2(dfs2, m_tree.m_root, 0, 0, -1);",
			"        }",
			"        uint32_t calc(uint32_t __a, uint32_t __b) const {",
			"            while (m_linkId[__a] != m_linkId[__b])",
			"                if (m_linkDepth[__a] < m_linkDepth[__b])",
			"                    __b = m_linkParent[__b];",
			"                else",
			"                    __a = m_linkParent[__a];",
			"            return m_size[__a] < m_size[__b] ? __b : __a;",
			"        }",
			"    };",
			"}",
		],
		"description": "HLD LCA"
	},
	"HeavyLightDecomposition":{
		"prefix": "HLD",
		"body": [
			"namespace OY {",
			"    template <typename _Tree>",
			"    struct HeavyLightDecomposition {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        _Tree &m_tree;",
			"        uint32_t m_size[_MAXN];",
			"        uint32_t m_depth[_MAXN];",
			"        uint32_t m_heavySon[_MAXN];",
			"        uint32_t m_pos[_MAXN];",
			"        uint32_t m_sequence[_MAXN];",
			"        uint32_t m_belong[_MAXN];",
			"        uint32_t m_linkTop[_MAXN];",
			"        uint32_t m_linkCount;",
			"        HeavyLightDecomposition(_Tree &__tree) : m_tree(__tree) {",
			"            auto dfs = [&](auto self, uint32_t i, uint32_t d) -> void {",
			"                m_size[i] = 1;",
			"                m_depth[i] = d++;",
			"                m_heavySon[i] = -1;",
			"                uint32_t heavy = 0;",
			"                for (uint32_t cur = m_tree.m_starts[i] + (i != m_tree.m_root), end = m_tree.m_starts[i + 1]; cur != end; cur++) {",
			"                    uint32_t to = m_tree.m_to[cur];",
			"                    self(self, to, d);",
			"                    m_size[i] += m_size[to];",
			"                    if (chmax(heavy, m_size[to])) m_heavySon[i] = to;",
			"                }",
			"            };",
			"            dfs(dfs, m_tree.m_root, 0);",
			"            std::bitset<_MAXN> visit;",
			"            uint32_t cursor = 0;",
			"            m_linkCount = 0;",
			"            auto dfs2 = [&](auto self, uint32_t i) -> void {",
			"                visit.set(i);",
			"                m_sequence[cursor] = i;",
			"                m_pos[i] = cursor++;",
			"                m_belong[i] = m_linkCount;",
			"                if (!~m_heavySon[i]) {",
			"                    m_linkCount++;",
			"                    return;",
			"                }",
			"                self(self, m_heavySon[i]);",
			"                for (uint32_t cur = m_tree.m_starts[i], end = m_tree.m_starts[i + 1]; cur != end; cur++)",
			"                    if (uint32_t to = m_tree.m_to[cur]; !visit[to]) self(self, m_linkTop[m_linkCount] = to);",
			"            };",
			"            dfs2(dfs2, m_linkTop[m_linkCount] = m_tree.m_root);",
			"        }",
			"        std::basic_string_view<uint32_t> getSequence() const { return std::basic_string_view<uint32_t>(m_sequence, m_sequence + m_tree.m_vertexNum); }",
			"        uint32_t getAncestor(uint32_t __a, uint32_t __n) const {",
			"            if (__n > m_depth[__a]) return -1;",
			"            uint32_t depth = m_depth[__a], targetDepth = m_depth[__a] - __n, top;",
			"            while (true) {",
			"                top = m_linkTop[m_belong[__a]];",
			"                if (m_depth[top] > targetDepth) {",
			"                    depth = m_depth[top] - 1;",
			"                    __a = m_tree.m_to[m_tree.m_starts[top]];",
			"                } else",
			"                    break;",
			"            }",
			"            return m_sequence[m_pos[__a] - (depth - targetDepth)];",
			"        }",
			"        auto getLinks(uint32_t __a, uint32_t __b) const {",
			"            struct _range {",
			"                uint32_t start, end;",
			"            };",
			"            std::vector<_range> res;",
			"            while (true) {",
			"                uint32_t atop = m_linkTop[m_belong[__a]], btop = m_linkTop[m_belong[__b]];",
			"                if (atop == btop) break;",
			"                if (m_depth[atop] < m_depth[btop]) {",
			"                    res.push_back({m_pos[btop], m_pos[__b]});",
			"                    __b = m_tree.m_to[m_tree.m_starts[btop]];",
			"                } else {",
			"                    res.push_back({m_pos[atop], m_pos[__a]});",
			"                    __a = m_tree.m_to[m_tree.m_starts[atop]];",
			"                }",
			"            }",
			"            if (m_depth[__a] > m_depth[__b]) std::swap(__a, __b);",
			"            res.push_back({m_pos[__a], m_pos[__b]});",
			"            return res;",
			"        }",
			"        auto getSubtree(uint32_t __a) const {",
			"            struct _range {",
			"                uint32_t start, end;",
			"            };",
			"            return _range{m_pos[__a], m_pos[__a] + m_size[__a] - 1};",
			"        }",
			"        uint32_t lca(uint32_t __a, uint32_t __b) const {",
			"            while (true) {",
			"                uint32_t atop = m_linkTop[m_belong[__a]], btop = m_linkTop[m_belong[__b]];",
			"                if (atop == btop) break;",
			"                if (m_depth[atop] < m_depth[btop])",
			"                    __b = m_tree.m_to[m_tree.m_starts[btop]];",
			"                else",
			"                    __a = m_tree.m_to[m_tree.m_starts[atop]];",
			"            }",
			"            return m_depth[__a] < m_depth[__b] ? __a : __b;",
			"        }",
			"    };",
			"}",
		],
		"description": "Heavy Light Decomposition"
	},
	"LimitedRMQ LCA":{
		"prefix": "LCA",
		"body": [
			"namespace OY {",
			"    template <typename _Tree>",
			"    struct LimitedRMQLCA {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        _Tree &m_tree;",
			"        uint32_t m_sequence[_MAXN * 2 - 1];",
			"        uint32_t m_depthSequence[_MAXN * 2 - 1];",
			"        uint32_t m_minIndex[_MAXN];",
			"        uint32_t m_maxIndex[_MAXN];",
			"        LimitedRMQ<_LimitedRMQPicker<uint32_t[_MAXN * 2 - 1], std::greater<uint32_t>>> m_rmq;",
			"        LimitedRMQLCA(_Tree &__tree) : m_tree(__tree), m_rmq(m_depthSequence) {",
			"            uint32_t cursor = 0;",
			"            auto dfs = [&](auto self, uint32_t i, uint32_t d) -> void {",
			"                m_sequence[cursor] = i;",
			"                m_depthSequence[cursor++] = d;",
			"                for (uint32_t cur = m_tree.m_starts[i] + (i != m_tree.m_root), end = m_tree.m_starts[i + 1]; cur != end; cur++) {",
			"                    self(self, m_tree.m_to[cur], d + 1);",
			"                    m_sequence[cursor] = i;",
			"                    m_depthSequence[cursor++] = d;",
			"                }",
			"            };",
			"            dfs(dfs, m_tree.m_root, 0);",
			"            for (uint32_t i = 0; i < m_tree.m_vertexNum; i++) {",
			"                m_minIndex[i] = cursor;",
			"                m_maxIndex[i] = 0;",
			"            }",
			"            for (uint32_t i = 0; i < cursor; i++) {",
			"                chmin(m_minIndex[m_sequence[i]], i);",
			"                chmax(m_maxIndex[m_sequence[i]], i);",
			"            }",
			"            m_rmq.reset(m_depthSequence, m_depthSequence + cursor);",
			"        }",
			"        uint32_t calc(uint32_t __a, uint32_t __b) { return m_sequence[m_rmq.query(std::min(m_minIndex[__a], m_minIndex[__b]), std::max(m_maxIndex[__a], m_maxIndex[__b]))]; }",
			"    };",
			"}",
		],
		"description": "LimitedRMQ LCA"
	},
	"LongShortDecomposition":{
		"prefix": "LSD",
		"body": [
			"namespace OY {",
			"    template <typename _Tree>",
			"    struct LongShortDecomposition {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        _Tree &m_tree;",
			"        uint32_t m_size[_MAXN];",
			"        uint32_t m_height[_MAXN];",
			"        uint32_t m_depth[_MAXN];",
			"        uint32_t m_heavySon[_MAXN];",
			"        uint32_t m_pos[_MAXN];",
			"        uint32_t m_sequence[_MAXN];",
			"        uint32_t m_belong[_MAXN];",
			"        uint32_t m_linkTop[_MAXN];",
			"        uint32_t m_linkCount;",
			"        LongShortDecomposition(_Tree &__tree) : m_tree(__tree) {",
			"            auto dfs = [&](auto self, uint32_t i, uint32_t d) -> void {",
			"                m_size[i] = 1;",
			"                m_height[i] = 1;",
			"                m_depth[i] = d++;",
			"                m_heavySon[i] = -1;",
			"                for (uint32_t cur = m_tree.m_starts[i] + (i != m_tree.m_root), end = m_tree.m_starts[i + 1]; cur != end; cur++) {",
			"                    uint32_t to = m_tree.m_to[cur];",
			"                    self(self, to, d);",
			"                    m_size[i] += m_size[to];",
			"                    if (chmax(m_height[i], m_height[to] + 1)) m_heavySon[i] = to;",
			"                }",
			"            };",
			"            dfs(dfs, m_tree.m_root, 0);",
			"            std::bitset<_MAXN> visit;",
			"            uint32_t cursor = 0;",
			"            m_linkCount = 0;",
			"            auto dfs2 = [&](auto self, uint32_t i) -> void {",
			"                visit.set(i);",
			"                m_sequence[cursor] = i;",
			"                m_pos[i] = cursor++;",
			"                m_belong[i] = m_linkCount;",
			"                if (!~m_heavySon[i]) {",
			"                    m_linkCount++;",
			"                    return;",
			"                }",
			"                self(self, m_heavySon[i]);",
			"                for (uint32_t cur = m_tree.m_starts[i], end = m_tree.m_starts[i + 1]; cur != end; cur++)",
			"                    if (uint32_t to = m_tree.m_to[cur]; !visit[to]) self(self, m_linkTop[m_linkCount] = to);",
			"            };",
			"            dfs2(dfs2, m_linkTop[m_linkCount] = m_tree.m_root);",
			"        }",
			"        std::basic_string_view<uint32_t> getSequence() const { return std::basic_string_view<uint32_t>(m_sequence, m_sequence + m_tree.m_vertexNum); }",
			"        uint32_t getAncestor(uint32_t __a, uint32_t __n) const {",
			"            if (__n > m_depth[__a]) return -1;",
			"            uint32_t depth = m_depth[__a], targetDepth = m_depth[__a] - __n, top;",
			"            while (true) {",
			"                top = m_linkTop[m_belong[__a]];",
			"                if (m_depth[top] > targetDepth) {",
			"                    depth = m_depth[top] - 1;",
			"                    __a = m_tree.m_to[m_tree.m_starts[top]];",
			"                } else",
			"                    break;",
			"            }",
			"            return m_sequence[m_pos[__a] - (depth - targetDepth)];",
			"        }",
			"        auto getLinks(uint32_t __a, uint32_t __b) const {",
			"            struct _range {",
			"                uint32_t start, end;",
			"            };",
			"            std::vector<_range> res;",
			"            while (true) {",
			"                uint32_t atop = m_linkTop[m_belong[__a]], btop = m_linkTop[m_belong[__b]];",
			"                if (atop == btop) break;",
			"                if (m_depth[atop] < m_depth[btop]) {",
			"                    res.push_back({m_pos[btop], m_pos[__b]});",
			"                    __b = m_tree.m_to[m_tree.m_starts[btop]];",
			"                } else {",
			"                    res.push_back({m_pos[atop], m_pos[__a]});",
			"                    __a = m_tree.m_to[m_tree.m_starts[atop]];",
			"                }",
			"            }",
			"            if (m_depth[__a] > m_depth[__b]) std::swap(__a, __b);",
			"            res.push_back({m_pos[__a], m_pos[__b]});",
			"            return res;",
			"        }",
			"        auto getSubtree(uint32_t __a) const {",
			"            struct _range {",
			"                uint32_t start, end;",
			"            };",
			"            return _range{m_pos[__a], m_pos[__a] + m_size[__a] - 1};",
			"        }",
			"        uint32_t lca(uint32_t __a, uint32_t __b) const {",
			"            while (true) {",
			"                uint32_t atop = m_linkTop[m_belong[__a]], btop = m_linkTop[m_belong[__b]];",
			"                if (atop == btop) break;",
			"                if (m_depth[atop] < m_depth[btop])",
			"                    __b = m_tree.m_to[m_tree.m_starts[btop]];",
			"                else",
			"                    __a = m_tree.m_to[m_tree.m_starts[atop]];",
			"            }",
			"            return m_depth[__a] < m_depth[__b] ? __a : __b;",
			"        }",
			"    };",
			"}",
		],
		"description": "Long Short Decomposition"
	},
	"LongShortDecomposition LCA":{
		"prefix": "LCA",
		"body": [
			"namespace OY {",
			"    template <typename _Tree>",
			"    struct LongShortDecompositionLCA {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        static inline std::bitset<_MAXN> s_visit;",
			"        _Tree &m_tree;",
			"        uint32_t m_height[_MAXN];",
			"        uint32_t m_depth[_MAXN];",
			"        uint32_t m_heavySon[_MAXN];",
			"        uint32_t m_belongTopVal[_MAXN];",
			"        uint32_t m_upDown[_MAXN * 2];",
			"        uint32_t m_fa[32 - std::__countl_zero(_MAXN - 1)][_MAXN];",
			"        LongShortDecompositionLCA(_Tree &__tree) : m_tree(__tree) {",
			"            auto getHeavy = [&](auto self, uint32_t i, uint32_t d) -> void {",
			"                m_height[i] = 1;",
			"                m_depth[i] = d++;",
			"                m_heavySon[i] = -1;",
			"                for (uint32_t cur = m_tree.m_starts[i] + (i != m_tree.m_root), end = m_tree.m_starts[i + 1]; cur != end; cur++) {",
			"                    uint32_t to = m_tree.m_to[cur];",
			"                    self(self, to, d);",
			"                    m_fa[0][to] = i;",
			"                    if (chmax(m_height[i], m_height[to] + 1)) m_heavySon[i] = to;",
			"                }",
			"            };",
			"            getHeavy(getHeavy, m_tree.m_root, 0);",
			"            uint32_t cursor = 0, level = 32 - std::__countl_zero(*std::max_element(m_depth, m_depth + m_tree.m_vertexNum));",
			"            m_fa[0][m_tree.m_root] = -1;",
			"            for (uint32_t j = 1; j < level; j++)",
			"                for (uint32_t i = 0; i < m_tree.m_vertexNum; i++) m_fa[j][i] = ~m_fa[j - 1][i] ? m_fa[j - 1][m_fa[j - 1][i]] : -1;",
			"            auto setTop = [&](uint32_t top) {",
			"                uint32_t h = m_height[top];",
			"                for (uint32_t k = cursor + h, kend = cursor + h * 2, cur = top; k < kend; k++, cur = m_heavySon[cur]) m_upDown[k] = cur;",
			"                for (uint32_t k = cursor + h - 1, kend = cursor + 1, cur = top; k > kend && ~cur; k--) m_upDown[k] = cur = m_fa[0][cur];",
			"                return h + cursor - m_depth[top];",
			"            };",
			"            auto getOrder = [&](auto self, uint32_t i, uint32_t topVal) -> void {",
			"                s_visit.set(i);",
			"                m_belongTopVal[i] = topVal;",
			"                cursor += 2;",
			"                if (!~m_heavySon[i]) return;",
			"                self(self, m_heavySon[i], topVal);",
			"                for (uint32_t cur = m_tree.m_starts[i], end = m_tree.m_starts[i + 1]; cur != end; cur++)",
			"                    if (uint32_t to = m_tree.m_to[cur]; !s_visit[to]) self(self, to, setTop(to));",
			"            };",
			"            getOrder(getOrder, m_tree.m_root, setTop(m_tree.m_root));",
			"            for (uint32_t i = 0; i < m_tree.m_vertexNum; i++) s_visit.reset(i);",
			"        }",
			"        uint32_t getAncestor(uint32_t __a, uint32_t __n) const {",
			"            if (__n > m_depth[__a]) return -1;",
			"            if (!__n) return __a;",
			"            return m_upDown[m_belongTopVal[m_fa[31 - std::__countl_zero(__n)][__a]] + (m_depth[__a] - __n)];",
			"        }",
			"        uint32_t calc(uint32_t __a, uint32_t __b) const {",
			"            if (m_depth[__a] > m_depth[__b]) std::swap(__a, __b);",
			"            uint32_t d = m_depth[__b] - m_depth[__a], low = 0, high = m_depth[__a], p1 = __a, p2 = __a;",
			"            while (low < high) {",
			"                uint32_t mid = (low + high) / 2;",
			"                if (p1 = getAncestor(__a, mid), p2 = getAncestor(__b, mid + d); p1 != p2)",
			"                    low = mid + 1;",
			"                else",
			"                    high = mid;",
			"            }",
			"            return p1 == p2 ? p1 : m_fa[0][p1];",
			"        }",
			"    };",
			"}",
		],
		"description": "LSD LCA"
	},
	"RMQ LCA":{
		"prefix": "LCA",
		"body": [
			"namespace OY {",
			"    template <typename _Tree, template <typename...> typename _Solver = STTable>",
			"    struct RMQLCA {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        _Tree &m_tree;",
			"        uint32_t m_sequence[_MAXN * 2 - 1];",
			"        uint32_t m_minIndexSequence[_MAXN * 2 - 1];",
			"        uint32_t m_minIndex[_MAXN];",
			"        uint32_t m_maxIndex[_MAXN];",
			"        _Solver<uint32_t, const uint32_t &(*)(const uint32_t &, const uint32_t &)> m_sol;",
			"        RMQLCA(_Tree &__tree) : m_tree(__tree), m_sol(0, std::min<uint32_t>) {",
			"            uint32_t cursor = 0;",
			"            auto dfs = [&](auto self, uint32_t i) -> void {",
			"                m_sequence[cursor++] = i;",
			"                for (uint32_t cur = m_tree.m_starts[i] + (i != m_tree.m_root), end = m_tree.m_starts[i + 1]; cur != end; cur++) {",
			"                    self(self, m_tree.m_to[cur]);",
			"                    m_sequence[cursor++] = i;",
			"                }",
			"            };",
			"            dfs(dfs, m_tree.m_root);",
			"            for (uint32_t i = 0; i < m_tree.m_vertexNum; i++) {",
			"                m_minIndex[i] = cursor;",
			"                m_maxIndex[i] = 0;",
			"            }",
			"            for (uint32_t i = 0; i < cursor; i++) {",
			"                chmin(m_minIndex[m_sequence[i]], i);",
			"                chmax(m_maxIndex[m_sequence[i]], i);",
			"            }",
			"            for (uint32_t i = 0; i < cursor; i++) m_minIndexSequence[i] = m_minIndex[m_sequence[i]];",
			"            m_sol.reset(m_minIndexSequence, m_minIndexSequence + cursor);",
			"        }",
			"        uint32_t calc(uint32_t __a, uint32_t __b) { return m_sequence[m_sol.query(std::min(m_minIndex[__a], m_minIndex[__b]), std::max(m_maxIndex[__a], m_maxIndex[__b]))]; }",
			"    };",
			"}",
		],
		"description": "RMQ LCA"
	},
	"SegRayLengthHelper":{
		"prefix": "SEGRAY",
		"body": [
			"namespace OY {",
			"    template <typename _Tree>",
			"    struct SegRayLengthSolver {",
			"        using _Tp = typename _Tree::distance_type;",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        _Tree &m_tree;",
			"        _Tp m_ray[_MAXN][3];",
			"        _Tp m_seg[_MAXN][2];",
			"        _Tp m_downRay[_MAXN];",
			"        _Tp m_downSeg[_MAXN];",
			"        _Tp m_upRay[_MAXN];",
			"        _Tp m_upSeg[_MAXN];",
			"        SegRayLengthSolver(_Tree &__tree) : m_tree(__tree) {",
			"            std::fill(m_ray[0],m_ray[m_tree.m_vertexNum],0);",
			"            std::fill(m_seg[0],m_seg[m_tree.m_vertexNum],0);",
			"            std::fill(m_downRay,m_downRay+m_tree.m_vertexNum,0);",
			"            std::fill(m_downSeg,m_downSeg+m_tree.m_vertexNum,0);",
			"            std::fill(m_upRay,m_upRay+m_tree.m_vertexNum,0);",
			"            std::fill(m_upSeg,m_upSeg+m_tree.m_vertexNum,0);",
			"            auto dfs1 = [&](auto self, uint32_t i) -> void {",
			"                for (uint32_t cur = m_tree.m_starts[i] + (i != m_tree.m_root), end = m_tree.m_starts[i + 1]; cur != end; cur++) {",
			"                    uint32_t to = m_tree.m_to[cur];",
			"                    self(self, to);",
			"                    addDownRay(i, m_downRay[to] + m_tree.m_distances[cur]);",
			"                    addDownSeg(i, m_downSeg[to]);",
			"                }",
			"                chmax(m_downSeg[i], m_ray[i][0] + m_ray[i][1]);",
			"            };",
			"            dfs1(dfs1, m_tree.m_root);",
			"            auto dfs2 = [&](auto self, uint32_t i, _Tp upRay, _Tp upSeg) -> void {",
			"                setUpRay(i, upRay);",
			"                setUpSeg(i, upSeg);",
			"                for (uint32_t cur = m_tree.m_starts[i] + (i != m_tree.m_root), end = m_tree.m_starts[i + 1]; cur != end; cur++) {",
			"                    uint32_t to = m_tree.m_to[cur];",
			"                    _Tp distance = m_tree.m_distances[cur];",
			"                    auto [ray, seg] = maxRaySeg(i, m_downRay[to] + distance, m_downSeg[to]);",
			"                    chmax(seg, ray += distance);",
			"                    self(self, to, ray, seg);",
			"                }",
			"            };",
			"            dfs2(dfs2, m_tree.m_root, 0, 0);",
			"        }",
			"        void addRay(uint32_t __i, _Tp __ray) {",
			"            if (__ray > m_ray[__i][0]) {",
			"                m_ray[__i][2] = m_ray[__i][1];",
			"                m_ray[__i][1] = m_ray[__i][0];",
			"                m_ray[__i][0] = __ray;",
			"            } else if (__ray > m_ray[__i][1]) {",
			"                m_ray[__i][2] = m_ray[__i][1];",
			"                m_ray[__i][1] = __ray;",
			"            } else if (__ray > m_ray[__i][2])",
			"                m_ray[__i][2] = __ray;",
			"        }",
			"        void addSeg(uint32_t __i, _Tp __seg) {",
			"            if (__seg > m_seg[__i][0]) {",
			"                m_seg[__i][1] = m_seg[__i][0];",
			"                m_seg[__i][0] = __seg;",
			"            } else if (__seg > m_seg[__i][1])",
			"                m_seg[__i][1] = __seg;",
			"        }",
			"        void addDownRay(uint32_t __i, _Tp __ray) {",
			"            chmax(m_downRay[__i], __ray);",
			"            addRay(__i, __ray);",
			"        }",
			"        void addDownSeg(uint32_t __i, _Tp __seg) {",
			"            chmax(m_downSeg[__i], __seg);",
			"            addSeg(__i, __seg);",
			"        }",
			"        void setUpRay(uint32_t __i, _Tp __ray) {",
			"            m_upRay[__i] = __ray;",
			"            addRay(__i, __ray);",
			"        }",
			"        void setUpSeg(uint32_t __i, _Tp __seg) {",
			"            m_upSeg[__i] = __seg;",
			"            addSeg(__i, __seg);",
			"        }",
			"        auto maxRaySeg(uint32_t __i, _Tp __exceptRay, _Tp __exceptSeg) const {",
			"            struct _RaySeg {",
			"                _Tp ray, seg;",
			"            };",
			"            _Tp ray = __exceptRay == m_ray[__i][0] ? m_ray[__i][1] : m_ray[__i][0];",
			"            _Tp seg = __exceptSeg == m_seg[__i][0] ? m_seg[__i][1] : m_seg[__i][0];",
			"            _Tp rays = __exceptRay == m_ray[__i][0] ? m_ray[__i][1] + m_ray[__i][2] : (__exceptRay == m_ray[__i][1] ? m_ray[__i][0] + m_ray[__i][2] : m_ray[__i][0] + m_ray[__i][1]);",
			"            return _RaySeg{ray, std::max(seg, rays)};",
			"        }",
			"    };",
			"}",
		],
		"description": "Seg Ray Length Helper"
	},
	"Tarjan LCA":{
		"prefix": "LCA",
		"body": [
			"namespace OY {",
			"    template <typename _Tree, uint32_t _MAXM>",
			"    struct TarjanLCA {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        _Tree &m_tree;",
			"        struct _QueryEdge {",
			"            uint32_t from, to;",
			"        } m_queryEdges[_MAXM];",
			"        uint32_t m_answer[_MAXM];",
			"        uint32_t m_queryIndex[_MAXM * 2];",
			"        uint32_t m_queryTo[_MAXM * 2];",
			"        uint32_t m_queryStarts[_MAXN + 1];",
			"        uint32_t m_find[_MAXN];",
			"        uint32_t m_cursor;",
			"        TarjanLCA(_Tree &__tree) : m_tree(__tree), m_cursor(0) {}",
			"        void addQuery(uint32_t __a, uint32_t __b) { m_queryEdges[m_cursor++] = {__a, __b}; }",
			"        void calc() {",
			"            std::fill(m_queryStarts, m_queryStarts + m_tree.m_vertexNum + 1, 0);",
			"            for (uint32_t i = 0; i < m_cursor; i++)",
			"                if (auto &[from, to] = m_queryEdges[i]; from != to) {",
			"                    m_queryStarts[from + 1]++;",
			"                    m_queryStarts[to + 1]++;",
			"                }",
			"            std::partial_sum(m_queryStarts, m_queryStarts + m_tree.m_vertexNum + 1, m_queryStarts);",
			"            uint32_t cursor[m_tree.m_vertexNum];",
			"            std::copy(m_queryStarts, m_queryStarts + m_tree.m_vertexNum, cursor);",
			"            for (uint32_t i = 0; i < m_cursor; i++)",
			"                if (auto &[from, to] = m_queryEdges[i]; from != to) {",
			"                    m_queryTo[cursor[from]] = to;",
			"                    m_queryIndex[cursor[from]++] = i;",
			"                    m_queryTo[cursor[to]] = from;",
			"                    m_queryIndex[cursor[to]++] = i;",
			"                } else",
			"                    m_answer[i] = from;",
			"            std::bitset<_MAXN> visit;",
			"            std::iota(m_find, m_find + m_tree.m_vertexNum, 0);",
			"            auto dfs = [&](auto self, uint32_t i) -> void {",
			"                m_find[i] = i;",
			"                visit.set(i);",
			"                for (uint32_t cur = m_tree.m_starts[i], end = m_tree.m_starts[i + 1]; cur != end; cur++)",
			"                    if (uint32_t to = m_tree.m_to[cur]; !visit[to]) {",
			"                        self(self, to);",
			"                        m_find[to] = i;",
			"                    }",
			"                for (uint32_t cur = m_queryStarts[i], end = m_queryStarts[i + 1]; cur != end; cur++)",
			"                    if (uint32_t to = m_queryTo[cur]; visit[to]) m_answer[m_queryIndex[cur]] = Find(to);",
			"            };",
			"            dfs(dfs, m_tree.m_root);",
			"        }",
			"        uint32_t Find(uint32_t __i) {",
			"            return m_find[__i] == __i ? __i : m_find[__i] = Find(m_find[__i]);",
			"        }",
			"    };",
			"}",
		],
		"description": "Tarjan LCA"
	},
	"Tree":{
		"prefix": "TREE",
		"body": [
			"namespace OY {",
			"#pragma pack(4)",
			"    template <typename _Tp>",
			"    struct _TreeEdge {",
			"        uint32_t from, to;",
			"        _Tp distance;",
			"    };",
			"    template <>",
			"    struct _TreeEdge<bool> {",
			"        uint32_t from, to;",
			"    };",
			"    template <typename _Tp, uint32_t _N>",
			"    struct _TreeDistance {",
			"        _Tp data[_N];",
			"        void set(uint32_t __i, _Tp __val) { data[__i] = __val; }",
			"        _Tp &operator[](uint32_t __i) { return data[__i]; }",
			"        const _Tp &operator[](uint32_t __i) const { return data[__i]; }",
			"    };",
			"    template <uint32_t _N>",
			"    struct _TreeDistance<bool, _N> {",
			"        void set(uint32_t, bool) {}",
			"        constexpr bool operator[](uint32_t) { return true; }",
			"    };",
			"#pragma pack()",
			"    template <uint32_t _MAXN, typename _Tp = bool>",
			"    struct Tree {",
			"        _TreeEdge<_Tp> m_edges[_MAXN];",
			"        uint32_t m_to[_MAXN * 2];",
			"        _TreeDistance<_Tp, _MAXN * 2> m_distances;",
			"        uint32_t m_starts[_MAXN + 1];",
			"        uint32_t m_vertexNum;",
			"        uint32_t m_root;",
			"        uint32_t m_cursor;",
			"        using distance_type = std::conditional_t<std::is_same_v<_Tp, bool>, uint32_t, _Tp>;",
			"        Tree(uint32_t __vertexNum) : m_vertexNum(__vertexNum), m_root(-1), m_cursor(0) {}",
			"        static Tree<_MAXN, bool> fromParentArray(const std::vector<int> &__parent) {",
			"            Tree<_MAXN, bool> res(__parent.size());",
			"            for (uint32_t i = 0; i < __parent.size(); i++)",
			"                if (~__parent[i]) res.addEdge(i, __parent[i]);",
			"            res.prepare();",
			"            return res;",
			"        }",
			"        static Tree<_MAXN, bool> fromEdges(const std::vector<std::vector<int>> &__edges) {",
			"            Tree<_MAXN, bool> res(__edges.size() + 1);",
			"            for (uint32_t i = 0; i < __edges.size(); i++) res.addEdge(__edges[i][0], __edges[i][1]);",
			"            res.prepare();",
			"            return res;",
			"        }",
			"        void addEdge(uint32_t __a, uint32_t __b) { m_edges[m_cursor++] = {__a, __b}; }",
			"        void addEdge(uint32_t __a, uint32_t __b, _Tp __distance) { m_edges[m_cursor++] = {__a, __b, __distance}; }",
			"        void prepare() {",
			"            std::fill(m_starts, m_starts + m_vertexNum + 1, 0);",
			"            for (uint32_t i = 0; i < m_cursor; i++) {",
			"                m_starts[m_edges[i].from + 1]++;",
			"                m_starts[m_edges[i].to + 1]++;",
			"            }",
			"            std::partial_sum(m_starts, m_starts + m_vertexNum + 1, m_starts);",
			"            uint32_t cursor[m_vertexNum];",
			"            std::copy(m_starts, m_starts + m_vertexNum, cursor);",
			"            for (uint32_t i = 0; i < m_cursor; i++)",
			"                if constexpr (std::is_same_v<_Tp, bool>) {",
			"                    auto &[from, to] = m_edges[i];",
			"                    m_to[cursor[from]++] = to;",
			"                    m_to[cursor[to]++] = from;",
			"                } else {",
			"                    auto &[from, to, distance] = m_edges[i];",
			"                    m_to[cursor[from]] = to;",
			"                    m_distances.set(cursor[from]++, distance);",
			"                    m_to[cursor[to]] = from;",
			"                    m_distances.set(cursor[to]++, distance);",
			"                }",
			"        }",
			"        void setRoot(uint32_t __root) {",
			"            auto dfs = [this](auto self, uint32_t i, uint32_t from) -> void {",
			"                for (uint32_t start = m_starts[i], end = m_starts[i + 1], cur = start; cur != end; cur++)",
			"                    if (uint32_t to = m_to[cur]; to != from)",
			"                        self(self, to, i);",
			"                    else {",
			"                        std::swap(m_to[start], m_to[cur]);",
			"                        if constexpr (!std::is_same_v<_Tp, bool>) std::swap(m_distances[start], m_distances[cur]);",
			"                    }",
			"            };",
			"            dfs(dfs, m_root = __root, -1);",
			"        }",
			"        uint32_t getParent(uint32_t __i) const { return __i == m_root ? -1 : m_to[m_starts[__i]]; }",
			"        std::vector<distance_type> getDistance(uint32_t __source) const {",
			"            std::vector<distance_type> res(m_vertexNum);",
			"            auto dfs = [&](auto self, uint32_t i, uint32_t from, distance_type curDistance) -> void {",
			"                res[i] = curDistance;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur != end; cur++)",
			"                    if (uint32_t to = m_to[cur]; to != from) self(self, to, i, curDistance + m_distances[cur]);",
			"            };",
			"            dfs(dfs, __source, -1, 0);",
			"            return res;",
			"        }",
			"        template <typename _Mapping, typename _Merge, typename _Afterwork = std::nullptr_t>",
			"        auto getSubtreeValues(_Mapping __map, _Merge __merge, _Afterwork __work = _Afterwork()) {",
			"            using _Fp = decltype(__map(0));",
			"            std::vector<_Fp> res(m_vertexNum);",
			"            auto dfs = [&](auto self, uint32_t i) -> void {",
			"                res[i] = __map(i);",
			"                for (uint32_t cur = m_starts[i] + (i != m_root), end = m_starts[i + 1]; cur != end; cur++) {",
			"                    uint32_t to = m_to[cur];",
			"                    self(self, to);",
			"                    if constexpr (std::is_invocable_v<_Merge, _Fp &, _Fp &, uint32_t, uint32_t>)",
			"                        __merge(res[i], res[to], i, to);",
			"                    else if constexpr (std::is_invocable_v<_Merge, _Fp &, _Fp &, uint32_t>)",
			"                        __merge(res[i], res[to], i);",
			"                    else",
			"                        __merge(res[i], res[to]);",
			"                }",
			"                if constexpr (std::is_invocable_v<_Afterwork, _Fp &, uint32_t>) __work(res[i], i);",
			"            };",
			"            dfs(dfs, m_root);",
			"            return res;",
			"        }",
			"        template <typename _Mapping>",
			"        auto getDistanceSum(_Mapping __map) const {",
			"            decltype(__map(0)) size[m_vertexNum];",
			"            struct _Distance {",
			"                distance_type downSum, upSum;",
			"            };",
			"            std::vector<_Distance> res(m_vertexNum);",
			"            auto dfs1 = [&](auto self, uint32_t i) -> void {",
			"                res[i].downSum = 0;",
			"                size[i] = __map(i);",
			"                for (uint32_t cur = m_starts[i] + (i != m_root), end = m_starts[i + 1]; cur != end; cur++) {",
			"                    uint32_t to = m_to[cur];",
			"                    self(self, to);",
			"                    size[i] += size[to];",
			"                    res[i].downSum += res[to].downSum + size[to] * m_distances[cur];",
			"                }",
			"            };",
			"            dfs1(dfs1, m_root);",
			"            auto dfs2 = [&](auto self, uint32_t i, distance_type upSum) -> void {",
			"                res[i].upSum = upSum;",
			"                for (uint32_t cur = m_starts[i] + (i != m_root), end = m_starts[i + 1]; cur != end; cur++) {",
			"                    uint32_t to = m_to[cur];",
			"                    self(self, to, res[i].upSum + res[i].downSum - res[to].downSum + (size[m_root] - size[to] * 2) * m_distances[cur]);",
			"                }",
			"            };",
			"            dfs2(dfs2, m_root, 0);",
			"            return res;",
			"        }",
			"        std::pair<uint32_t, uint32_t> getCentroid() const {",
			"            std::pair<uint32_t, uint32_t> res{-1, -1};",
			"            auto dfs = [&](auto self, uint32_t i, uint32_t p) -> uint32_t {",
			"                uint32_t size = 1, maxAdj = 0;",
			"                for (uint32_t cur = m_starts[i], end = m_starts[i + 1]; cur != end; cur++)",
			"                    if (uint32_t to = m_to[cur]; to != p) {",
			"                        uint32_t subSize = self(self, to, i);",
			"                        size += subSize;",
			"                        chmax(maxAdj, subSize);",
			"                    }",
			"                chmax(maxAdj, m_vertexNum - size);",
			"                if (maxAdj <= m_vertexNum / 2)",
			"                    if (~res.first)",
			"                        res.second = i;",
			"                    else",
			"                        res.first = i;",
			"                return size;",
			"            };",
			"            dfs(dfs, 0, -1);",
			"            return res;",
			"        }",
			"    };",
			"    template <typename _Ostream, uint32_t _MAXN, typename _Tp>",
			"    _Ostream &operator<<(_Ostream &__out, Tree<_MAXN, _Tp> __tree) { // http://mshang.ca/syntree/",
			"        auto dfs = [&](auto self, uint32_t i) -> void {",
			"            __out << '[' << i;",
			"            for (uint32_t cur = __tree.m_starts[i] + (i != __tree.m_root), end = __tree.m_starts[i + 1]; cur != end; cur++)",
			"                self(self, __tree.m_to[cur]);",
			"            __out << ']';",
			"        };",
			"        dfs(dfs, __tree.m_root);",
			"        return __out;",
			"    }",
			"}",
		],
		"description": "Tree"
	},
	"Tree Adjacent Difference":{
		"prefix": "AD",
		"body": [
			"namespace OY {",
			"    template <typename _Tree, typename _Tp, template <typename...> typename _Solver = HeavyLightDecompositionLCA>",
			"    struct TreeAdjacentDifference {",
			"        static constexpr uint32_t _MAXN = sizeof(_Tree::m_edges) / sizeof(*_Tree::m_edges);",
			"        _Tree &m_tree;",
			"        _Solver<_Tree> m_sol;",
			"        _Tp m_values[_MAXN];",
			"        uint32_t m_queue[_MAXN];",
			"        TreeAdjacentDifference(_Tree &__tree) : m_tree(__tree), m_sol(__tree) {",
			"            std::fill(m_values, m_values + m_tree.m_vertexNum, 0);",
			"            uint32_t deg[m_tree.m_vertexNum], head = 0, tail = 0;",
			"            std::adjacent_difference(m_tree.m_starts + 1, m_tree.m_starts + m_tree.m_vertexNum + 1, deg);",
			"            for (uint32_t i = 0; i < m_tree.m_vertexNum; i++) deg[i]--;",
			"            deg[m_tree.m_root]++;",
			"            for (uint32_t i = 0; i < m_tree.m_vertexNum; i++)",
			"                if (!deg[i]) m_queue[tail++] = i;",
			"            while (tail < m_tree.m_vertexNum - 1)",
			"                if (uint32_t p = m_tree.m_to[m_tree.m_starts[m_queue[head++]]]; !--deg[p]) m_queue[tail++] = p;",
			"        }",
			"        void addVertexValue(uint32_t __a, _Tp __inc) {",
			"            m_values[__a] += __inc;",
			"            if (__a != m_tree.m_root) m_values[m_tree.m_to[m_tree.m_starts[__a]]] -= __inc;",
			"        }",
			"        void addPathValue(uint32_t __a, uint32_t __b, _Tp __inc) {",
			"            if (__a == __b) return addVertexValue(__a, __inc);",
			"            uint32_t p = m_sol.calc(__a, __b);",
			"            m_values[__a] += __inc;",
			"            m_values[__b] += __inc;",
			"            m_values[p] -= __inc;",
			"            if (p != m_tree.m_root) m_values[m_tree.m_to[m_tree.m_starts[p]]] -= __inc;",
			"        }",
			"        void partialSum() {",
			"            for (uint32_t i = 0; i < m_tree.m_vertexNum - 1; i++) m_values[m_tree.m_to[m_tree.m_starts[m_queue[i]]]] += m_values[m_queue[i]];",
			"        }",
			"        void adjacentDifference() {",
			"            for (uint32_t i = m_tree.m_vertexNum - 2; ~i; i--) m_values[m_tree.m_to[m_tree.m_starts[m_queue[i]]]] -= m_values[m_queue[i]];",
			"        }",
			"    };",
			"}",
		],
		"description": "Tree Adjacent Difference"
	},
	"Tree Hash":{
		"prefix": "HASH",
		"body": [
			"namespace OY {",
			"    struct _TreeHashTrieNode : MemoryPool<_TreeHashTrieNode> {",
			"        uint32_t m_id;",
			"        std::unordered_map<uint32_t, _TreeHashTrieNode *> m_sons;",
			"    };",
			"    _TreeHashTrieNode g_treeHashTrie{{}, 0, {}};",
			"    uint32_t g_treeHashCount = 1;",
			"    template <typename _Tree>",
			"    std::vector<uint32_t> getTreeHash(_Tree &__tree, uint32_t __root) {",
			"        __tree.setRoot(__root);",
			"        std::vector<uint32_t> res(__tree.m_vertexNum);",
			"        uint32_t deg[__tree.m_vertexNum], queue[__tree.m_vertexNum], head = 0, tail = 0;",
			"        std::fill(deg, deg + __tree.m_vertexNum, 0);",
			"        std::adjacent_difference(__tree.m_starts + 1, __tree.m_starts + __tree.m_vertexNum + 1, deg);",
			"        for (uint32_t i = 0; i < __tree.m_vertexNum; i++) deg[i]--;",
			"        deg[__tree.m_root]++;",
			"        for (uint32_t i = 0; i < __tree.m_vertexNum; i++)",
			"            if (!deg[i]) queue[tail++] = i;",
			"        while (head < tail) {",
			"            uint32_t i = queue[head++], childNum = __tree.m_starts[i + 1] - __tree.m_starts[i] - (i != __tree.m_root);",
			"            uint32_t childHash[childNum];",
			"            for (uint32_t cur = __tree.m_starts[i] + (i != __tree.m_root), index = 0; index < childNum; cur++) childHash[index++] = res[__tree.m_to[cur]];",
			"            std::sort(childHash, childHash + childNum);",
			"            _TreeHashTrieNode *cur = &g_treeHashTrie;",
			"            for (uint32_t a : childHash) {",
			"                auto find = cur->m_sons.find(a);",
			"                if (find == cur->m_sons.end()) find = cur->m_sons.emplace(a, new _TreeHashTrieNode{{}, uint32_t(-1), {}}).first;",
			"                cur = find->second;",
			"            }",
			"            if (!~cur->m_id) cur->m_id = g_treeHashCount++;",
			"            res[i] = cur->m_id;",
			"            if (i != __tree.m_root)",
			"                if (uint32_t p = __tree.m_to[__tree.m_starts[i]]; !--deg[p]) queue[tail++] = p;",
			"        }",
			"        return res;",
			"    }",
			"    template <typename _Tree>",
			"    std::pair<uint32_t, uint32_t> getTreeHash(_Tree &__tree) {",
			"        auto centroid = __tree.getCentroid();",
			"        auto &[r1, r2] = centroid;",
			"        r1 = getTreeHash(__tree, r1)[r1];",
			"        if (~r2) r2 = getTreeHash(__tree, r2)[r2];",
			"        if (r1 > r2) std::swap(r1, r2);",
			"        return centroid;",
			"    }",
			"}",
		],
		"description": "Tree Hash"
	},



	"bipartite":{
		"prefix": "BIPARTITE",
		"body": [
			"namespace OY{",
			"    struct Hungary{",
			"        int left_match[VNUM],right_match[VNUM];",
			"        template<typename T,template<typename U>typename Container>int max_match(DirectedDenseGraph<T,Container>&G){",
			"            static int tag[VNUM],from[VNUM],q[VNUM];int ans=0;",
			"            memset(left_match,0xff,G.n*sizeof(int)),memset(right_match,0xff,G.n*sizeof(int)),memset(tag,0xff,G.n*sizeof(int));",
			"            for(int i=0;i<G.n;i++)if(!~left_match[i]){",
			"                int h=0,t=0;",
			"                auto push=[&](int x,int _from){q[t++]=x,from[x]=_from;};push(i,-1);",
			"                for(bool flag=false;h<t&&!flag;){",
			"                    int p=q[h++];",
			"                    for(auto [to,cost]:G.edges_to_cost(p))if(cost&&tag[to]!=i){",
			"                        tag[to]=i;",
			"                        if(~right_match[to])push(right_match[to],p);",
			"                        else{",
			"                            while(~to){int old=left_match[p];left_match[p]=to,right_match[to]=p;to=old,p=from[p];}",
			"                            flag=true;ans++;break;",
			"                        }",
			"                    }",
			"                }",
			"            }",
			"            return ans;",
			"        }",
			"        template<typename T,template<typename U>typename Container>T max_weight_match(DirectedDenseGraph<T,Container>&G){",
			"            static T left_l[VNUM],right_l[VNUM],slack[VNUM];T ans=0;",
			"            static int from[VNUM];",
			"            static bitset<VNUM>left_visit,right_visit;",
			"            auto aug=[&](int v){while(~v){int u=from[v],vv=left_match[u];right_match[v]=u,left_match[u]=v;v=vv;}};",
			"            auto bfs=[&](int i){",
			"                left_visit.reset();right_visit.reset();",
			"                fill(slack,slack+G.n,G.inf);",
			"                static int q[VNUM];int h=0,t=0;",
			"                auto push=[&](int x){q[t++]=x,left_visit.set(x);};push(i);",
			"                while(true){",
			"                    while(h<t){",
			"                        int p=q[h++];",
			"                        for(int i=0;i<G.n;i++)if(!right_visit[i]&&ckmin(slack[i],left_l[p]+right_l[i]-G.edge_cost(p,i))){",
			"                            from[i]=p;",
			"                            if(!slack[i])if(~right_match[i])right_visit.set(i),push(right_match[i]);",
			"                            else{aug(i);return;}",
			"                        }",
			"                    }",
			"                    T d=G.inf;",
			"                    for(int i=0;i<G.n;i++)if(!right_visit[i])ckmin(d,slack[i]);",
			"                    for(int i=0;i<G.n;++i)if(left_visit[i])left_l[i]-=d;",
			"                    for(int i=0;i<G.n;++i)if(right_visit[i])right_l[i]+=d;else slack[i]-=d;",
			"                    for(int i=0;i<G.n;++i)if(!right_visit[i]&&!slack[i])",
			"                        if(~right_match[i])right_visit.set(i),push(right_match[i]);",
			"                        else{aug(i);return;}",
			"                }",
			"            };",
			"            fill(left_l,left_l+G.n,0),fill(right_l,right_l+G.n,0);",
			"            memset(left_match,0xff,G.n*sizeof(int)),memset(right_match,0xff,G.n*sizeof(int));",
			"            for(int i=0;i<G.n;i++)for(int j=0;j<G.n;j++)ckmax(left_l[i],G.edge_cost(i,j));",
			"            for(int i=0;i<G.n;i++)bfs(i);",
			"            for(int i=0;i<G.n;i++)ans+=G.edge_cost(i,left_match[i]);",
			"            return ans;",
			"        }",
			"    };",
			"};",
		],
		"description": "bipartite"
	},
	"min cycle":{
		"prefix": "MINCYCLE",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container,bool directed>T floyd_min_circle_cost(DenseGraph<T,Container,directed>&G){",
			"        static T dist[VNUM][VNUM];T ans=G.inf;",
			"        for(int i=0;i<G.n;i++)for(int j=0;j<G.n;j++)dist[i][j]=G.edge_cost(i,j);",
			"        for(int k=0;k<G.n;k++){",
			"            for(int i=0;i<k;i++)for(int j=0;j<i;j++)ckmin(ans,dist[i][j]+min(G.inf,G.edge_cost(j,k)+G.edge_cost(k,i)));",
			"            for(int i=0;i<G.n;i++)for(int j=0;j<G.n;j++)ckmin(dist[i][j],dist[i][k]+dist[k][j]);",
			"        }",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "min cycle"
	},
	"min cost max flow":{
		"prefix": "MINCOSTMAXFLOW",
		"body": [
			"namespace OY{",
			"    template<typename T,typename F>struct HLPP_mcmf{",
			"        cost_flow<T,F>W[ENUM];",
			"        T phi[VNUM];",
			"        F ex[VNUM];",
			"        int sta[VNUM],stalen=0;",
			"        static constexpr int SCALE=8;",
			"        template<template<typename U>typename Container>pair<T,F>getMaxFlowMinCost(CostFlowNetwork<T,F,Container>&G,int source,int target){",
			"            T cost=0,neg=0,bnd=0,mul=32-std::__countl_zero(G.n);",
			"            F flow;",
			"            for(int i=0;i<G.m;i++){",
			"                auto [from,to,cf]=G.edge(i);",
			"                if(from!=to)W[i]=cf;",
			"                else if(cf.cost<0)neg+=cf.cost*cf.flow,W[i]={0,0};",
			"            }",
			"            auto getMaxFlow=[&](){",
			"                static int height[VNUM],highest,exFi[VNUM*2],exNxt[VNUM],cnt[VNUM*2];",
			"                using iiterator=typename Container<cost_flow<T,F>>::edge_series_idx_to::edge_iterator_idx_to;",
			"                static iiterator its[VNUM],ends[VNUM];",
			"                for(int i=0;i<G.n;i++)its[i]=G.edges_idx_to(i).begin(),ends[i]=G.edges_idx_to(i).end();",
			"                auto push=[&](int v,int idx,int to){",
			"                    if(F f=min(ex[v],W[idx].flow)){",
			"                        if(!ex[to])exNxt[to]=exFi[height[to]],exFi[height[to]]=to;",
			"                        W[idx].flow-=f,W[idx^1].flow+=f,ex[v]-=f,ex[to]+=f;",
			"                    }",
			"                };",
			"                auto discharge=[&](int v){",
			"                    while(true){",
			"                        for(auto&it=its[v];it!=ends[v];++it){",
			"                            auto [idx,to]=*its[v];",
			"                            if(W[idx].flow&&height[v]==height[to]+1){push(v,idx,to);if(!ex[v])break;}",
			"                        }",
			"                        if(!ex[v])break;",
			"                        height[v]=0x3f3f3f3f;",
			"                        for(auto it=G.edges_idx_to(v).begin();it!=ends[v];++it){",
			"                            auto [idx,to]=*it;",
			"                            if(W[idx].flow&&ckmin(height[v],height[to]+1))its[v]=it;",
			"                        }",
			"                        ++cnt[height[v]];",
			"                        if(!--cnt[highest]&&highest<G.n)",
			"                            for(int i=0;i<G.n;i++)if(height[i]>highest&&height[i]<G.n){",
			"                                cnt[height[i]]--,height[i]=G.n+1,cnt[height[i]]++;",
			"                            }",
			"                        highest=height[v];",
			"                    }",
			"                };",
			"                fill(height,height+G.n,0);height[source]=G.n;",
			"                cnt[0]=G.n-1,cnt[G.n]=1;",
			"                fill(ex,ex+G.n,0);ex[source]=G.T_inf,ex[target]=-G.T_inf;",
			"                memset(exFi,0xff,G.n*2*sizeof(int)),memset(exNxt,0xff,G.n*sizeof(int));",
			"                for(auto [idx,to]:G.edges_idx_to(source))push(source,idx,to);",
			"                for(highest=~exFi[0]?0:-1;~highest;highest--)while(~exFi[highest]){",
			"                    int v=exFi[highest];exFi[highest]=exNxt[v];discharge(v);",
			"                }",
			"                return ex[target]+G.T_inf;",
			"            };",
			"            auto push=[&](int v,int idx,int to,F f,bool pushToStack){",
			"                if(!f)return;",
			"                W[idx].flow-=f,W[idx^1].flow+=f,ex[v]-=f,ex[to]+=f;",
			"                if(pushToStack&&ex[to]>0&&ex[to]<=f)sta[stalen++]=to;",
			"            };",
			"            auto lookAhead=[&](int v){",
			"                if(ex[v])return false;",
			"                T delta=G.T_inf;",
			"                for(auto [idx,to]:G.edges_idx_to(v))if(W[idx].flow){",
			"                    T c=W[idx].cost+phi[v]-phi[to];",
			"                    if(c<0)return false;",
			"                    else ckmin(delta,c);",
			"                }",
			"                phi[v]-=delta+bnd;return true;",
			"            };",
			"            auto discharge=[&](int v){",
			"                T delta=G.T_inf;",
			"                for(auto [idx,to]:G.edges_idx_to(v))if(W[idx].flow){",
			"                    while(true)if(W[idx].cost+phi[v]-phi[to]>=0){ckmin(delta,W[idx].cost+phi[v]-phi[to]);break;}",
			"                    else if(!lookAhead(to)){push(v,idx,to,min(ex[v],W[idx].flow),true);break;}",
			"                    if (!ex[v])return;",
			"                }",
			"                phi[v]-=delta+bnd;sta[stalen++]=v;",
			"            };",
			"            for(int idx=0;idx<G.m;idx++)cost+=W[idx].cost*W[idx].flow,ckmax(bnd,W[idx].cost<<=mul);",
			"            flow=getMaxFlow();",
			"            fill(phi,phi+G.n,0),fill(ex,ex+G.n,0);",
			"            while(bnd>1){",
			"                bnd=max(bnd/SCALE,T(1));",
			"                for(int idx=0;idx<G.m;idx++){",
			"                    auto [v,to,_]=G.edge(idx);",
			"                    if(W[idx].flow&&W[idx].cost+phi[v]-phi[to]<0)push(v,idx,to,W[idx].flow,false);",
			"                }",
			"                for(int v=0;v<G.n;v++)if(ex[v]>0)sta[stalen++]=v;",
			"                while(stalen)discharge(sta[--stalen]);",
			"            }",
			"            for(int idx=0;idx<G.m;idx++)cost-=(W[idx].cost>>mul)*W[idx].flow;",
			"            return {cost/2+neg,flow};",
			"        }",
			"    };",
			"};",
		],
		"description": "mincost maxflow"
	},
	"blossom":{
		"prefix": "BLOSSOM",
		"body": [
			"namespace OY{",
			"    struct Blossom{",
			"        int match[VNUM];",
			"        template<typename T,template<typename U>typename Container>int max_match(UndirectedGraph<T,Container>&G){",
			"            static int find[VNUM],from[VNUM],tag[VNUM],Time=0;",
			"            static bitset<VNUM>vis,inq;",
			"            static queue<int>q;",
			"            function<int(int)>Find=[&](int i){return find[i]==i?i:find[i]=Find(find[i]);};",
			"            auto lca=[&](int a,int b){",
			"                for(Time++;tag[a]!=Time;){if(~a)tag[a]=Time,a=~match[a]?Find(from[match[a]]):-1;if(~b)swap(a,b);}",
			"                return a;",
			"            };",
			"            auto blossom=[&](int a,int b,int l){",
			"                for(;Find(a)!=l;b=match[a],a=from[b]){",
			"                    from[a]=b;",
			"                    if(vis[match[a]]&&!inq[match[a]])inq.set(match[a]),q.push(match[a]);",
			"                    if(find[a]==a)find[a]=l;",
			"                    if(find[match[a]]==match[a])find[match[a]]=l;",
			"                }",
			"            };",
			"            auto aug=[&](int v){while(~v){int u=from[v],vv=match[u];match[v]=u,match[u]=v;v=vv;}};",
			"            auto bfs=[&](int x){",
			"                iota(find,find+G.n,0);",
			"                vis.reset(),inq.reset();",
			"                while(q.size())q.pop();",
			"                vis.set(x),inq.set(x),q.push(x);",
			"                while(q.size()){",
			"                    int p=q.front();q.pop();",
			"                    for(auto [idx,to]:G.edges_idx_to(p)){",
			"                        if(!vis[to]){",
			"                            from[to]=p,vis.set(to);",
			"                            if(!~match[to]){aug(to);return 1;}",
			"                            vis.set(match[to]),inq.set(match[to]),q.push(match[to]);",
			"                        }",
			"                        else if(inq[to]&&Find(to)!=Find(p)){",
			"                            int l=lca(Find(to),Find(p));",
			"                            blossom(to,p,l),blossom(p,to,l);",
			"                        }",
			"                    }",
			"                }",
			"                return 0;",
			"            };",
			"            int ans=0;",
			"            memset(match,0xff,G.n*sizeof(int));",
			"            for(int i=G.n-1;i>=0;i--)if(!~match[i])ans+=bfs(i);",
			"            return ans;",
			"        }",
			"    };",
			"};",
		],
		"description": "blossom"
	}
}