### 一、模板类别

​	数学：扩展欧几里得算法。

### 二、模板功能

#### 1.求解最大公约数

1. 数据类型

   输入参数 `int64_t a` ，表示第一个数。

   输入参数 `int64_t b` ，表示第二个数。

   返回类型 `_exEucAns` ，其 `g` 属性表示求出的最大公约数，`k1` 属性和 `k2` 属性表示配平数。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本模板基于欧几里得算法求解最大公约数，并给出 `a` 和 `b` 的配平数，使得 `a*k1+b*k2=g` 。这样的配平数可以存在无数多组，但只返回其中一组。
   特别的，当 `a=b=0` 时，返回 `g=k1=k2=0` 。

#### 2.求解配平式

1. 数据类型

   输入参数 `int64_t a` ，表示第一个数。

   输入参数 `int64_t b` ，表示第二个数。

   输入参数 `int64_t c` ，表示等于的值。

   返回类型 `_exEucAns` ，其 `g` 属性表示求出的最大公约数， `res` 属性表示配平式的值，`k1` 属性表示 `a` 的配平数。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本模板基于欧几里得算法计算配平数，使得 `a*k1+b*k2=c` 。这样的配平数可以存在无数多组，返回的一组是令 `k1>=0` 且 `k1` 最小的一组，也就是 `k1` 为最小的非负整数的一组。本算法只偏重计算合适的 `k1` ，所以 `k2` 很有可能超出一定的数值范围，所以没有返回 `k2` 。

   **注意：** 当无法配平时，返回 `res=0` 。所以只需要检查返回的 `res` 属性就可以知道配平成功与否。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/ExtendedEuclidean.h"

int main() {
    int a = 100;
    int b = -85;
    //只找出最大公约数
    auto [g, k1, k2] = OY::ExtendedEuclidean(a, b);
    cout << "gcd of " << a << " and " << b << " is: " << g << endl;
    cout << a << " * " << k1 << " + " << b << " * " << k2 << " = " << g << endl;

    //尝试配平 -20
    int c = -20;
    auto [g2, res, k3] = OY::ExtendedEuclidean(a, b, c);
    if (res == c) {
        cout << "gcd of " << a << " and " << b << " is: " << g2 << endl;
        auto k4 = (c - k3 * a) / b;
        cout << a << " * " << k3 << " + " << b << " * " << k4 << " = " << res << endl;
    } else {
        cout << "failed\n";
    }
}
```

```
#输出如下
gcd of 100 and -85 is: 5
100 * 6 + -85 * 7 = 5
gcd of 100 and -85 is: 5
100 * 10 + -85 * 12 = -20

```

