### 一、模板类别

​	数学： `Pollard Rho` 算法。

### 二、模板功能

#### 1.找出一个非平凡因数

1. 数据类型

   模板参数 `typename _Elem` ，可以为 `uint32_t` 或者 `uint64_t` ，表示元素类型。

   输入参数 `_Elem n` ，表示要查询的数。

2. 时间复杂度

    $O(n^\frac{1}{4})$ 。

3. 备注

   本函数用于找出某一数字的某个非平凡因数。

   本函数的时间复杂度为基于概率的时间复杂度。

   本模板与其他利用筛预处理，然后分解质因数的模板的区别是：

   1. 本模板的适用数值范围更大，可以用于 `[1, 2^63)` 范围内的数；
   2. 本模板无需预处理；
   3. 本模板的分解速度略慢。

   **注意：** 在传参时，请保证传入的参数为合数。

#### 2.分解质因数

1. 数据类型

   模板参数 `typename _Elem` ，可以为 `uint32_t` 或者 `uint64_t` ，表示元素类型。

   输入参数 `_Elem n` ，表示要查询的数。

   返回类型 `std::vector<node>` ，其中 `node` 包含 `prime` 和 `count` 两个属性，表示包含的质因子以及包含的数量。所有的 `node` 按照 `prime` 升序排列。

2. 时间复杂度

    $O(n^\frac{1}{4})$ 。

3. 备注

   本函数用于找出某一数字的所有质因数。

   本函数的时间复杂度为基于概率的时间复杂度。

#### 3.找出所有因数

1. 数据类型

   模板参数 `typename _Elem` ，可以为 `uint32_t` 或者 `uint64_t` ，表示元素类型。

   输入参数 `_Elem n` ，表示要查询的数。

   返回类型 `std::vector<_Elem>` ，表示升序排列的所有因数。

2. 时间复杂度

    $O(n^\frac{1}{4})$ 。

3. 备注

   本函数用于找出某一数字的所有因数。
   
   本函数首先找出所有质因子，再组合生成所有的因子。一般前一个过程耗时较大，所以时间复杂度与分解质因数的时间复杂度相同。

#### 4.求欧拉函数

1. 数据类型

   模板参数 `typename _Elem` ，可以为 `uint32_t` 或者 `uint64_t` ，表示元素类型。

   输入参数 `_Elem n` ，表示要查询的数。

2. 时间复杂度

    $O(n^\frac{1}{4})$ 。


### 三、模板示例

```c++
#include "MATH/PollardRho.h"
#include "IO/FastIO.h"

int main(){
    uint64_t A=2ull*3*3*5*5*95986273*265988969;
    auto pf=OY::Pollard_Rho::decomposite(A);
    for(auto [p,c]:pf){
        cout<<p<<'^'<<c<<endl;
    }

    uint64_t B=2*3*5*7;
    auto fs=OY::Pollard_Rho::getFactors(B);
    for(auto f:fs){
        cout<<B<<" % "<<f<<" = "<<B%f<<endl;
    }
}
```

```
#输出如下
2^1
3^2
5^2
95986273^1
265988969^1
210 % 1 = 0
210 % 2 = 0
210 % 3 = 0
210 % 5 = 0
210 % 6 = 0
210 % 7 = 0
210 % 10 = 0
210 % 14 = 0
210 % 15 = 0
210 % 21 = 0
210 % 30 = 0
210 % 35 = 0
210 % 42 = 0
210 % 70 = 0
210 % 105 = 0
210 % 210 = 0

```

