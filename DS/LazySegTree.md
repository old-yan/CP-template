### 一、模板类别

​	数据结构：带懒惰标记的线段树

### 二、模板功能

#### 1.建立线段树

1. 数据类型

   模板参数 `typename _Tp` ，表示原有元素的类型。

   模板参数 `typename _Fp` ，表示增量元素的类型。

   模板参数 `typename _Operation` ，表示区间操作函数的类，默认为 `std::plus<_Tp>` ，也就是加法。

   模板参数 `typename _Mapping` ，表示增值函数的类，默认为 `OY::LazySegAdd<_Tp,_Fp>` ，也就是对某个 `_Tp` 对象增加若干数量的 `_Fp` 对象。

   模板参数 `typename _Composition` ，表示囤积函数的类，默认为 `std::plus<_Fp>` ，也就是加法。

   构造参数 `uint64 __length` ，表示线段树的覆盖范围为 `[0, __length-1]`。

   构造参数 `_Operation __op` ，表示具体的区间操作函数。默认为 `_Operation` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Mapping __map` ，表示具体的增值函数。默认为 `_Mapping` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Composition __com` ，表示具体的囤积函数。默认为 `_Composition` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Tp __defaultValue` ，表示原有元素的默认值，默认为 `_Tp` 类的默认实例。

   构造参数 `_Fp __defaultIncrement` ，表示增值元素的默认值，默认为 `_Fp` 类的默认实例。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   带懒惰标记的线段树处理的问题为单点/区间修改，单点/区间的查询。

   带懒惰标记的线段树要求区间操作函数、增值函数和屯积函数的运算符都满足**结合律**。

   在理解带懒惰标记的线段树的各种参数之前，请先理解普通的线段树参数。

   `_Fp` 不一定是和 `_Tp` 不一样的类，完全可以是相同的类.

   `__op` 函数与线段树的区间操作函数作用相同，为 `_Tp __op(_Tp,_Tp)` 的形式。

   `__map` 函数可以传递二元函数，也可以传递三元函数。如果传递二元函数，为 `_Tp __map(_Fp,_Tp)` 的形式，表示前者为增量，后者为原值，返回原值被增量修改后的值；如果传递三元函数，为 `_Tp __map(_Fp,_Tp,int)` 的形式，第三个参数表示当前结点大小。（为什么要传递第三个参数？不妨考虑一个问题，如果一个结点维护一个长度为 `100` 的区间。此时，令该区间所有元素增加 `5` 的值，请问这段区间的和值增加多少？显然是 `5*100=500`，在这个情境下必须要知道结点大小，才能计算出增量带来的变化大小。）

   `__com` 函数为 `_Fp __com(_Fp,_Fp)` 的形式。表示两个增量会合合之后变成多大的增量。

   **注意：**如果增量的囤积函数不满足交换律，那么请将先来的增量放到第二个参数位置上，后来的增量放到第一个参数位置上。
   
   **注意：** `__defaultValue` 需要满足：`__op(__defaultValue, __defaultValue)==__defaultValue` 。`__defaultIncrement` 需要满足：`__com(__defaultIncrement,__defaultIncrement)==__defaultIncrement`。此外，`__map(__defaultIncrement,__defaultValue,(1))==__defaultValue`。由于 `_Tp,_Fp` 类型不一定支持相等运算符，所以 `_check` 函数默认处于注释掉的状态。如果取消注释，则会在建树时进行检查。
   
   **注意：**本数据结构名为 `LazySegTree` ，和 `LazyZkwTree` 一样都是带懒惰标记的线段树。区别在于：
   
   1. 大多数人熟悉、使用 `LazySegTree` ，而 `LazyZkwTree` 较少有人使用；
   2. `LazySegTree` 可以处理维护较大范围的区间（甚至可以达到 $10^9$ ），因为 `LazySegTree` 可以动态开点，即树不一定是满二叉树，初始时可以是空的，在需要的时候再去初始化从根到叶子的一条链；而 `LazyZkwTree` 只能处理相对较小范围的区间（$10^6$ 以内），因为 `LazyZkwTree` 必须初始化整颗二叉树；
   3. 在处理较小范围区间的问题时， `LazySegTree` 的时间空间常数都偏大，效率偏低；而 `LazyZkwTree` 具有优秀的时空效率；

#### 2.建立线段树

1. 数据类型

   构造参数 `_Iterator __first` ，表示区间维护的区间头。

   构造参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

   其它同上。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   同上。

   使用迭代器进行初始化，可以将区间初状态直接赋到线段树里。
   
   如果通过本方法构造线段树，请确认区间范围不是特别大（$10^6$ 以内）。本方法将一次性开出树中所有结点。

#### 3.设置内存池大小

1. 数据类型

   输入参数 `uint32_t __count`，表示程序运行最多用到的结点数量。

2. 时间复杂度

   $O(1)$

#### 4.重置

1. 数据类型

   输入参数 `uint64_t __length` ，表示线段树要处理的区间大小。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将线段树大小改变，并将之前的合并信息重置。

#### 5.重置

1. 数据类型

   输入参数 `_Iterator __first` ，表示区间维护的区间头。

   输入参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

2. 时间复杂度

   $O(n)$ 。

3. 备注

   同上。

   使用迭代器进行重置，可以将区间初状态直接赋到线段树里。
   
   如果通过本方法重置线段树，请确认区间范围不是特别大（$10^6$ 以内）。本方法将一次性开出树中所有结点。

#### 6.单点赋值

1. 数据类型

   输入参数 `uint64_t __i` ，表示单点赋值的下标。

   输入参数 `_Tp __val​` ，表示赋的值。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 7.单点增值

1. 数据类型

   输入参数 `uint64_t __i` ，表示单点增值的下标。

   输入参数 `_Fp __inc​` ，表示增量大小。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 8.区间增值

1. 数据类型

   输入参数 `uint64_t __left` ，表示增值的区间起始下标。

   输入参数 `uint64_t __right` ，表示增值的区间结尾下标。（闭区间）

   输入参数 `_Fp __inc​` ，表示增量大小。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 9.单点查询

1. 数据类型

   输入参数 `uint64_t __i` ，表示查询的下标。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）


#### 10.区间查询

1. 数据类型

   输入参数 `uint64_t __left` ，表示区间查询的开头下标。

   输入参数 `uint64_t __right`，表示区间查询的结尾下标。(闭区间)

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 11.查询全部

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 12.树上二分查询右边界

1. 数据类型

   输入参数 `uint64_t __left` ，表示左边界。

   输入参数 `_Judge __judge` ，表示需要满足的判断条件。

   返回类型 `uint64_t` ，表示在满足条件情况下的最大右边界。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   假设本函数返回 `r` ，则表示，对于 `i∈[__left, r]`  ，均有 `__judge(__query(__left, i))` 为真。而当 `i>r` 时，有 `__judge(__query(__left, i))` 为假。显然，`r` 的最大值为 `m_length-1` 。

   如果从 `__left` 开始，即使长度为一的区间也不能满足判断条件，那么返回 `__left-1`  。所以 `r` 的最小值为 `__left-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）
   
   **注意：**在树上二分的时候，需确保没有未初始化的结点。

#### 13.树上二分查询左边界

1. 数据类型

   输入参数 `uint64_t __right` ，表示右边界。

   输入参数 `_Judge __judge` ，表示需要满足的判断条件。

   返回类型 `uint64_t` ，表示在满足条件情况下的最小左边界。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   假设本函数返回 `l` ，则表示，对于 `i∈[l, __right]`  ，均有 `__judge(__query(i, __right))` 为真。而当 `i<l` 时，有 `__judge(__query(i, __right))` 为假。显然，`l` 的最小值为 `0` 。

   如果从 `__right` 开始往左走，即使长度为一的区间也不能满足判断条件，那么返回 `__right+1`  。所以 `l` 的最大值为 `__right+1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）
   
   **注意：**在树上二分的时候，需确保没有未初始化的结点。

#### 14.查询第 $k$ 个元素

1. 数据类型

   输入参数 `_Tp __k​` ，表示要查询的元素从小到大的顺次。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   仅当线段树的元素类型 `_Tp` 为数字，且区间操作函数为加法的时候，本方法才有意义。

   顺次 `k​` 表示第 `k+1` 小，顺次 `0` 表示查询最小的元素。
   
   本函数没有进行参数检查，所以请自己确保 `__k` 合法。（位于`[0, queryAll())`）

### 三、模板示例

```c++
#include "DS/LazySegTree.h"
#include "IO/FastIO.h"

int main() {
    // LazySegTree 功能和 LazyZkwTree 是基本一样的
    //这里展示一下 LazySegTree 维护超大范围区间的特点

    //默认无参构造就是日常用的最多的求和树
    OY::LazySegTree tree_sum;
    tree_sum.resize(1000000000);
    cout << "sum(0~999999999)     =" << tree_sum.queryAll() << endl;

    tree_sum.add(0, 800000000, 1);
    tree_sum.add(400000000, 900000000, 2);

    cout << "sum(0~999999999)     =" << tree_sum.queryAll() << endl;
}
```

```
#输出如下
sum(0~999999999)     =0
sum(0~999999999)     =1800000003

```

