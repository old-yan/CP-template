### 一、模板类别

​	数据结构：带懒惰标记的动态开点位集

​	练习题目：

1. [2003. 每棵子树内缺失的最小基因值](https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/)
2. [2166. 设计位集](https://leetcode.cn/problems/design-bitset/)
3. [3161. 物块放置查询](https://leetcode.cn/problems/block-placement-queries/)
4. [#2037. 「SHOI2015」脑洞治疗仪](https://loj.ac/p/2037)
5. [P1503 鬼子进村](https://www.luogu.com.cn/problem/P1503)
6. [P2572 [SCOI2010] 序列操作](https://www.luogu.com.cn/problem/P2572)
7. [P2894 [USACO08FEB] Hotel G](https://www.luogu.com.cn/problem/P2894)
8. [P3201 [HNOI2009] 梦幻布丁](https://www.luogu.com.cn/problem/P3201)
9. [P4344 [SHOI2015] 脑洞治疗仪](https://www.luogu.com.cn/problem/P4344)
10. [P5057 [CQOI2006] 简单题](https://www.luogu.com.cn/problem/P5057)
11. [P10996 【MX-J3-T3】Tuple](https://www.luogu.com.cn/problem/P10996)
12. [P10998 【MX-J3-T3+】Tuple+](https://www.luogu.com.cn/problem/P10998)

### 二、模板功能

#### 1.建立位集

1. 数据类型

   类型设定 `size_type = uint32_t` ，表示树中结点在内存池上的下标的类型。

   模板参数 `typename SizeType` ，表示表示区间长度时，所采用的数的类型。在区间长度为 `1e9` 级别时，采用 `uint32_t` 为佳；区间长度更长时，采用 `uint64_t` 。当然采用有符号数也无大碍。

   构造参数 `SizeType length` ，表示位集的覆盖范围为 `[0, length)`。默认值为 `0` 。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   在标准库中有 `std::bitset` 可以作为位集，但是 `std::bitset` 有长度无法改变、无法进行区间修改、区间查询的缺点。本数据结构实现了区间赋值、区间翻转、区间查询 `1` 的数量的功能。

   在另一文件中，已经实现了 `OY::Bitset::Table` 这一数据结构。但是该数据结构创建的时间复杂度是线性，面对上亿长度时力不从心。本数据结构以动态开点、懒惰更新的思想进行优化，在牺牲一定常数效率的基础上，支持了上亿长度。

   本数据结构没有实现按位左移和按位右移的功能。

#### 2.重置(resize)

1. 数据类型

   输入参数 `SizeType length` ，表示位集的大小为 `length`。

2. 时间复杂度

    $O(1)$ 。

####  3.全部置为1(set)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `1` 。

#### 4.将某一位置为1(set)

1. 数据类型

   输入参数 `SizeType i` ，表示将下标 `i` 位置置为 `1` 。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 5.将某一区间置为1(set)

1. 数据类型

   输入参数 `SizeType left` ，表示要修改的区间的起始下标。

   输入参数 `SizeType right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  6.全部置为0(reset)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `0` 。

#### 7.将某一位置为0(reset)

1. 数据类型

   输入参数 `SizeType i` ，表示将下标 `i` 位置置为 `0` 。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 8.将某一区间置为0(reset)

1. 数据类型

   输入参数 `SizeType left` ，表示要修改的区间的起始下标。

   输入参数 `SizeType right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  9.全部翻转(flip)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将位集的每一位翻转。

#### 10.将某一位置翻转(flip)

1. 数据类型

   输入参数 `SizeType i` ，表示将下标 `i` 翻转。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 11.将某一区间翻转(flip)

1. 数据类型

   输入参数 `SizeType left` ，表示要修改的区间的起始下标。

   输入参数 `SizeType right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 12.查询1的总数(count)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 13.查询区间中1的总数(count)

1. 数据类型

   输入参数 `SizeType left` ，表示要查询的区间的起始下标。

   输入参数 `SizeType right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 14.查询是否有1(any)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 15.查询区间中是否有1(any)

1. 数据类型

   输入参数 `SizeType left` ，表示要查询的区间的起始下标。

   输入参数 `SizeType right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 16.查询是否全为1(all)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 17.查询区间中是否全为1(all)

1. 数据类型

   输入参数 `SizeType left` ，表示要查询的区间的起始下标。

   输入参数 `SizeType right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 18.查询区间内最长连续1

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$  。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 19.查询区间内最长连续0

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$  。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 20.查询第一个1的位置(first_one)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 21.查询最后一个1的位置(last_one)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 22.查询第一个0的位置(first_zero)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `1` ，没有 `0` 时，返回 `-1` 。

#### 23.查询最后一个0的位置(last_zero)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `1` ，没有 `0` 时，返回 `-1` 。

#### 24.查询前一个1的位置(prev_one)

1. 数据类型

   输入参数 `SizeType i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之前全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 25.查询后一个1的位置(next_one)

1. 数据类型

   输入参数 `SizeType i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之后全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 26.查询前一个0的位置(prev_zero)

1. 数据类型

   输入参数 `SizeType i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之前全部都是 `1` ，没有 `0` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 27.查询后一个0的位置(next_zero)

1. 数据类型

   输入参数 `SizeType i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之后全部都是 `1` ，没有 `0` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 28.查询某下标(at)

1. 数据类型

   输入参数 `SizeType i` ，表示要查询的下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 29.查询第k个1(kth)

1. 数据类型

   输入参数 `SizeType k` ，表示要查询的排名。

   输入参数 `SizeType pos` ，表示从 `pos` 位置开始数。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 30.树上二分查询右边界(max_right)

1. 数据类型

   模板参数 `typename Getter` ，表示结点属性访问器。
   
   输入参数 `SizeType left` ，表示左边界。

   输入参数 `Judger &&judge` ，表示需要满足的判断条件。

   返回类型 `SizeType` ，表示在满足条件情况下的最大右边界。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   假设本函数返回 `r` ，则表示，对于 `i∈[left, r]`  ，均有 `judge(query(left, i))` 为真。而当 `i>r` 时，有 `judge(query(left, i))` 为假。显然，`r` 的最大值为 `m_size-1` 。

   如果从 `left` 开始，即使长度为一的区间也不能满足判断条件，那么返回 `left-1`  。所以 `r` 的最小值为 `left-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 31.树上二分查询左边界(min_left)

1. 数据类型

   模板参数 `typename Getter` ，表示结点属性访问器。
   
   输入参数 `SizeType right` ，表示右边界。

   输入参数 `Judger &&judge` ，表示需要满足的判断条件。

   返回类型 `SizeType` ，表示在满足条件情况下的最小左边界。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   假设本函数返回 `l` ，则表示，对于 `i∈[l, right]`  ，均有 `judge(query(i, right))` 为真。而当 `i<l` 时，有 `judge(query(i, right))` 为假。显然，`l` 的最小值为 `0` 。

   如果从 `right` 开始往左走，即使长度为一的区间也不能满足判断条件，那么返回 `right+1`  。所以 `l` 的最大值为 `right+1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 32.枚举所有的零(enumerate_zero)

1. 数据类型

   输入参数 `Callback &&call` ，表示对每个为零的位置调用的回调函数。

2. 时间复杂度

   $O(n)$ ，此处 `n` 指零的个数。

#### 31.枚举所有的一(enumerate_one)

1. 数据类型

   输入参数 `Callback &&call` ，表示对每个为一的位置调用的回调函数。

2. 时间复杂度

   $O(n)$ ，此处 `n` 指一的个数。
   
#### 33.枚举所有的一的区间(enumerate_range)

1. 数据类型

   输入参数 `Callback &&call` ，表示对每个为一的连续区间调用的回调函数。

2. 时间复杂度

   $O(n)$ ，此处 `n` 指一的段数。
   

#### 三、模板示例

```c++
#include "DS/LazyBitset.h"
#include "IO/FastIO.h"

void test() {
    OY::VectorLazyBitset<uint32_t> B(100000000);
    // 将区间置为 1
    B.set(10000000, 30000000);
    cout << "B[10000000~20000000]=" << B.count(10000000, 20000000) << endl;
    // 将区间置为 0
    B.reset(5000000, 14000000);
    cout << "B[10000000~20000000]=" << B.count(10000000, 20000000) << endl;
    // 将整个位集翻转
    B.flip();
    cout << "B[10000000~20000000]=" << B.count(10000000, 20000000) << endl;

    for (int i = 13950000; i < 14050000; i += 10000)
        cout << "index " << i << ":" << B.at(i) << endl;

    // 全部置为 0
    B.reset();

    B.set(160000);
    B.set(9800000);
    B.set(3570000);
    B.set(20000);
    for (int i = B.first_one(); i >= 0; i = B.next_one(i))
        cout << i << ' ';
    cout << endl;
    for (int i = B.last_one(); i >= 0; i = B.prev_one(i))
        cout << i << ' ';
    cout << endl;
}
void test_merge() {
    OY::VectorLazyBitset<uint32_t> S1(10), S2(10), S3(10);
    for (int i : {2, 3, 4, 6, 9}) S1.set(i);
    for (int i : {1, 2, 5, 6, 8}) S2.set(i);
    cout << "S1:" << S1 << endl;
    cout << "S2:" << S2 << endl;
    cout << "after S1&=S2:" << (S1 &= S2) << endl;

    for (int i : {0, 4, 6, 8}) S3.set(i);
    cout << "S3:" << S3 << endl;
    cout << "after S1&=S3:" << (S1 |= S3) << endl;
}

int main() {
    test();
    test_merge();
}
```

```
#输出如下
B[10000000~20000000]=10000001
B[10000000~20000000]=6000000
B[10000000~20000000]=4000001
index 13950000:1
index 13960000:1
index 13970000:1
index 13980000:1
index 13990000:1
index 14000000:1
index 14010000:0
index 14020000:0
index 14030000:0
index 14040000:0
20000 160000 3570000 9800000 
9800000 3570000 160000 20000 
S1:[2, 3, 4, 6, 9]
S2:[1, 2, 5, 6, 8]
after S1&=S2:[2, 6]
S3:[0, 4, 6, 8]
after S1&=S3:[0, 2, 4, 6, 8]

```

