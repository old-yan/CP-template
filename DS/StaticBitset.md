### 一、模板类别

​	数据结构：静态大小的位集

​	练习题目：

1. [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
2. [3161. 物块放置查询](https://leetcode.cn/problems/block-placement-queries/)
3. [3181. 执行操作可获得的最大总奖励 II](https://leetcode.cn/problems/maximum-total-reward-using-operations-ii/)
4. [P5020 [NOIP2018 提高组] 货币系统](https://www.luogu.com.cn/problem/P5020)


### 二、模板功能

#### 1.建立位集

1. 数据类型

   类型设定 `size_type = uint32_t` ，表示位集下标类型。

   模板参数 `size_type N` ，表示位集的最大大小为 `N`。

2. 时间复杂度

   $O(\frac n \omega )$ ，其中 `ω` 表示 `mask_type` 所包含的比特数量。

3. 备注

   在标准库中有 `std::bitset` 可以作为位集，但是 `std::bitset` 有无法进行区间修改、区间查询的缺点。本数据结构实现了区间赋值、区间翻转、区间查询 `1` 的数量的功能。

   一般来说，本数据结构的时间复杂度很差，但是跑起来的性能很优。故在函数中除了时间复杂度，还会介绍在 `atcoder` 环境下、最坏情况下的实际运行速度，使用语言为 `C++23(gcc12.2)` 。从数据可以看出，本数据结构处理 `1e5` 规模的 $O(n^2)$ 问题绰绰有余。

####  2.全部置为1(set)

1. 数据类型

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `1` 。
   
   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `1.8s` 。

#### 3.将某一位置为 1(set)

1. 数据类型

   输入参数 `size_type i` ，表示将下标 `i` 位置置为 `1` 。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 4.将某一区间置为 1(set)

1. 数据类型

   输入参数 `size_type left` ，表示要修改的区间的起始下标。

   输入参数 `size_type right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\frac n {\omega})$ 。

3. 备注

   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `4.8s` 。
   
   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  5.全部置为 0(reset)

1. 数据类型

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `0` 。
   
   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `1.8s` 。

#### 6.将某一位置为 0(reset)

1. 数据类型

   输入参数 `size_type i` ，表示将下标 `i` 位置置为 `0` 。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 7.将某一区间置为 0(reset)

1. 数据类型

   输入参数 `size_type left` ，表示要修改的区间的起始下标。

   输入参数 `size_type right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `4.8s` 。
   
   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  8.全部翻转(flip)

1. 数据类型

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   调用本函数会将位集的每一位翻转。
   
   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `7.1s` 。

#### 9.将某一位置翻转(flip)

1. 数据类型

   输入参数 `size_type i` ，表示将下标 `i` 位置翻转。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 10.将某一区间翻转(flip)

1. 数据类型

   输入参数 `size_type left` ，表示要修改的区间的起始下标。

   输入参数 `size_type right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `8.9s` 。
   
   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 11.查询1的总数(count)

1. 数据类型

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `7.4s` 。

#### 12.查询区间中1的总数(count)

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `7.4s` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 13.查询是否有1(any)

1. 数据类型

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `5.2s` 。


#### 14.查询区间中是否有1(any)

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `5.1s` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 15.查询是否全为1(all)

1. 数据类型

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `9.0s` 。

#### 16.查询区间中是否全为1(all)

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   对 `1e6` 大小的位集进行 `1e6` 次操作，耗时约 `9.0s` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 17.查询区间内最长连续1

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\frac n w)$  。

3. 备注

   对 `5e5` 大小的位集进行 `5e5` 次操作，耗时约 `7.0s` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 18.查询区间内最长连续0

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\frac n w)$  。

3. 备注

   对 `5e5` 大小的位集进行 `5e5` 次操作，耗时约 `7.7s` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 19.查询第一个1的位置(first_one)

1. 数据类型

2. 时间复杂度

   $O(\frac n \omega)$ ；配合 `next_one` 进行遍历，则均摊 $O(\frac n {m\cdot\omega})$ ，此处 `m` 指 `1` 的总数。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 20.查询最后一个1的位置(last_one)

1. 数据类型

2. 时间复杂度

   $O(\frac n \omega)$ ；配合 `next_one` 进行遍历，则均摊 $O(\frac n {m\cdot\omega})$ ，此处 `m` 指 `1` 的总数。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 21.查询第一个0的位置(first_zero)

1. 数据类型

2. 时间复杂度

   $O(\frac n \omega)$ ；配合 `next_zero` 进行遍历，则均摊 $O(\frac n {m\cdot\omega})$ ，此处 `m` 指 `0` 的总数。

3. 备注

   当位集中全部都是 `1` ，没有 `0` 时，返回 `-1` 。

#### 22.查询最后一个0的位置(last_zero)

1. 数据类型

2. 时间复杂度

    $O(\frac n \omega)$ ；配合 `prev_zero` 进行遍历，则均摊 $O(\frac n {m\cdot\omega})$ ，此处 `m` 指 `0` 的总数。

3. 备注

   当位集中全部都是 `1` ，没有 `0` 时，返回 `-1` 。

#### 23.查询前一个1的位置(prev_one)

1. 数据类型

   输入参数 `size_type i` ，表示当前下标。

2. 时间复杂度

   $O(\frac n \omega)$ ；配合 `last_one` 进行遍历，则均摊 $O(\frac n {m\cdot\omega})$ ，此处 `m` 指 `1` 的总数。

3. 备注

   当位集中下标 `i` 之前全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 24.查询后一个1的位置(next_one)

1. 数据类型

   输入参数 `size_type i` ，表示当前下标。

2. 时间复杂度

   $O(\frac n \omega)$ ；配合 `first_one` 进行遍历，则均摊 $O(\frac n {m\cdot\omega})$ ，此处 `m` 指 `1` 的总数。

3. 备注

   当位集中下标 `i` 之后全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 25.查询前一个0的位置(prev_zero)

1. 数据类型

   输入参数 `size_type i` ，表示当前下标。

2. 时间复杂度

   $O(\frac n \omega)$ ；配合 `last_zero` 进行遍历，则均摊 $O(\frac n {m\cdot\omega})$ ，此处 `m` 指 `0` 的总数。

3. 备注

   当位集中下标 `i` 之前全部都是 `1` ，没有 `0` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 26.查询后一个0的位置(next_zero)

1. 数据类型

   输入参数 `size_type i` ，表示当前下标。

2. 时间复杂度

   $O(\frac n \omega)$ ；配合 `first_zero` 进行遍历，则均摊 $O(\frac n {m\cdot\omega})$ ，此处 `m` 指 `0` 的总数。

3. 备注

   当位集中下标 `i` 之后全部都是 `1` ，没有 `0` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 27.查询某下标(at)

1. 数据类型

   输入参数 `size_type i` ，表示要查询的下标。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 28.查询第k个1(kth)

1. 数据类型

   输入参数 `size_type k` ，表示要查询的排名。

   输入参数 `size_type pos` ，表示要从 `pos` 位置开始数。默认为 `0` 。

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 29.背包左移(bitor_lshift)

1. 数据类型

   输入参数 `size_type x` ，表示要背包左移的位数。

   输入参数 `size_type range`，表示要将哪个范围的 `1` 进行背包左移。默认为 `-1` 。

2. 时间复杂度

   $O(\frac n \omega)$ 。

3. 备注

   调用本函数 `a.bitor_lshift(x);` 等价于 `a |= a << x;` 。

   当填写 `range` 参数时，认为位集只在 `[0, range)` 区间内有 `1` ，从而避免对全零区间进行操作，更快地实现背包转移。如果 `range` 为默认参数 `-1` ，表示位集的每个位置都可能有 `1` 。
   
   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）


#### 30.按位与(&,&=)

1. 数据类型

   两个同类型、同大小的位集参与运算。

2. 时间复杂度

   $O(\frac n \omega)$ 。
   

#### 31.按位或(|,|=)

1. 数据类型

   两个同类型、同大小的位集参与运算。

2. 时间复杂度

   $O(\frac n \omega)$ 。

#### 32.按位异或(^,^=)

1. 数据类型

   两个同类型、同大小的位集参与运算。

2. 时间复杂度

   $O(\frac n \omega)$ 。

#### 33.向左位移(<<,<<=)

1. 数据类型

   输入参数 `size_type x` ，表示位移的位数。

2. 时间复杂度

   $O(\frac n \omega)$ 。

#### 34.向右位移(>>,>>=)

1. 数据类型

   输入参数 `size_type x` ，表示位移的位数。

2. 时间复杂度

   $O(\frac n \omega)$ 。

#### 35.对所有值为1的位置调用回调(enumerate_one)

1. 数据类型

   输入参数 `Callback &&call` ，表示对每个位置调用的回调。

2. 时间复杂度

   $O(\frac n w)$  。

3. 备注

   本方法比其手动调用 `first_one` 和 `next_one` 速度更快。

#### 36.对所有值为0的位置调用回调(enumerate_zero)

1. 数据类型

   输入参数 `Callback &&call` ，表示对每个位置调用的回调。

2. 时间复杂度

   $O(\frac n w)$  。

3. 备注

   本方法比其手动调用 `first_zero` 和 `next_zero` 速度更快。
   
#### 三、模板示例

```c++
#include "DS/StaticBitset.h"
#include "IO/FastIO.h"

int main() {
    OY::StaticBitset<100000> B;
    // 将区间置为 1
    B.set(10000, 30000);
    cout << "B[10000~20000]=" << B.count(10000, 20000) << endl;
    // 将区间置为 0
    B.reset(5000, 14000);
    cout << "B[10000~20000]=" << B.count(10000, 20000) << endl;
    // 将整个位集翻转
    B.flip();
    cout << "B[10000~20000]=" << B.count(10000, 20000) << endl;

    for (int i = 13950; i < 14050; i += 10)
        cout << "index " << i << ":" << B.at(i) << endl;

    // 全部置为 0
    B.reset();

    B.set(160);
    B.set(9800);
    B.set(3570);
    B.set(20);
    for (int i = B.first_one(); i >= 0; i = B.next_one(i))
        cout << i << ' ';
    cout << endl;

    // 进行一个背包左移
    B.bitor_lshift(1);
    for (int i = B.last_one(); i >= 0; i = B.prev_one(i))
        cout << i << ' ';
    cout << endl;
}
```

```
#输出如下
B[10000~20000]=10001
B[10000~20000]=6000
B[10000~20000]=4001
index 13950:1
index 13960:1
index 13970:1
index 13980:1
index 13990:1
index 14000:1
index 14010:0
index 14020:0
index 14030:0
index 14040:0
20 160 3570 9800 
9801 9800 3571 3570 161 160 21 20 

```

