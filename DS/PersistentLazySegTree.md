### 一、模板类别

​	数据结构：可持久化的带懒惰标记的线段树

### 二、模板功能

#### 1.建立线段树

1. 数据类型

   模板参数 `typename _Tp` ，表示原有元素的类型。

   模板参数 `typename _Fp` ，表示增量元素的类型。

   模板参数 `typename _Operation` ，表示区间操作函数的类，默认为 `std::plus<_Tp>` ，也就是加法。

   模板参数 `typename _Mapping` ，表示增值函数的类，默认为 `OY::LazyZkwAdd<_Tp,_Fp>` ，也就是对某个 `_Tp` 对象增加若干数量的 `_Fp` 对象。

   模板参数 `typename _Composition` ，表示囤积函数的类，默认为 `std::plus<_Fp>` ，也就是加法。

   构造参数 `uint64_t __length` ，表示线段树的覆盖范围为 `[0, __length-1]`。

   构造参数 `_Operation __op` ，表示具体的区间操作函数。默认为 `_Operation` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Mapping __map` ，表示具体的增值函数。默认为 `_Mapping` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Composition __com` ，表示具体的囤积函数。默认为 `_Composition` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Tp __defaultValue` ，表示原有元素的默认值，默认为 `_Tp` 类的默认实例。

   构造参数 `_Fp __defaultIncrement` ，表示增值元素的默认值，默认为 `_Fp` 类的默认实例。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   可持久化线段树可以用于对某个时间某个坐标的单点修改，单点/区间查询。
   
   带懒惰标记的线段树处理的问题为单点/区间修改，单点/区间的查询。
   
   所以，可持久化的带懒惰标记的线段树处理的问题为对某个时间的单点/区间修改，对时间段的单点/区间的查询。
   
   可持久化的带懒惰标记的线段树要求区间操作函数、增值函数和屯积函数的运算符都满足**结合律**。此外，还要求运算符满足**交换律**。
   
   本数据结构的基础是普通线段树、带懒惰标记的线段树、可持久化线段树，请循序渐进。
   
   `_Fp` 不一定是和 `_Tp` 不一样的类，完全可以是相同的类.
   
   `__op` 函数与线段树的区间操作函数作用相同，为 `_Tp __op(_Tp,_Tp)` 的形式。
   
   `__map` 函数可以传递二元函数，也可以传递三元函数。如果传递二元函数，为 `_Tp __map(_Fp,_Tp)` 的形式，表示前者为增量，后者为原值，返回原值被增量修改后的值；如果传递三元函数，为 `_Tp __map(_Fp, _Tp, uint64_t)` 的形式，第三个参数表示当前结点大小。（为什么要传递第三个参数？不妨考虑一个问题，如果一个结点维护一个长度为 `100` 的区间。此时，令该区间所有元素增加 `5` 的值，请问这段区间的和值增加多少？显然是 `5*100=500`，在这个情境下必须要知道结点大小，才能计算出增量带来的变化大小。）
   
   `__com` 函数为 `_Fp __com(_Fp,_Fp)` 的形式。表示两个增量会合合之后变成多大的增量。
   
   **注意：** `__defaultValue` 需要满足：`__op(__defaultValue, __defaultValue)==__defaultValue` 。`__defaultIncrement` 需要满足：`__com(__defaultIncrement,__defaultIncrement)==__defaultIncrement`。此外，`__map(__defaultIncrement,__defaultValue,(1))==__defaultValue`。由于 `_Tp,_Fp` 类型不一定支持相等运算符，所以 `_check` 函数默认处于注释掉的状态。如果取消注释，则会在建树时进行检查。
   
   **注意：**在构造时，必须一次性开够所需的空间。如果区间范围较小，那么空间分配没有问题；如果区间较大( $10^9$ )，显然不可能开这么大的空间，这种场景下对线段树的操作+查询的总次数往往只有 $10^5$ 的数量级甚至更少，所以使用者可以根据操作次数来预估所需空间。一般预留数百万的空间就够用了。默认的预留空间是 `4000000` 。
   
   可持久化线段树可以用于对某个时间某个坐标的单点修改，单点/区间查询。
   
   时间维度，常被称为“版本”，初始化后的版本号为 `0` ，以后每次有修改时自动向后生成一个版本号。
   
   坐标维度的范围为 `[0, __length-1]​` 。
   
   建树采用动态开点的方法，而非堆式建树，占用空间很大。
   
   **注意：**以下大部分方法传参时都可以用 `-1` 来表示**上一个版本**的版本号。（对版本区间进行查询的方法不能使用 `-1` 来表示版本号，因为需要两个版本号来确定版本区间，`-1`的引入会导致混乱。）

#### 2.建立线段树

1. 数据类型

   构造参数 `_Iterator __first` ，表示区间维护的区间头。

   构造参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

   其它同上。

2. 时间复杂度

   $O(n)$。

3. 备注

   同上。

   使用迭代器进行初始化，可以将区间初状态直接赋到线段树里。

   如果通过本方法构造线段树，请确认区间范围不是特别大（ $10^6$ 以内）。本方法将一次性开出树中所有结点。

#### 3.设置内存池大小

1. 数据类型

   输入参数 `uint32_t __count`，表示程序运行最多用到的结点数量。

2. 时间复杂度

   $O(n)$

#### 4.重置

1. 数据类型

   输入参数 `uint64_t __length` ，表示线段树要处理的区间大小。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将线段树大小改变，并将之前的合并信息重置。版本号重新从 `0` 开始计。

#### 5.重置

1. 数据类型

   输入参数 `_Iterator __first` ，表示区间维护的区间头。

   输入参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

2. 时间复杂度

   $O(n)$。

3. 备注

   同上。

   使用迭代器进行重置，可以将区间初状态直接赋到线段树里。版本号重新从 `0` 开始计。

   如果通过本方法重置线段树，请确认区间范围不是特别大（ $10^6$ 以内）。本方法将一次性开出树中所有结点。

#### 6.复制版本

1. 数据类型

   输入参数 `uint32_t __prevVersion` ，表示要复制哪个版本。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本方法生成某个版本的副本，保存为下一个版本号。
   
   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）

#### 7.单点增值

1. 数据类型

   输入参数 `uint32_t __prevVersion` ，表示以哪个版本为基础进行修改。

   输入参数 `uint64_t __i` ，表示单点增值的下标。

   输入参数 `_Fp __inc​` ，表示增量大小。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）

   本函数没有进行参数检查，所以请自己确保下标合法。（位于 `[0, n)` ）

#### 8.区间增值

1. 数据类型

   输入参数 `uint32_t __prevVersion` ，表示以哪个版本为基础进行修改。

   输入参数 `uint64_t __left` ，表示增值的区间起始下标。

   输入参数 `uint64_t __right` ，表示增值的区间结尾下标。（闭区间）

   输入参数 `_Fp __inc​` ，表示增量大小。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）

   本函数没有进行参数检查，所以请自己确保下标合法。（位于 `[0, n)` ）

#### 9.单点查询

1. 数据类型

   输入参数 `uint32_t __version` ，表示查询哪个版本。

   输入参数 `uint64_t __i` ，表示查询的下标。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）

   本函数没有进行参数检查，所以请自己确保下标合法。（位于 `[0, n)` ）


#### 10.区间查询

1. 数据类型

   输入参数 `uint32_t __version` ，表示查询哪个版本。

   输入参数 `uint64_t __left` ，表示区间查询的开头下标。

   输入参数 `uint64_t __right`，表示区间查询的结尾下标。(闭区间)

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）

   本函数没有进行参数检查，所以请自己确保下标合法。（位于 `[0, n)` ）

#### 11.查询全部

1. 数据类型

   输入参数 `uint32_t __version` ，表示查询哪个版本。

2. 时间复杂度

   $O(1)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）

#### 12.树上二分查询左边界

1. 数据类型

   输入参数 `uint32_t __version` ，表示查询哪个版本。

   输入参数 `uint64_t __right` ，表示右边界。

   输入参数 `_Judge __judge` ，表示需要满足的判断条件。

   返回类型 `uint64_t` ，表示在满足条件情况下的最小左边界。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   假设本函数返回 `l` ，则表示，对于 `i∈[l, __right]`  ，均有 `__judge(__query(i, __right))` 为真。而当 `i<l` 时，有 `__judge(__query(i, __right))` 为假。显然，`l` 的最小值为 `0` 。

   如果从 `__right` 开始往左走，即使长度为一的区间也不能满足判断条件，那么返回 `__right+1`  。所以 `l` 的最大值为 `__right+1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

   **注意：**在树上二分的时候，需确保没有未初始化的结点。

#### 13.查询某个版本第k个元素

1. 数据类型

   输入参数 `uint32_t __version` ，表示查询哪个版本。

   输入参数 `_Tp __k` ，表示要查询的元素从小到大的顺次。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   顺次 $k$ 表示第 $k+1$ 小，顺次 $0$ 表示查询最小的元素。

   只有在线段树的元素类型 $T$ 为数字，且累积函数为加法的时候，本函数才有意义。

   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）

   本函数没有进行参数检查，所以请自己确保 `__k` 合法。（位于 `[0, queryAll(__version))` ）

#### 14.查询某个版本第k个元素

1. 数据类型

   输入参数 `uint32_t __version` ，表示查询哪个版本。

   输入参数 `_Tp __k` ，表示要查询的元素从小到大的顺次。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   顺次 $k$ 表示第 $k+1$ 小，顺次 $0$ 表示查询最小的元素。

   只有在线段树的元素类型 $T$ 为数字，且累积函数为加法的时候，本函数才有意义。

#### 15.查询某个版本区间的单点值

1. 数据类型

   输入参数 `uint32_t __leftVersion` ，表示查询版本区间的起点。

   输入参数 `uint32_t __rightVersion` ，表示查询版本区间的末尾。（闭区间）

   输入参数 `uint64_t __i` ，表示查询的下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   只有在线段树的元素类型 $T$ 为数字，且累积函数为加法的时候，本函数才有意义。

   函数采用差分，用两个版本的信息相减来获取之间的区间信息。
   
   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）
   
   本函数没有进行参数检查，所以请自己确保 `__k` 合法。（位于 `[0, queryAll(__version))` ）

#### 16.查询某个版本区间的区间和值

1. 数据类型

   输入参数 `uint32_t __leftVersion` ，表示查询版本区间的起点。

   输入参数 `uint32_t __rightVersion` ，表示查询版本区间的末尾。（闭区间）

   输入参数 `uint64_t __left` ，表示区间查询的开头下标。

   输入参数 `uint64_t __right`，表示区间查询的结尾下标。(闭区间)

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   只有在线段树的元素类型 $T$ 为数字，且累积函数为加法的时候，本函数才有意义。

   函数采用差分，用两个版本的信息相减来获取之间的区间信息。
   
   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）
   
   本函数没有进行参数检查，所以请自己确保下标合法。（位于 `[0, n)` ）

#### 17.在某个版本区间树上二分查询右边界

1. 数据类型

   输入参数 `uint32_t __leftVersion` ，表示查询版本区间的起点。

   输入参数 `uint32_t __rightVersion` ，表示查询版本区间的末尾。（闭区间）

   输入参数 `uint64_t __left` ，表示左边界。

   输入参数 `_Judge __judge` ，表示需要满足的判断条件。

   返回类型 `uint64_t` ，表示在满足条件情况下的最大右边界。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   只有在线段树的元素类型 $T$ 为数字，且累积函数为加法的时候，本函数才有意义。

   函数采用差分，用两个版本的信息相减来获取之间的区间信息。

   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）

   本函数没有进行参数检查，所以请自己确保下标合法。（位于 `[0, n)` ）

   **注意：**在树上二分的时候，需确保没有未初始化的结点。

#### 18.在某个版本区间树上二分查询左边界

1. 数据类型

   输入参数 `uint32_t __leftVersion` ，表示查询版本区间的起点。

   输入参数 `uint32_t __rightVersion` ，表示查询版本区间的末尾。（闭区间）

   输入参数 `uint64_t __right` ，表示右边界。

   输入参数 `_Judge __judge` ，表示需要满足的判断条件。

   返回类型 `uint64_t` ，表示在满足条件情况下的最小左边界。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   只有在线段树的元素类型 $T$ 为数字，且累积函数为加法的时候，本函数才有意义。

   函数采用差分，用两个版本的信息相减来获取之间的区间信息。

   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）

   本函数没有进行参数检查，所以请自己确保下标合法。（位于 `[0, n)` ）

   **注意：**在树上二分的时候，需确保没有未初始化的结点。

#### 19.查询某个版本区间第k个元素

1. 数据类型

   输入参数 `uint32_t __leftVersion` ，表示查询版本区间的起点。

   输入参数 `uint32_t __rightVersion` ，表示查询版本区间的末尾。（闭区间）

   输入参数 `_Tp __k` ，表示要查询的元素从小到大的顺次。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   顺次 $k$ 表示第 $k+1$ 小，顺次 $0$ 表示查询最小的元素。

   只有在线段树的元素类型 $T$ 为数字，且累积函数为加法的时候，本函数才有意义。

   函数采用差分，用两个版本的信息相减来获取之间的区间信息。
   
   本函数没有进行参数检查，所以请自己确保版本号合法。（位于 `[-1, versionCount())` ）
   
   本函数没有进行参数检查，所以请自己确保 `__k` 合法。

#### 16.查询版本数量

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   可以用来查询版本的数量，包括最初的版本 `0` 。

### 三、模板示例

```c++
#include "DS/PersistentLazySegTree.h"
#include "IO/FastIO.h"

int main() {
    //可持久化的带懒惰标记的线段树可以实现可持久化线段树的所有功能
    //唯一多出来的是区间修改功能

    //这是一个长度为5的空数组
    int A[5] = {0, 0, 0, 0, 0};
    //写一个默认的求和树
    OY::PersistentLazySegTree sum_tree(A, A + 5);

    cout << "version num=" << sum_tree.versionCount() << endl;

    sum_tree.add(-1, 2, 100);
    sum_tree.add(-1, 0, 1000);
    sum_tree.add(-1, 3, 10000);
    sum_tree.add(-1, 1, 100000);
    sum_tree.add(-1, 4, 1000000);

    cout << "version num=" << sum_tree.versionCount() << endl;

    //在版本 2 的基础上生成版本 6
    sum_tree.add(2, 0, 4, 77);
    cout << "version num=" << sum_tree.versionCount() << endl;
    for (int i = 0; i < 5; i++)
        cout << sum_tree.query(-1, i) << (i == 4 ? '\n' : ' ');
}
```

```
#输出如下
version num=1
version num=6
version num=7
1077 77 177 77 77


```

