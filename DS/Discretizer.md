### 一、模板类别

​	数据结构：离散化数组

### 二、模板功能

#### 1.建立离散化数组

1. 数据类型

   模板参数 `typename _Tp`​ ，表示离散化的元素类型。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本数据结构继承自 `std::vector` ，所以可以使用 `std::vector` 的成员方法。比如，为了减少数组的扩容复制次数，可以使用 `reserve` 方法预留空间。
   
   以下只介绍特有的方法。


#### 2.输入元素

1. 数据类型

   输入参数 `_Tp __item` ，表示要参与离散化的元素。

2. 时间复杂度

   $O(1)$ 。
   

#### 3.输入元素数组

1. 数据类型

   参数 `std::vector<_Tp> __items` ，表示要参与离散化的元素所组成的数组。

2. 时间复杂度

   $O(n)$  。

#### 4.输入元素二维数组

1. 数据类型

   参数 `std::vector<std::vector<_Tp>> __items` ，表示要参与离散化的元素所组成的二维数组。

2. 时间复杂度

   $O(n)$  。

#### 5.准备

1. 数据类型

2. 时间复杂度

   $O(n\log (n))$ 。
   
3. 备注

   本方法会对数组内的元素排序、去重，之后数组就不再接受新元素。


#### 6.获取排名

1. 数据类型

   输入参数 `_Tp __item`，表示要查询离散化编号的元素

2. 时间复杂度

   $O(log(n))$ 。
   
3. 备注

   如果该元素不在集合中，则返回若该元素在集合中，将会处于的名次。

#### 7.二分下界

1. 数据类型

   输入参数 `_Tp __item`，表示要查询的元素

2. 时间复杂度

   $O(log(n))$ 。
   
3. 备注

   等同于调用 `std::lower_bound` 。

#### 8.二分上界

1. 数据类型

   输入参数 `_Tp __item`，表示要查询的元素

2. 时间复杂度

   $O(log(n))$ 。

3. 备注

   等同于调用 `std::upper_bound` 。

### 三、模板示例

```c++
#include "DS/Discretizer.h"
#include "IO/FastIO.h"

int main(){
    OY::Discretizer D;
    D<<11<<22<<33;
    std::vector<int>arr{15,25,35};
    std::vector<std::vector<int>>arr_2d{{100,200},{400,300},{15,25}};
    D<<arr<<arr_2d;
    //准备后不会再接受数据
    D.prepare();
    for(int i=0;i<D.size();i++){
        cout<<"D["<<i<<"]=\t"<<D[i]<<endl;
    }
    cout<<"rank of "<<24<<"="<<D.rank(24)<<endl;
    cout<<"rank of "<<25<<"="<<D.rank(25)<<endl;
    cout<<"rank of "<<26<<"="<<D.rank(26)<<endl;
}
```

```
#输出如下
D[0]=	11
D[1]=	15
D[2]=	22
D[3]=	25
D[4]=	33
D[5]=	35
D[6]=	100
D[7]=	200
D[8]=	300
D[9]=	400
rank of 24=3
rank of 25=3
rank of 26=4

```

