### 一、模板类别

​	数据结构：累加器。

​	（这是自取的名字，该数据结构用来维护前缀和、后缀和，并提供暴力统计区间和的功能）

### 二、模板功能

#### 1.建立累加器

1. 数据类型

   模板参数 `typename _Tp` ，表示要进行区间维护的元素类型。

   模板参数 `typename _Operation`  ，表示区间操作的类。默认为 `_Tp` 的加法类。

   模板参数 `int _Mask`  ，表示该类的功能:

   1. 如果 `_Mask==0` ，表示只提供暴力统计区间和的功能；
   2. 如果 `_Mask==1` ，表示维护前缀和；
   3. 如果 `_Mask==2` ，表示维护后缀和；
   4. 如果 `_Mask==3` ，表示维护前缀和与后缀和；

   `_Mask` 默认值为 `3` 。

   构造参数 `int __n`​ ，表示区间维护的长度。

   构造参数 `_Operation __op` ，表示具体的区间操作函数。默认为 `_Operation` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Tp __defaultValue` ，表示默认元素值。默认为 `_Tp` 类的默认值。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   累加器处理的问题为区间维护，可以是区间最大值、区间最小值，也可以是区间按位或、区间按位与、区间最大公约数以及加法、乘法、按位异或等各种运算。

   如果在构造的时候不想直接填区间长度，可以设为 `0` 。
   
   累加器并不适合进行动态区间的维护，单点修改的时间复杂度很高。但是本模板仍然支持该方法。

#### 2.建立累加器

1. 数据类型

   构造参数 `_Iterator __first`​ ，表示区间维护的区间头。

   构造参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

   其余同上。

2. 时间复杂度

   同上。

3. 备注

   使用迭代器进行初始化，可以将区间初状态直接赋到累加器里。

#### 3.重置

1. 数据类型

   输入参数 `int __n` ，表示重置为的区间长度。

2. 时间复杂度

   $O(n)$ 。

#### 4.重置

1. 数据类型

   输入参数 `_Iterator __first` ，表示区间查询的区间头。

   输入参数 `_Iterator __last` ，表示区间查询的区间尾。（开区间）

2. 时间复杂度

   同上。

3. 备注

   使用迭代器进行重置，可以将区间初状态直接赋到累加器里。

#### 5.单点修改

1. 数据类型

   输入参数 `int __i` ，表示要修改的点的下标。

   输入参数 `_Tp __val` ，表示要修改为的值。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 6.查询前缀和

1. 数据类型

   输入参数 `int __i` ，表示要查询的前缀区间的尾下标。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数只有在 `_Mask&1>0` 的情况下适用。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 7.查询后缀和

1. 数据类型

   输入参数 `int __i` ，表示要查询的后缀区间的头下标。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数只有在 `_Mask&2>0` 的情况下适用。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 8.单点查询

1. 数据类型

   输入参数 `int __i` ，表示要查询的点的下标。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 9.区间查询

1. 数据类型

   输入参数 `int __left` ，表示要查询的区间的左边界下标。

   输入参数 `int __right` ，表示要查询的区间的右边界下标。（闭区间）

2. 时间复杂度

   $O(n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 10.查询全部

1. 数据类型

2. 时间复杂度

   $O(1\sim n)$。
   
3. 备注

   本函数在不同的情况下采用不同的策略。

### 三、模板示例

```c++
#include "DS/Accumulator.h"
#include "IO/FastIO.h"

int main() {
    //先给出一个长度为 10 的数组
    int A[10] = {11, 5, 9, 12, 8, 4, 6, 15, 7, 7};
    for (int i = 0; i < 10; i++)
        cout << A[i] << (i == 9 ? '\n' : ' ');

    //建立一个区间最大值累加器
    auto mymax = [](int x, int y) {
        return x > y ? x : y;
    };
    //一般可以忽略模板参数
    OY::Accumulator acc_max(A, A + 10, mymax);
    cout << "max(A[3~6])     =" << acc_max.query(3, 6) << endl;

    //建立一个区间最小值累加器
    //甚至可以适用 stl 的最值函数
    OY::Accumulator acc_min(A, A + 10, std::min);
    cout << "min(A[3~6])     =" << acc_min.query(3, 6) << endl;

    //建立一个区间最大公约数累加器
    //可以在参数框里写 lambda
    OY::Accumulator acc_gcd(A, A + 10, [](int x, int y) { return std::gcd(x, y); });
    cout << "gcd(A[3~6])     =" << acc_gcd.query(3, 6) << endl;

    //建立一个区间按位与累加器
    //按位与的函数类具有默认构造，可以忽略构造参数
    OY::Accumulator acc_bit_and(A, A + 10, std::bit_and());
    cout << "bit_and(A[3~6]) =" << acc_bit_and.query(3, 6) << endl;

    //建立一个区间按位或累加器
    //一开始可以是空的
    OY::Accumulator acc_bit_or(0, std::bit_or<int>());
    acc_bit_or.reset(A, A + 10);
    cout << "bit_or(A[3~6])  =" << acc_bit_or.query(3, 6) << endl;

    //最后的便利化措施：由于实际使用的时候，往往是和值较多，所以无参构造为和值累加器
    OY::Accumulator acc_default;
    acc_default.reset(A, A + 10);
    cout << "sum(A[0~9])     =" << acc_default.query(0, 9) << endl;

    //最新的累加器支持开指定大小的空表；也支持对单点进行修改（当然速度很慢）
    OY::Accumulator new_acc(10,std::min<int>);
    for(int i=0;i<10;i++)new_acc.update(i,A[i]);
    cout << "min(A[3~6]) =" << new_acc.query(3, 6) << endl;

    new_acc.update(4,2);
    cout << "A[4]        =" << new_acc.query(4) << endl;
    cout << "min(A[3~6]) =" << new_acc.query(3, 6) << endl;
}
```

```
#输出如下
11 5 9 12 8 4 6 15 7 7
max(A[3~6])     =12
min(A[3~6])     =4
gcd(A[3~6])     =2
bit_and(A[3~6]) =0
bit_or(A[3~6])  =14
sum(A[0~9])     =84
min(A[3~6]) =4
A[4]        =2
min(A[3~6]) =2

```

